diff -rNu gcc-4.9.2/config.guess test/gcc-4.9.2/config.guess
--- gcc-4.9.2/config.guess	2013-10-02 00:50:56.000000000 +0800
+++ test/gcc-4.9.2/config.guess	2018-04-02 14:15:44.000000000 +0800
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2013 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2013-06-10'
+timestamp='2015-07-03'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -24,12 +24,12 @@
 # program.  This Exception is an additional permission under section 7
 # of the GNU General Public License, version 3 ("GPLv3").
 #
-# Originally written by Per Bothner.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
 # http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 #
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 
 
 me=`echo "$0" | sed -e 's,.*/,,'`
@@ -50,7 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2013 Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -149,7 +149,7 @@
 	LIBC=gnu
 	#endif
 	EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
 	;;
 esac
 
@@ -168,20 +168,27 @@
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+	    arm*|earm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
@@ -197,6 +204,13 @@
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -207,13 +221,13 @@
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
 	exit ;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
@@ -579,8 +593,9 @@
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -826,7 +841,7 @@
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
-    i*:MSYS*:*)
+    *:MSYS*:*)
 	echo ${UNAME_MACHINE}-pc-msys
 	exit ;;
     i*:windows32*:*)
@@ -932,6 +947,9 @@
     crisv32:Linux:*:*)
 	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     frv:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
@@ -969,10 +987,10 @@
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or1k:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
 	exit ;;
-    or32:Linux:*:*)
+    or32:Linux:*:* | or1k*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
@@ -1020,7 +1038,7 @@
 	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
@@ -1260,16 +1278,26 @@
 	if test "$UNAME_PROCESSOR" = unknown ; then
 	    UNAME_PROCESSOR=powerpc
 	fi
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		grep IS_64BIT_ARCH >/dev/null
-	    then
-		case $UNAME_PROCESSOR in
-		    i386) UNAME_PROCESSOR=x86_64 ;;
-		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
-		esac
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
 	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
 	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
@@ -1361,154 +1389,6 @@
 	exit ;;
 esac
 
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-	"4"
-#else
-	""
-#endif
-	); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
-
 cat >&2 <<EOF
 $0: unable to guess system type
 
diff -rNu gcc-4.9.2/config.sub test/gcc-4.9.2/config.sub
--- gcc-4.9.2/config.sub	2013-10-02 00:50:56.000000000 +0800
+++ test/gcc-4.9.2/config.sub	2018-04-02 14:15:44.000000000 +0800
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2013 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2013-10-01'
+timestamp='2015-07-28'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@
 # of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -68,7 +68,7 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2013 Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -117,7 +117,7 @@
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
@@ -255,12 +255,13 @@
 	| arc | arceb \
 	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
 	| avr | avr32 \
+	| ba \
 	| be32 | be64 \
 	| bfin \
 	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia64 \
@@ -283,8 +284,10 @@
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipsr5900 | mipsr5900el \
@@ -296,11 +299,11 @@
 	| nds32 | nds32le | nds32be \
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| open8 \
-	| or1k | or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
+	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
@@ -311,6 +314,7 @@
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -325,6 +329,9 @@
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
 	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -370,12 +377,13 @@
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| ba-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
@@ -402,8 +410,10 @@
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipsr5900-* | mipsr5900el-* \
@@ -415,16 +425,18 @@
 	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
+	| riscv32-* | riscv64-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile*-* \
@@ -432,6 +444,7 @@
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -508,6 +521,9 @@
 		basic_machine=i386-pc
 		os=-aros
 		;;
+        asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -769,6 +785,9 @@
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -824,6 +843,10 @@
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -1356,7 +1379,7 @@
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
 	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
@@ -1369,14 +1392,14 @@
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1594,9 +1617,6 @@
 	mips*-*)
 		os=-elf
 		;;
-	or1k-*)
-		os=-elf
-		;;
 	or32-*)
 		os=-coff
 		;;
diff -rNu gcc-4.9.2/gcc/calls.c test/gcc-4.9.2/gcc/calls.c
--- gcc-4.9.2/gcc/calls.c	2014-03-20 19:35:22.000000000 +0800
+++ test/gcc-4.9.2/gcc/calls.c	2018-04-02 14:15:31.000000000 +0800
@@ -1499,8 +1499,10 @@
 	      args[i].initial_value
 		= gen_lowpart_SUBREG (mode, args[i].value);
 	      SUBREG_PROMOTED_VAR_P (args[i].initial_value) = 1;
-	      SUBREG_PROMOTED_UNSIGNED_SET (args[i].initial_value,
-					    args[i].unsignedp);
+	      if (promoted_for_signed_and_unsigned_p (args[i].tree_value, mode))
+		SUBREG_PROMOTED_SET (args[i].initial_value, SRP_SIGNED_AND_UNSIGNED);
+	      else
+		SUBREG_PROMOTED_SET (args[i].initial_value, args[i].unsignedp);
 	    }
 	}
     }
@@ -3375,7 +3377,7 @@
 
 	  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);
 	  SUBREG_PROMOTED_VAR_P (target) = 1;
-	  SUBREG_PROMOTED_UNSIGNED_SET (target, unsignedp);
+	  SUBREG_PROMOTED_SET (target, unsignedp);
 	}
 
       /* If size of args is variable or this was a constructor call for a stack
diff -rNu gcc-4.9.2/gcc/c-family/c.opt test/gcc-4.9.2/gcc/c-family/c.opt
--- gcc-4.9.2/gcc/c-family/c.opt	2014-04-03 21:41:55.000000000 +0800
+++ test/gcc-4.9.2/gcc/c-family/c.opt	2018-04-02 14:15:41.000000000 +0800
@@ -1323,6 +1323,10 @@
 C++ ObjC++
 Do not search standard system include directories for C++
 
+nostdlib++
+Driver
+Do not link standard C++ runtime library
+
 o
 C ObjC C++ ObjC++ Joined Separate
 ; Documented in common.opt
diff -rNu gcc-4.9.2/gcc/cfgexpand.c test/gcc-4.9.2/gcc/cfgexpand.c
--- gcc-4.9.2/gcc/cfgexpand.c	2014-04-22 21:15:24.000000000 +0800
+++ test/gcc-4.9.2/gcc/cfgexpand.c	2018-04-02 14:15:31.000000000 +0800
@@ -3265,7 +3265,7 @@
 	      ;
 	    else if (promoted)
 	      {
-		int unsignedp = SUBREG_PROMOTED_UNSIGNED_P (target);
+		int unsignedp = SUBREG_PROMOTED_SIGN (target);
 		/* If TEMP is a VOIDmode constant, use convert_modes to make
 		   sure that we properly convert it.  */
 		if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)
@@ -3277,7 +3277,14 @@
 					  GET_MODE (target), temp, unsignedp);
 		  }
 
-		convert_move (SUBREG_REG (target), temp, unsignedp);
+		if ((SUBREG_PROMOTED_GET (target) == SRP_SIGNED_AND_UNSIGNED)
+		    && (GET_CODE (temp) == SUBREG)
+		    && SUBREG_PROMOTED_VAR_P (temp)
+		    && (GET_MODE (target) == GET_MODE (temp))
+		    && (GET_MODE (SUBREG_REG (target)) == GET_MODE (SUBREG_REG (temp))))
+		  emit_move_insn (SUBREG_REG (target), SUBREG_REG (temp));
+		else
+		  convert_move (SUBREG_REG (target), temp, unsignedp);
 	      }
 	    else if (nontemporal && emit_storent_insn (target, temp))
 	      ;
diff -rNu gcc-4.9.2/gcc/combine.c test/gcc-4.9.2/gcc/combine.c
--- gcc-4.9.2/gcc/combine.c	2014-07-08 23:43:39.000000000 +0800
+++ test/gcc-4.9.2/gcc/combine.c	2018-04-02 14:15:31.000000000 +0800
@@ -12433,7 +12433,7 @@
       rsp = &reg_stat[regno];
       if (rsp->last_set == insn)
 	{
-	  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)
+	  if (SUBREG_PROMOTED_UNSIGNED_P (subreg))
 	    rsp->last_set_nonzero_bits &= GET_MODE_MASK (mode);
 	}
 
diff -rNu gcc-4.9.2/gcc/common.opt test/gcc-4.9.2/gcc/common.opt
--- gcc-4.9.2/gcc/common.opt	2014-04-07 21:27:39.000000000 +0800
+++ test/gcc-4.9.2/gcc/common.opt	2018-04-02 14:15:41.000000000 +0800
@@ -898,6 +898,10 @@
 Common Report Var(flag_btr_bb_exclusive) Optimization
 Restrict target load migration not to re-use registers in any basic block
 
+fbypass-load-on-store
+Common Report Var(flag_bypass_load_on_store) Optimization
+Bypass load on store collision
+
 fcall-saved-
 Common Joined RejectNegative Var(common_deferred_options) Defer
 -fcall-saved-<register>	Mark <register> as being preserved across functions
@@ -993,6 +997,10 @@
 Common Report Var(flag_debug_types_section) Init(0)
 Output .debug_types section when using DWARF v4 debuginfo.
 
+fdebug-unwind-tables
+Common Report Var(flag_debug_unwind_tables) Init(0)
+Generate unwind tables in .debug_frame also, when exception unwind tables enabled
+
 ; Nonzero for -fdefer-pop: don't pop args after each function call
 ; instead save them up to pop many calls' args with one insns.
 fdefer-pop
@@ -1072,6 +1080,10 @@
 Common Joined RejectNegative Var(common_deferred_options) Defer
 -fdisable-[tree|rtl|ipa]-<pass>=range1+range2 disables an optimization pass
 
+fdisable-c11-self-mod-expr
+Common RejectNegative Report Var(flag_disable_c11_self_mod_expr) Init(0) Optimization
+Disable c11 restriction on self modifying expression of gimplifier
+
 fenable-
 Common Joined RejectNegative Var(common_deferred_options) Defer
 -fenable-[tree|rtl|ipa]-<pass>=range1+range2 enables an optimization pass
@@ -1119,6 +1131,10 @@
 Common Report Var(flag_eliminate_dwarf2_dups)
 Perform DWARF2 duplicate elimination
 
+fextelim
+Common Report Var(flag_extelim)
+Perform zero/sign extension removal
+
 fipa-sra
 Common Report Var(flag_ipa_sra) Init(0) Optimization
 Perform interprocedural reduction of aggregates
@@ -1467,6 +1483,10 @@
 Common Report Var(flag_ivopts) Init(1) Optimization
 Optimize induction variables on trees
 
+fuse-seq-load-indexes
+Common Report Var(flag_use_seq_load_indexes) Init(1) Optimization
+Supress sequential load update and indexed loads with two indexed loads which exploits pipeline
+
 fjump-tables
 Common Var(flag_jump_tables) Init(1) Optimization
 Use jump tables for sufficiently large switch statements
@@ -1591,6 +1611,10 @@
 Common Report Var(flag_omit_frame_pointer) Optimization
 When possible do not generate stack frames
 
+fopt-array-offset
+Common Report Var(flag_opt_array_offset)
+Expand array offset address calculations
+
 fopt-info
 Common Report Var(flag_opt_info) Optimization
 Enable all optimization info dumps on stderr
@@ -2014,6 +2038,10 @@
 Common Joined RejectNegative Enum(tls_model) Var(flag_tls_default) Init(TLS_MODEL_GLOBAL_DYNAMIC)
 -ftls-model=[global-dynamic|local-dynamic|initial-exec|local-exec]	Set the default thread-local storage code generation model
 
+fwiden-types
+Common Report Var(flag_widen_types)
+Widen signed integral variables (local, whose address has not been taken, non-volatile and having precision less than that of long) to long (retaining original qualifiers)
+
 Enum
 Name(tls_model) Type(enum tls_model) UnknownError(unknown TLS model %qs)
 
@@ -2264,6 +2292,14 @@
 fuse-linker-plugin
 Common Undocumented Var(flag_use_linker_plugin)
 
+; Initialize flag_use_load_updates to -1
+; That way, it gets set to 1 on -fuse-load-updates and to 0 on -fno-use-load-updates
+; when these options are explicitly used by the user. This helps us default it to ON
+; on 64-bit and OFF in 32-bit
+fuse-load-updates
+Common Report Var(flag_use_load_updates) Init(-1) Optimization
+Support generation of {load, store}-with-update instructions past non-unit increments
+
 ; Positive if we should track variables, negative if we should run
 ; the var-tracking pass only to discard debug annotations, zero if
 ; we're not to run it.  When flag_var_tracking == 2 (AUTODETECT_VALUE) it
diff -rNu gcc-4.9.2/gcc/config/alpha/linux-elf.h test/gcc-4.9.2/gcc/config/alpha/linux-elf.h
--- gcc-4.9.2/gcc/config/alpha/linux-elf.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/alpha/linux-elf.h	2018-04-02 14:15:42.000000000 +0800
@@ -23,8 +23,8 @@
 #define EXTRA_SPECS \
 { "elf_dynamic_linker", ELF_DYNAMIC_LINKER },
 
-#define GLIBC_DYNAMIC_LINKER	"/lib/ld-linux.so.2"
-#define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#define GLIBC_DYNAMIC_LINKER	SYSTEMLIBS_DIR "ld-linux.so.2"
+#define UCLIBC_DYNAMIC_LINKER  SYSTEMLIBS_DIR "ld-uClibc.so.0"
 #if DEFAULT_LIBC == LIBC_UCLIBC
 #define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:" G ";:" U "}"
 #elif DEFAULT_LIBC == LIBC_GLIBC
diff -rNu gcc-4.9.2/gcc/config/arm/linux-eabi.h test/gcc-4.9.2/gcc/config/arm/linux-eabi.h
--- gcc-4.9.2/gcc/config/arm/linux-eabi.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/arm/linux-eabi.h	2018-04-02 14:15:42.000000000 +0800
@@ -68,8 +68,8 @@
    GLIBC_DYNAMIC_LINKER_DEFAULT and TARGET_DEFAULT_FLOAT_ABI.  */
 
 #undef  GLIBC_DYNAMIC_LINKER
-#define GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "/lib/ld-linux.so.3"
-#define GLIBC_DYNAMIC_LINKER_HARD_FLOAT "/lib/ld-linux-armhf.so.3"
+#define GLIBC_DYNAMIC_LINKER_SOFT_FLOAT SYSTEMLIBS_DIR "ld-linux.so.3"
+#define GLIBC_DYNAMIC_LINKER_HARD_FLOAT SYSTEMLIBS_DIR "ld-linux-armhf.so.3"
 #define GLIBC_DYNAMIC_LINKER_DEFAULT GLIBC_DYNAMIC_LINKER_SOFT_FLOAT
 
 #define GLIBC_DYNAMIC_LINKER \
diff -rNu gcc-4.9.2/gcc/config/arm/linux-elf.h test/gcc-4.9.2/gcc/config/arm/linux-elf.h
--- gcc-4.9.2/gcc/config/arm/linux-elf.h	2014-05-27 19:42:10.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/arm/linux-elf.h	2018-04-02 14:15:42.000000000 +0800
@@ -62,7 +62,7 @@
 
 #define LIBGCC_SPEC "%{mfloat-abi=soft*:-lfloat} -lgcc"
 
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER SYSTEMLIBS_DIR "ld-linux.so.2"
 
 #define LINUX_TARGET_LINK_SPEC  "%{h*} \
    %{static:-Bstatic} \
diff -rNu gcc-4.9.2/gcc/config/i386/linux64.h test/gcc-4.9.2/gcc/config/i386/linux64.h
--- gcc-4.9.2/gcc/config/i386/linux64.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/i386/linux64.h	2018-04-02 14:15:42.000000000 +0800
@@ -27,6 +27,6 @@
 #define GNU_USER_LINK_EMULATION64 "elf_x86_64"
 #define GNU_USER_LINK_EMULATIONX32 "elf32_x86_64"
 
-#define GLIBC_DYNAMIC_LINKER32 "/lib/ld-linux.so.2"
-#define GLIBC_DYNAMIC_LINKER64 "/lib64/ld-linux-x86-64.so.2"
-#define GLIBC_DYNAMIC_LINKERX32 "/libx32/ld-linux-x32.so.2"
+#define GLIBC_DYNAMIC_LINKER32 SYSTEMLIBS_DIR "ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER64 SYSTEMLIBS_DIR "ld-linux-x86-64.so.2"
+#define GLIBC_DYNAMIC_LINKERX32 SYSTEMLIBS_DIR "ld-linux-x32.so.2"
diff -rNu gcc-4.9.2/gcc/config/i386/linux.h test/gcc-4.9.2/gcc/config/i386/linux.h
--- gcc-4.9.2/gcc/config/i386/linux.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/i386/linux.h	2018-04-02 14:15:42.000000000 +0800
@@ -20,4 +20,4 @@
 <http://www.gnu.org/licenses/>.  */
 
 #define GNU_USER_LINK_EMULATION "elf_i386"
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER SYSTEMLIBS_DIR "ld-linux.so.2"
diff -rNu gcc-4.9.2/gcc/config/i386/t-linux64 test/gcc-4.9.2/gcc/config/i386/t-linux64
--- gcc-4.9.2/gcc/config/i386/t-linux64	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/i386/t-linux64	2018-04-02 14:15:41.000000000 +0800
@@ -32,7 +32,5 @@
 #
 comma=,
 MULTILIB_OPTIONS    = $(subst $(comma),/,$(TM_MULTILIB_CONFIG))
-MULTILIB_DIRNAMES   = $(patsubst m%, %, $(subst /, ,$(MULTILIB_OPTIONS)))
-MULTILIB_OSDIRNAMES = m64=../lib64$(call if_multiarch,:x86_64-linux-gnu)
-MULTILIB_OSDIRNAMES+= m32=$(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:i386-linux-gnu)
-MULTILIB_OSDIRNAMES+= mx32=../libx32$(call if_multiarch,:x86_64-linux-gnux32)
+MULTILIB_DIRNAMES = . .
+MULTILIB_OSDIRNAMES = ../$(shell basename $(base_libdir)) ../$(shell basename $(base_libdir))
diff -rNu gcc-4.9.2/gcc/config/linux.h test/gcc-4.9.2/gcc/config/linux.h
--- gcc-4.9.2/gcc/config/linux.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/linux.h	2018-04-02 14:15:42.000000000 +0800
@@ -73,10 +73,10 @@
    GLIBC_DYNAMIC_LINKER must be defined for each target using them, or
    GLIBC_DYNAMIC_LINKER32 and GLIBC_DYNAMIC_LINKER64 for targets
    supporting both 32-bit and 64-bit compilation.  */
-#define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKERX32 "/lib/ldx32-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER SYSTEMLIBS_DIR "ld-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER32 SYSTEMLIBS_DIR "ld-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER64 SYSTEMLIBS_DIR "ld64-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKERX32 SYSTEMLIBS_DIR "ldx32-uClibc.so.0"
 #define BIONIC_DYNAMIC_LINKER "/system/bin/linker"
 #define BIONIC_DYNAMIC_LINKER32 "/system/bin/linker"
 #define BIONIC_DYNAMIC_LINKER64 "/system/bin/linker64"
diff -rNu gcc-4.9.2/gcc/config/mips/linux64.h test/gcc-4.9.2/gcc/config/mips/linux64.h
--- gcc-4.9.2/gcc/config/mips/linux64.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/mips/linux64.h	2018-04-02 14:15:42.000000000 +0800
@@ -23,20 +23,20 @@
 #define GNU_USER_LINK_EMULATIONN32 "elf32%{EB:b}%{EL:l}tsmipn32"
 
 #define GLIBC_DYNAMIC_LINKER32 \
-  "%{mnan=2008:/lib/ld-linux-mipsn8.so.1;:/lib/ld.so.1}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-linux-mipsn8.so.1;:" SYSTEMLIBS_DIR "ld.so.1}"
 #define GLIBC_DYNAMIC_LINKER64 \
-  "%{mnan=2008:/lib64/ld-linux-mipsn8.so.1;:/lib64/ld.so.1}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-linux-mipsn8.so.1;:" SYSTEMLIBS_DIR "ld.so.1}"
 #define GLIBC_DYNAMIC_LINKERN32 \
-  "%{mnan=2008:/lib32/ld-linux-mipsn8.so.1;:/lib32/ld.so.1}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-linux-mipsn8.so.1;:" SYSTEMLIBS_DIR "ld.so.1}"
 
 #undef UCLIBC_DYNAMIC_LINKER32
 #define UCLIBC_DYNAMIC_LINKER32 \
-  "%{mnan=2008:/lib/ld-uClibc-mipsn8.so.0;:/lib/ld-uClibc.so.0}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-uClibc-mipsn8.so.0;:" SYSTEMLIBS_DIR "ld-uClibc.so.0}"
 #undef UCLIBC_DYNAMIC_LINKER64
 #define UCLIBC_DYNAMIC_LINKER64 \
-  "%{mnan=2008:/lib/ld64-uClibc-mipsn8.so.0;:/lib/ld64-uClibc.so.0}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld64-uClibc-mipsn8.so.0;:" SYSTEMLIBS_DIR "ld64-uClibc.so.0}"
 #define UCLIBC_DYNAMIC_LINKERN32 \
-  "%{mnan=2008:/lib32/ld-uClibc-mipsn8.so.0;:/lib32/ld-uClibc.so.0}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-uClibc-mipsn8.so.0;:" SYSTEMLIBS_DIR "ld-uClibc.so.0}"
 
 #define BIONIC_DYNAMIC_LINKERN32 "/system/bin/linker32"
 #define GNU_USER_DYNAMIC_LINKERN32 \
diff -rNu gcc-4.9.2/gcc/config/mips/linux.h test/gcc-4.9.2/gcc/config/mips/linux.h
--- gcc-4.9.2/gcc/config/mips/linux.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/mips/linux.h	2018-04-02 14:15:42.000000000 +0800
@@ -18,8 +18,8 @@
 <http://www.gnu.org/licenses/>.  */
 
 #define GLIBC_DYNAMIC_LINKER \
-  "%{mnan=2008:/lib/ld-linux-mipsn8.so.1;:/lib/ld.so.1}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-linux-mipsn8.so.1;:" SYSTEMLIBS_DIR "ld.so.1}"
 
 #undef UCLIBC_DYNAMIC_LINKER
 #define UCLIBC_DYNAMIC_LINKER \
-  "%{mnan=2008:/lib/ld-uClibc-mipsn8.so.0;:/lib/ld-uClibc.so.0}"
+  "%{mnan=2008:" SYSTEMLIBS_DIR "ld-uClibc-mipsn8.so.0;:" SYSTEMLIBS_DIR "ld-uClibc.so.0}"
diff -rNu gcc-4.9.2/gcc/config/mips/t-linux64 test/gcc-4.9.2/gcc/config/mips/t-linux64
--- gcc-4.9.2/gcc/config/mips/t-linux64	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/mips/t-linux64	2018-04-02 14:15:41.000000000 +0800
@@ -17,10 +17,6 @@
 # <http://www.gnu.org/licenses/>.
 
 MULTILIB_OPTIONS = mabi=n32/mabi=32/mabi=64
-MULTILIB_DIRNAMES = n32 32 64
-MIPS_EL = $(if $(filter %el, $(firstword $(subst -, ,$(target)))),el)
-MIPS_SOFT = $(if $(strip $(filter MASK_SOFT_FLOAT_ABI, $(target_cpu_default)) $(filter soft, $(with_float))),soft)
-MULTILIB_OSDIRNAMES = \
-	../lib32$(call if_multiarch,:mips64$(MIPS_EL)-linux-gnuabin32$(MIPS_SOFT)) \
-	../lib$(call if_multiarch,:mips$(MIPS_EL)-linux-gnu$(MIPS_SOFT)) \
-	../lib64$(call if_multiarch,:mips64$(MIPS_EL)-linux-gnuabi64$(MIPS_SOFT))
+MULTILIB_DIRNAMES = . . .
+MULTILIB_OSDIRNAMES = ../$(shell basename $(base_libdir)) ../$(shell basename $(base_libdir)) ../$(shell basename $(base_libdir))
+
diff -rNu gcc-4.9.2/gcc/config/rs6000/altivec.h test/gcc-4.9.2/gcc/config/rs6000/altivec.h
--- gcc-4.9.2/gcc/config/rs6000/altivec.h	2014-03-28 04:07:16.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/altivec.h	2018-04-02 14:15:30.000000000 +0800
@@ -371,6 +371,30 @@
 #define vec_vupklsw __builtin_vec_vupklsw
 #endif
 
+#ifdef __ALTIVEC2__
+/* New Altivec instructions */
+#define vec_absd __builtin_vec_absd
+#define vec_lvexbx __builtin_vec_lvexbx
+#define vec_lvexhx __builtin_vec_lvexhx
+#define vec_lvexwx __builtin_vec_lvexwx
+#define vec_stvexbx __builtin_vec_stvexbx
+#define vec_stvexhx __builtin_vec_stvexhx
+#define vec_stvexwx __builtin_vec_stvexwx
+#define vec_lvswx __builtin_vec_lvswx
+#define vec_lvswxl __builtin_vec_lvswxl
+#define vec_stvswx __builtin_vec_stvswx
+#define vec_stvswxl __builtin_vec_stvswxl
+#define vec_lvsm __builtin_vec_lvsm
+#define vec_lvtlx __builtin_vec_lvtlx
+#define vec_lvtlxl __builtin_vec_lvtlxl
+#define vec_lvtrx __builtin_vec_lvtrx
+#define vec_lvtrxl __builtin_vec_lvtrxl
+#define vec_stvflx __builtin_vec_stvflx
+#define vec_stvflxl __builtin_vec_stvflxl
+#define vec_stvfrx __builtin_vec_stvfrx
+#define vec_stvfrxl __builtin_vec_stvfrxl
+#endif
+
 /* Predicates.
    For C++, we use templates in order to allow non-parenthesized arguments.
    For C, instead, we use macros since non-parenthesized arguments were
diff -rNu gcc-4.9.2/gcc/config/rs6000/altivec.md test/gcc-4.9.2/gcc/config/rs6000/altivec.md
--- gcc-4.9.2/gcc/config/rs6000/altivec.md	2014-10-13 10:33:20.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/altivec.md	2018-04-02 14:15:30.000000000 +0800
@@ -81,9 +81,11 @@
    UNSPEC_LVSL
    UNSPEC_LVSR
    UNSPEC_LVE
+   UNSPEC_LVEX
    UNSPEC_STVX
    UNSPEC_STVXL
    UNSPEC_STVE
+   UNSPEC_STVEX
    UNSPEC_SET_VSCR
    UNSPEC_GET_VRSAVE
    UNSPEC_LVX
@@ -111,6 +113,19 @@
    UNSPEC_STVLXL
    UNSPEC_STVRX
    UNSPEC_STVRXL
+   UNSPEC_LVTLX
+   UNSPEC_LVTLXL
+   UNSPEC_LVTRX
+   UNSPEC_LVTRXL
+   UNSPEC_STVFLX
+   UNSPEC_STVFLXL
+   UNSPEC_STVFRX
+   UNSPEC_STVFRXL
+   UNSPEC_LVSWX
+   UNSPEC_LVSWXL
+   UNSPEC_STVSWX
+   UNSPEC_STVSWXL
+   UNSPEC_LVSM
    UNSPEC_VMULWHUB
    UNSPEC_VMULWLUB
    UNSPEC_VMULWHSB
@@ -131,6 +146,9 @@
    UNSPEC_VUPKLS_V4SF
    UNSPEC_VUPKHU_V4SF
    UNSPEC_VUPKLU_V4SF
+   UNSPEC_VABSDUB
+   UNSPEC_VABSDUH
+   UNSPEC_VABSDUW
    UNSPEC_VGBBD
    UNSPEC_VMRGH_DIRECT
    UNSPEC_VMRGL_DIRECT
@@ -401,6 +419,34 @@
 
 ;; Simple binary operations.
 
+;; absd
+(define_insn "altivec_vabsduw"
+  [(set (match_operand:V4SI 0 "register_operand" "=v")
+        (unspec:V4SI [(match_operand:V4SI 1 "register_operand" "v")
+                      (match_operand:V4SI 2 "register_operand" "v")]
+		     UNSPEC_VABSDUW))]
+  "TARGET_ALTIVEC2"
+  "vabsduw %0,%1,%2"
+  [(set_attr "type" "vecsimple")])
+
+(define_insn "altivec_vabsduh"
+  [(set (match_operand:V8HI 0 "register_operand" "=v")
+        (unspec:V8HI [(match_operand:V8HI 1 "register_operand" "v")
+                      (match_operand:V8HI 2 "register_operand" "v")]
+		     UNSPEC_VABSDUH))]
+  "TARGET_ALTIVEC2"
+  "vabsduh %0,%1,%2"
+  [(set_attr "type" "vecsimple")])
+
+(define_insn "altivec_vabsdub"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand:V16QI 1 "register_operand" "v")
+                       (match_operand:V16QI 2 "register_operand" "v")]
+		      UNSPEC_VABSDUB))]
+  "TARGET_ALTIVEC2"
+  "vabsdub %0,%1,%2"
+  [(set_attr "type" "vecsimple")])
+
 ;; add
 (define_insn "add<mode>3"
   [(set (match_operand:VI2 0 "register_operand" "=v")
@@ -2416,6 +2462,15 @@
   "lvewx %0,%y1"
   [(set_attr "type" "vecload")])
 
+(define_insn "altivec_lvex<VI_char>x"
+  [(parallel
+    [(set (match_operand:VI 0 "register_operand" "=v")
+         (match_operand:VI 1 "memory_operand" "Z"))
+     (unspec [(const_int 0)] UNSPEC_LVEX)])]
+  "TARGET_ALTIVEC2"
+  "lvex<VI_char>x %0,%y1"
+  [(set_attr "type" "vecload")])
+
 (define_expand "altivec_lvxl_<mode>"
   [(parallel
     [(set (match_operand:VM2 0 "register_operand" "=v")
@@ -2534,6 +2589,13 @@
   "stvewx %1,%y0"
   [(set_attr "type" "vecstore")])
 
+(define_insn "altivec_stvex<VI_char>x"
+  [(set (match_operand:<VI_scalar> 0 "memory_operand" "=Z")
+	(unspec:<VI_scalar> [(match_operand:VI 1 "register_operand" "v")] UNSPEC_STVEX))]
+  "TARGET_ALTIVEC2"
+  "stvex<VI_char>x %1,%y0"
+  [(set_attr "type" "vecstore")])
+
 ;; Generate
 ;;    xxlxor/vxor SCRATCH0,SCRATCH0,SCRATCH0
 ;;    vsubu?m SCRATCH2,SCRATCH1,%1
@@ -3199,6 +3261,116 @@
   "stvrxl %1,%y0"
   [(set_attr "type" "vecstore")])
 
+(define_insn "altivec_lvtlx"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVTLX))]
+  "TARGET_ALTIVEC2"
+  "lvtlx %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_lvtlxl"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVTLXL))]
+  "TARGET_ALTIVEC2"
+  "lvtlxl %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_lvtrx"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVTRX))]
+  "TARGET_ALTIVEC2"
+  "lvtrx %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_lvtrxl"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVTRXL))]
+  "TARGET_ALTIVEC2"
+  "lvtrxl %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_stvflx"
+  [(parallel
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
+     (unspec [(const_int 0)] UNSPEC_STVFLX)])]
+  "TARGET_ALTIVEC2"
+  "stvflx %1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "altivec_stvflxl"
+  [(parallel
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
+     (unspec [(const_int 0)] UNSPEC_STVFLXL)])]
+  "TARGET_ALTIVEC2"
+  "stvflxl %1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "altivec_stvfrx"
+  [(parallel
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
+     (unspec [(const_int 0)] UNSPEC_STVFRX)])]
+  "TARGET_ALTIVEC2"
+  "stvfrx %1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "altivec_stvfrxl"
+  [(parallel
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
+     (unspec [(const_int 0)] UNSPEC_STVFRXL)])]
+  "TARGET_ALTIVEC2"
+  "stvfrxl %1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "altivec_lvswx"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVSWX))]
+  "TARGET_ALTIVEC2"
+  "lvswx %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_lvswxl"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVSWXL))]
+  "TARGET_ALTIVEC2"
+  "lvswxl %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_lvsm"
+  [(set (match_operand:V16QI 0 "register_operand" "=v")
+        (unspec:V16QI [(match_operand 1 "memory_operand" "Z")] 
+		      UNSPEC_LVSM))]
+  "TARGET_ALTIVEC2"
+  "lvsm %0,%y1"
+  [(set_attr "type" "vecload")])
+
+(define_insn "altivec_stvswx"
+  [(parallel
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
+     (unspec [(const_int 0)] UNSPEC_STVSWX)])]
+  "TARGET_ALTIVEC2"
+  "stvswx %1,%y0"
+  [(set_attr "type" "vecstore")])
+
+(define_insn "altivec_stvswxl"
+  [(parallel
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
+     (unspec [(const_int 0)] UNSPEC_STVSWXL)])]
+  "TARGET_ALTIVEC2"
+  "stvswxl %1,%y0"
+  [(set_attr "type" "vecstore")])
+
 (define_expand "vec_unpacks_float_hi_v8hi"
  [(set (match_operand:V4SF 0 "register_operand" "")
         (unspec:V4SF [(match_operand:V8HI 1 "register_operand" "")]
diff -rNu gcc-4.9.2/gcc/config/rs6000/e500mc64.md test/gcc-4.9.2/gcc/config/rs6000/e500mc64.md
--- gcc-4.9.2/gcc/config/rs6000/e500mc64.md	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/e500mc64.md	2018-04-02 14:15:35.000000000 +0800
@@ -189,3 +189,5 @@
   (and (eq_attr "type" "ddiv")
        (eq_attr "cpu" "ppce500mc64"))
   "e500mc64_decode,e500mc64_issue+e500mc64_fpu,e500mc64_fpu*34")
+
+(define_bypass 15 "e500mc64_store" "e500mc64_load" "rs6000_bypass_load_on_store_collision_p")
diff -rNu gcc-4.9.2/gcc/config/rs6000/e500mc.h test/gcc-4.9.2/gcc/config/rs6000/e500mc.h
--- gcc-4.9.2/gcc/config/rs6000/e500mc.h	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/e500mc.h	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,367 @@
+/* Core target definitions for GNU compiler
+   for IBM RS/6000 PowerPC targeted to embedded ELF systems.
+   Copyright (C) 1995, 1996, 2000, 2003, 2004, 2007 Free Software Foundation, Inc.
+   Contributed by Cygnus Support.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Add -meabi to target flags.  */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT 0
+
+#ifdef RS6000_BI_ARCH
+#define DEFAULT_ARCH64_P (TARGET_DEFAULT & OPTION_MASK_64BIT)
+#define RS6000BI_ARCH_P 1
+#endif
+
+#ifdef IN_LIBGCC2
+#undef TARGET_64BIT
+#ifdef __powerpc64__
+#define TARGET_64BIT 1
+#else
+#define TARGET_64BIT 0
+#endif
+#endif
+
+
+
+
+#undef	ASM_DEFAULT_SPEC
+#undef	ASM_SPEC
+#undef	LINK_OS_LINUX_SPEC
+
+#ifndef	RS6000_BI_ARCH
+#define	ASM_DEFAULT_SPEC "-mppc%{m64:64}"
+#define	ASM_SPEC	 "%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)"
+#define	LINK_OS_LINUX_SPEC "%{!m64:%(link_os_linux_spec32)}%{m64:%(link_os_linux_spec64)}"
+#else
+#if DEFAULT_ARCH64_P
+#define	ASM_DEFAULT_SPEC "-mppc%{!m32:64}"
+#define	ASM_SPEC	 "%{m32:%(asm_spec32)}%{!m32:%(asm_spec64)} %(asm_spec_common)"
+#define	LINK_OS_LINUX_SPEC "%{m32:%(link_os_linux_spec32)}%{!m32:%(link_os_linux_spec64)}"
+#else
+#define	ASM_DEFAULT_SPEC "-mppc%{m64:64}"
+#define	ASM_SPEC	 "%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)"
+#define	LINK_OS_LINUX_SPEC "%{!m64:%(link_os_linux_spec32)}%{m64:%(link_os_linux_spec64)}"
+#endif
+#endif
+
+#define ASM_SPEC32 "-a32 %{n} %{T} %{Ym,*} %{Yd,*} \
+%{mrelocatable} %{mrelocatable-lib} %{fpic:-K PIC} %{fPIC:-K PIC} \
+%{memb} %{!memb: %{msdata: -memb} %{msdata=eabi: -memb}} \
+%{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: \
+    %{mcall-freebsd: -mbig} \
+    %{mcall-i960-old: -mlittle} \
+    %{mcall-linux: -mbig} \
+    %{mcall-gnu: -mbig} \
+    %{mcall-netbsd: -mbig} \
+}}}}"
+
+#define ASM_SPEC64 "-a64"
+
+#define ASM_SPEC_COMMON "%(asm_cpu) \
+%{,assembler|,assembler-with-cpp: %{mregnames} %{mno-regnames}} \
+%{v:-V} %{Qy:} %{!Qn:-Qy} %{Wa,*:%*} \
+%{mlittle} %{mlittle-endian} %{mbig} %{mbig-endian}"
+
+#undef	SUBSUBTARGET_EXTRA_SPECS
+#define SUBSUBTARGET_EXTRA_SPECS \
+  { "asm_spec_common",		ASM_SPEC_COMMON },			\
+  { "asm_spec32",		ASM_SPEC32 },				\
+  { "asm_spec64",		ASM_SPEC64 },				\
+  { "link_os_linux_spec32",	LINK_OS_LINUX_SPEC32 },			\
+  { "link_os_linux_spec64",	LINK_OS_LINUX_SPEC64 },                 \
+  { "startfile_aeabi",          STARTFILE_AEABI_SPEC },                 \
+  { "lib_aeabi",                LIB_AEABI_SPEC },                       \
+  { "endfile_aeabi",            ENDFILE_AEABI_SPEC },
+
+#define STARTFILE_AEABI_SPEC ""
+#define LIB_AEABI_SPEC ""
+#define ENDFILE_AEABI_SPEC ""
+
+/* This is the case of e5500 and e6500 targets */
+#undef STARTFILE_AEABI_SPEC
+#undef LIB_AEABI_SPEC
+#undef ENDFILE_AEABI_SPEC
+#define STARTFILE_AEABI_SPEC "%{m32:-m elf32ppc} %{m64:-m elf64ppc} %{!m32:%{!m64:-m elf32ppc}} ecrti.o%s crtaeabi0.o%s crtbegin.o%s"
+#define LIB_AEABI_SPEC "--start-group -laeabi -lc --end-group"
+#define ENDFILE_AEABI_SPEC "crtend.o%s crtaeabi9.o%s ecrtn.o%s"
+
+#undef	MULTILIB_DEFAULTS
+#if DEFAULT_ARCH64_P
+#define MULTILIB_DEFAULTS { "m64" }
+#else
+#define MULTILIB_DEFAULTS { "m32" }
+#endif
+
+#define POWERPC_LINUX
+
+/* PowerPC64 Linux word-aligns FP doubles when -malign-power is given.  */
+#undef  ADJUST_FIELD_ALIGN
+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \
+  ((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)	\
+   ? 128								\
+   : (TARGET_64BIT							\
+      && TARGET_ALIGN_NATURAL == 0					\
+      && TYPE_MODE (strip_array_types (TREE_TYPE (FIELD))) == DFmode)	\
+   ? MIN ((COMPUTED), 32)						\
+   : (COMPUTED))
+
+/* PowerPC64 Linux increases natural record alignment to doubleword if
+   the first field is an FP double, only if in power alignment mode.  */
+#undef  ROUND_TYPE_ALIGN
+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)			\
+  ((TARGET_64BIT							\
+    && (TREE_CODE (STRUCT) == RECORD_TYPE				\
+	|| TREE_CODE (STRUCT) == UNION_TYPE				\
+	|| TREE_CODE (STRUCT) == QUAL_UNION_TYPE)			\
+    && TARGET_ALIGN_NATURAL == 0)					\
+   ? rs6000_special_round_type_align (STRUCT, COMPUTED, SPECIFIED)	\
+   : MAX ((COMPUTED), (SPECIFIED)))
+
+/* Use the default for compiling target libs.  */
+#ifdef IN_TARGET_LIBS
+#undef TARGET_ALIGN_NATURAL
+#define TARGET_ALIGN_NATURAL 1
+#endif
+
+/* Indicate that jump tables go in the text section.  */
+#undef  JUMP_TABLES_IN_TEXT_SECTION
+#define JUMP_TABLES_IN_TEXT_SECTION TARGET_64BIT
+
+/* The linux ppc64 ABI isn't explicit on whether aggregates smaller
+   than a doubleword should be padded upward or downward.  You could
+   reasonably assume that they follow the normal rules for structure
+   layout treating the parameter area as any other block of memory,
+   then map the reg param area to registers.  i.e. pad upward.
+   Setting both of the following defines results in this behavior.
+   Setting just the first one will result in aggregates that fit in a
+   doubleword being padded downward, and others being padded upward.
+   Not a bad idea as this results in struct { int x; } being passed
+   the same way as an int.  */
+#define AGGREGATE_PADDING_FIXED TARGET_64BIT
+#define AGGREGATES_PAD_UPWARD_ALWAYS 0
+
+/* Specify padding for the last element of a block move between
+   registers and memory.  FIRST is nonzero if this is the only
+   element.  */
+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \
+  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))
+
+#undef  TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()			\
+  do							\
+    {							\
+      if (TARGET_64BIT)					\
+	{						\
+	  builtin_define ("__PPC__");			\
+	  builtin_define ("__PPC64__");			\
+	  builtin_define ("__powerpc__");		\
+	  builtin_define ("__powerpc64__");		\
+	  builtin_assert ("cpu=powerpc64");		\
+	  builtin_assert ("machine=powerpc64");		\
+	}						\
+      else						\
+	{						\
+	  builtin_define_std ("PPC");			\
+	  builtin_define ("__embedded__");		\
+	  builtin_assert ("system=embedded");		\
+	  builtin_assert ("cpu=powerpc");		\
+	  builtin_assert ("machine=powerpc");		\
+	  TARGET_OS_SYSV_CPP_BUILTINS ();		\
+	}						\
+    }							\
+  while (0)
+
+#ifdef RS6000BI_ARCH_P
+#undef	LINK_OS_DEFAULT_SPEC
+#define LINK_OS_DEFAULT_SPEC "%(link_os_linux)"
+#endif
+
+#define LINK_OS_LINUX_SPEC32 "-m elf32ppclinux"
+#define LINK_OS_LINUX_SPEC64 "-m elf64ppc"
+
+/* Must be at least as big as our pointer type.  */
+#undef	SIZE_TYPE
+#define	SIZE_TYPE (TARGET_64BIT ? "long unsigned int" : "unsigned int")
+
+#undef	PTRDIFF_TYPE
+#define	PTRDIFF_TYPE (TARGET_64BIT ? "long int" : "int")
+
+#undef	WCHAR_TYPE
+#define	WCHAR_TYPE (TARGET_64BIT ? "int" : "long int")
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 32
+
+#ifdef __powerpc64__
+/* _init and _fini functions are built from bits spread across many
+   object files, each potentially with a different TOC pointer.  For
+   that reason, place a nop after the call so that the linker can
+   restore the TOC pointer if a TOC adjusting call stub is needed.  */
+#if DOT_SYMBOLS
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+  asm (SECTION_OP "\n"					\
+"	bl ." #FUNC "\n"				\
+"	nop\n"						\
+"	.previous");
+#else
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+  asm (SECTION_OP "\n"					\
+"	bl " #FUNC "\n"					\
+"	nop\n"						\
+"	.previous");
+#endif
+#endif
+
+/* FP save and restore routines.  */
+#undef  SAVE_FP_PREFIX
+#define SAVE_FP_PREFIX (TARGET_64BIT ? "._savef" : "_savefpr_")
+#undef  SAVE_FP_SUFFIX
+#define SAVE_FP_SUFFIX (TARGET_64BIT ? "" : "_l")
+#undef  RESTORE_FP_PREFIX
+#define RESTORE_FP_PREFIX (TARGET_64BIT ? "._restf" : "_restfpr_")
+#undef  RESTORE_FP_SUFFIX
+#define RESTORE_FP_SUFFIX (TARGET_64BIT ? "" : "_l")
+
+/* Dwarf2 debugging.  */
+#undef  PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+/* This is how to declare the size of a function.  */
+#undef	ASM_DECLARE_FUNCTION_SIZE
+#define	ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)			\
+  do									\
+    {									\
+      if (!flag_inhibit_size_directive)					\
+	{								\
+	  fputs ("\t.size\t", (FILE));					\
+	  if (TARGET_64BIT && DOT_SYMBOLS)				\
+	    putc ('.', (FILE));						\
+	  assemble_name ((FILE), (FNAME));				\
+	  fputs (",.-", (FILE));					\
+	  rs6000_output_function_entry (FILE, FNAME);			\
+	  putc ('\n', (FILE));						\
+	}								\
+    }									\
+  while (0)
+
+/* Return nonzero if this entry is to be written into the constant
+   pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF
+   or a CONST containing one of them.  If -mfp-in-toc (the default),
+   we also do this for floating-point constants.  We actually can only
+   do this if the FP formats of the target and host machines are the
+   same, but we can't check that since not every file that uses
+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when
+   we can write the entry into the TOC and the entry is not larger
+   than a TOC entry.  */
+
+#undef  ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)			\
+  (TARGET_TOC								\
+   && (GET_CODE (X) == SYMBOL_REF					\
+       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS	\
+	   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)		\
+       || GET_CODE (X) == LABEL_REF					\
+       || (GET_CODE (X) == CONST_INT 					\
+	   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))	\
+       || (GET_CODE (X) == CONST_DOUBLE					\
+	   && ((TARGET_64BIT						\
+		&& (TARGET_MINIMAL_TOC					\
+		    || (SCALAR_FLOAT_MODE_P (GET_MODE (X))		\
+			&& ! TARGET_NO_FP_IN_TOC)))			\
+	       || (!TARGET_64BIT					\
+		   && !TARGET_NO_FP_IN_TOC				\
+		   && !TARGET_RELOCATABLE				\
+		   && SCALAR_FLOAT_MODE_P (GET_MODE (X))		\
+		   && BITS_PER_WORD == HOST_BITS_PER_INT)))))
+
+/* Select a format to encode pointers in exception handling data.  CODE
+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is
+   true if the symbol may be affected by dynamic relocations.  */
+#undef	ASM_PREFERRED_EH_DATA_FORMAT
+#define	ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  ((TARGET_64BIT || flag_pic || TARGET_RELOCATABLE)			\
+   ? (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel		\
+      | (TARGET_64BIT ? DW_EH_PE_udata8 : DW_EH_PE_sdata4))		\
+   : DW_EH_PE_absptr)
+
+/* For backward compatibility, we must continue to use the AIX
+   structure return convention.  */
+#undef DRAFT_V4_STRUCT_RET
+#define DRAFT_V4_STRUCT_RET 0
+
+#define TARGET_ASM_FILE_END rs6000_elf_file_end
+
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
+
+/* Use --as-needed -lgcc_s for eh support.  */
+#ifdef HAVE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 1
+#endif
+
+#undef	TARGET_AIX
+#define	TARGET_AIX TARGET_64BIT
+
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC "-maix-struct-return"
+
+#undef RS6000_ABI_NAME
+#define RS6000_ABI_NAME "linux"
+
+#define INVALID_64BIT "-m%s not supported in this configuration"
+#define INVALID_32BIT INVALID_64BIT
+
+#undef SUBSUBTARGET_OVERRIDE_OPTIONS
+#define SUBSUBTARGET_OVERRIDE_OPTIONS		\
+  do						\
+    {						\
+      if (!global_options_set.x_rs6000_alignment_flags)	\
+	rs6000_alignment_flags = MASK_ALIGN_NATURAL;		\
+      if (TARGET_64BIT)					\
+	{							\
+	  if (DEFAULT_ABI != ABI_AIX)				\
+	    {							\
+	      rs6000_current_abi = ABI_AIX;			\
+	      error (INVALID_64BIT, "call");			\
+	    }							\
+	  dot_symbols = !strcmp (rs6000_abi_name, "aixdesc");	\
+	  if (rs6000_isa_flags & OPTION_MASK_RELOCATABLE)	\
+	    {							\
+	      rs6000_isa_flags &= ~OPTION_MASK_RELOCATABLE;	\
+	      error (INVALID_64BIT, "relocatable");		\
+	    }							\
+	  if (rs6000_isa_flags & OPTION_MASK_EABI)		\
+	    {							\
+	      rs6000_isa_flags &= ~OPTION_MASK_EABI;		\
+	    }							\
+	  if (TARGET_PROTOTYPE)					\
+	    {							\
+	      TARGET_PROTOTYPE = 0;				\
+	      error (INVALID_64BIT, "prototype");		\
+	    }							\
+	  if ((rs6000_isa_flags & OPTION_MASK_POWERPC64) == 0)	\
+	    {							\
+	      rs6000_isa_flags |= OPTION_MASK_POWERPC64;	\
+	      error ("-m64 requires a PowerPC64 cpu");		\
+	    }							\
+	}							\
+    }						\
+  while (0)
+/* Linux doesn't support saving and restoring 64-bit regs in a 32-bit
+   process.  */
+#define OS_MISSING_POWERPC64 !TARGET_64BIT
diff -rNu gcc-4.9.2/gcc/config/rs6000/e500mc.md test/gcc-4.9.2/gcc/config/rs6000/e500mc.md
--- gcc-4.9.2/gcc/config/rs6000/e500mc.md	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/e500mc.md	2018-04-02 14:15:35.000000000 +0800
@@ -198,3 +198,5 @@
   (and (eq_attr "type" "ddiv")
        (eq_attr "cpu" "ppce500mc"))
   "e500mc_decode,e500mc_issue+e500mc_fpu,e500mc_fpu*65")
+
+(define_bypass 15 "e500mc_store" "e500mc_load" "rs6000_bypass_load_on_store_collision_p")
diff -rNu gcc-4.9.2/gcc/config/rs6000/e5500.md test/gcc-4.9.2/gcc/config/rs6000/e5500.md
--- gcc-4.9.2/gcc/config/rs6000/e5500.md	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/e5500.md	2018-04-02 14:15:38.000000000 +0800
@@ -33,6 +33,9 @@
 ;; Non-pipelined division.
 (define_cpu_unit "e5500_cfx_div" "e5500_long")
 
+;; Mulli pipeline
+(define_cpu_unit "e5500_cfx_mulli" "e5500_long")
+
 ;; LSU.
 (define_cpu_unit "e5500_lsu" "e5500_most")
 
@@ -108,8 +111,8 @@
 (define_insn_reservation "e5500_multiply_i" 5
   (and (eq_attr "type" "imul2,imul3,imul_compare")
        (eq_attr "cpu" "ppce5500"))
-  "e5500_decode,e5500_cfx_stage0,\
-   e5500_cfx_stage0+e5500_cfx_stage1,e5500_cfx_stage1")
+  "e5500_decode,e5500_cfx_stage0+e5500_cfx_mulli,\
+   e5500_cfx_mulli*2")
 
 ;; CFX - Divide.
 (define_insn_reservation "e5500_divide" 16
@@ -174,3 +177,5 @@
   (and (eq_attr "type" "cr_logical,delayed_cr")
        (eq_attr "cpu" "ppce5500"))
   "e5500_decode,e5500_bu")
+
+(define_bypass 15 "e5500_store" "e5500_load" "rs6000_bypass_load_on_store_collision_p")
diff -rNu gcc-4.9.2/gcc/config/rs6000/e6500.md test/gcc-4.9.2/gcc/config/rs6000/e6500.md
--- gcc-4.9.2/gcc/config/rs6000/e6500.md	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/e6500.md	2018-04-02 14:15:35.000000000 +0800
@@ -211,3 +211,5 @@
   (and (eq_attr "type" "vecperm")
        (eq_attr "cpu" "ppce6500"))
   "e6500_decode,e6500_vecperm")
+
+(define_bypass 15 "e6500_store" "e6500_load" "rs6000_bypass_load_on_store_collision_p")
diff -rNu gcc-4.9.2/gcc/config/rs6000/extelim.c test/gcc-4.9.2/gcc/config/rs6000/extelim.c
--- gcc-4.9.2/gcc/config/rs6000/extelim.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/extelim.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,3509 @@
+/* Redundant extension elimination 
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   Contributed by John Russo (john.russo@freescale.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/*
+PURPOSE: Implement a method for eliminating redundant and superflous sign
+extension instructions from 64-bit PPC e5500 generated code.
+
+MOTIVATING EXAMPLE:
+The Nullstone loop_6.c kernel looks like:
+  int i;
+  int a[100];
+  
+  ref_int_p (&a[0]);
+  
+  for (i=2; i<100; i++)
+    a[i] = a[i-1] + a[i-2];
+  
+The final, generated code for the loop body is:
+
+32-bit                  64-bit
+add     r25,r11,r0	add     r5,r5,r8
+add     r26,r0,r25	addi    r4,r4,12
+stw     r25,0(r9)	add     r27,r5,r8
+add     r27,r25,r26	stw     r5,0(r9)
+stw     r26,4(r9)	extsw   r12,r27       <===
+add     r28,r26,r27	stw     r27,4(r9)
+stw     r27,8(r9)	add     r6,r5,r12
+add     r29,r27,r28	add     r28,r6,r12
+stw     r28,12(r9)	stw     r6,8(r9)
+add     r30,r28,r29	extsw   r0,r28        <===
+stw     r29,16(r9)	stw     r28,12(r9)
+add     r12,r29,r30	add     r7,r6,r0
+stw     r30,20(r9)	add     r29,r7,r0
+add     r3,r30,r12	stw     r7,16(r9)
+stw     r12,24(r9)	extsw   r3,r29        <===
+add     r4,r12,r3	stw     r29,20(r9)
+stw     r3,28(r9)	add     r10,r7,r3
+add     r5,r3,r4	add     r30,r10,r3
+stw     r4,32(r9)	stw     r10,24(r9)
+add     r6,r4,r5	extsw   r8,r30        <===
+stw     r5,36(r9)	stw     r30,28(r9)
+add     r7,r5,r6	add     r11,r10,r8
+stw     r6,40(r9)	add     r12,r11,r8
+add     r8,r6,r7	stw     r11,32(r9)
+stw     r7,44(r9)	extsw   r26,r12       <===
+add     r10,r7,r8	stw     r12,36(r9)
+stw     r8,48(r9)	add     r0,r11,r26
+add     r11,r8,r10	add     r3,r0,r26
+stw     r10,52(r9)	stw     r0,40(r9)
+add     r0,r10,r11	subfic  r26,r4,100
+stw     r11,56(r9)	stw     r3,44(r9)
+stw     r0,60(r9)	extsw   r5,r0         <===
+addi    r9,r9,64	extsw   r8,r3         <===
+bdnz+   10000640        extsw   r4,r4         <===
+                        clrldi  r26,r26,32
+                        addi    r9,r9,48
+                        bdnz+   10000890 
+
+GENERAL APPROACH:
+Consider a machine whose native register size is 64-bits
+
+0          3132         63
+|-----------||-----------|
+
+where bit 63 is the LSB and bit 0 is the MSB of a long int
+and bit 63 is the LSB and bit 32 is the MSB of an int.
+
+Sign and zero extension are inserted to RTL to preserve the
+operation's semantics when the operands used are not the 
+native register size since normally the machine only performs
+the operation using a native register size. In practice, many
+of the inserted extensions are not necessary.
+
+First, the extension may simply be redundant. That is, the 
+same operation is performed on the same operands. The redundant
+extensions can be eliminated.
+
+Secondly, if the extended portion of the register (the "upper" bits)
+are not essential to the calculations performed on the output of the
+extension, then the extension is not necessary. For example, given
+int (32-bit) inputs and outputs:
+
+c = a + b
+d = sxt(c)
+e = d + 1; 
+
+The "upper" bits of d (bit 0-31) do not affect the calculation
+of e. It doesn't matter what the "upper" bits of d are, the int result
+e is the same regardless of the sxt instruction.
+
+Thirdly, the extensions may not be necessary if the operands are
+already extended and the operation preserves the extended bits.
+
+a = mem[&b] ; sign extending load
+c = a + 1
+d = sxt(c)
+
+Here, a is generated by a sign extending load, the operation
+does nothing to invalidate the extension to c, thus the extension
+on c to d is not necessary.
+
+In each case, the redundant extension must be replaced by a copy,
+with the copy to be optimized out in later phases.
+
+The three cases described above form the general idea behind the
+algorithms implemented here to eliminate redundant and unneccessary
+extensions. 
+
+Sign extensions do not have to be preserved for overflow conditions
+since signed overflow behavior is not defined in C. For example,
+take a 16-bit variable in a 32-bit register. It is ok
+for 0x0000_7fff to overflow to 0x0000_8000 and not 0xffff_8000.
+This implies that it is not necessary to preserve the sign
+extension.
+
+Unsigned overflow extension need to be preserved because 
+unsigned overflow is modulo. For example, a 16-bit unsigned 
+overflow of 0x0000_FFFF must be 0x0000_0000 in a 32-bit register, 
+not 0x0001_0000. In order to remove the unsigned zero extension,
+we would need to range check the variable to be sure it doesn't
+overflow.  
+
+RTL ANALYSIS:
+I looked at the RTL representation after RTL generation (.expand) and
+after the first forward propagation (.fwprop1). Since RTL is not compact
+when printing out, I reduced the .fwprop1 RTL to this pseudocode:
+
+(note: sxt,zxt mean double word length, 64-bit, extension).
+
+(1)     r198 = m[r113+ #112]     ; load a[0]
+(2)     r174 = sxt(r198)
+(3)     r199 = m[r113+ #116]     ; load a[1] 
+(4)     r186 = sxt(r199)
+(5)     r181 = r113 + #120       ; load &a[2]
+(6)     r180 = 2                 ; i = 2
+(7)     L1:
+(8)     r200 = r174 + r186       ; t1 = a[i-1] + a[i-2]
+(9)     r174 = sxt(r200)
+(10)    m[r181] = r200           ; a[i] = t1
+(11)    r201 = r200 + r186       ; t2 = t1 + a[i-1]
+(12)    r186 = sxt(r201)
+(13)    m[r181+4] = r201         ; a[i+1] = t2
+(14)    r202 = r180 + 2          ; i += 2
+(14.1)  r180 = sxt(r202)     
+(15)    r203 = 100 - r202        ; used to calc loop remainder
+(16)    r185 = zxt(r203)         ; used to calc loop remainder
+(17)    r181 = r181 + 8          ; address induction var
+(18)    ccr204 = cmp(r202,#98)   ; set CC
+(19)    BNE ccr204,L1            ; branch 
+
+In the pseudo-code, you see several sign extension candidates: (2),(4),
+(9), (12), (14.1), (16).  
+
+ALGORITHM:
+To eliminate the extra sign ext you have to look at (1) the definitions
+of the source of the sign extensions and/or (2) look at the uses of the target
+of the sign extensions. In either case, if doing a global elimination
+pass, you'll need def-use chain information. 
+
+The algorithms are recursive. Using the use/def and def/use chains
+we attempt to find ultimately whether the extension is relevant
+or not. 
+
+
+Example 1.
+Extensions (2) and (4) are not put in the candidate list because
+they are combined into a load/ext pair that is ultimately generated
+as sign extending loads.
+
+Take the sign extension at (9), r174 = sxt(r200).
+Def analysis shows that r200 is defined by 2 registers, thus no
+further def analysis recursion can occur.
+Use analysis. Find all the uses of r174. There is 1 use at (8) r200 = r174 + r186. 
+The extension does not affect the add operation results. Continuing, we look at
+the uses of r200 to see if the results of operations on r200 need the sign extended bits.
+We see 2 uses of r200 at (10) and (11). (10) is a 32-bit store of r200,
+so the sign extended bits are irrelevant. (11), however, is an unknown,
+so we must look that the uses of this result, r201. A similar sequence
+occurs for r201 when it defines r186. Looking at the uses of r186 at 
+(8) and (11), we have already visited those statements so they have
+been covered already. So it appears that the sxt to r174 at (9) ultimately
+dead-ends to a store instruction that doesn't case about the sign extended
+bits. The sxt at (9) can be removed.
+
+The remaining extensions are processed similarly.
+
+PROGRAM STRUCTURE:
+
+rest_of_handle_extelim                           -- main entry point
+ find extensions                                 -- identify extension candidates
+ extension duplication                           -- insert extension at strategic points to
+                                                    enable removal of extensions at more frequently
+                                                    executed points.
+ find extensions                                 -- recreate extension candidate list
+ sort extensions                                 -- sort extension candidate list by loop depth
+ for each ext in list                            -- process each extension candidate
+  eliminate one extension
+ replace marked candidates with copy             -- optimize the extension
+
+PSEUDOCODE:
+
+Create working list of sign extensions, sxt_list
+
+For each insn, insn_sxt,  in sxt_list 
+   ext_needed = true 
+   For all insns, insn_def, that DEFINE and REACH the SOURCE_REG(insn_sxt)
+     ext_needed = analyze_def(insn_def, insn_sxt)
+     if (ext_needed)
+       break;
+   end_loop
+   if (ext_needed)
+     For all insns, insn_use, that USE and are REACHED by the DEST_REG(insn_sxt)
+       ext_needed = analyze_use(insn_use, insn_sxt)
+       if (ext_needed)
+         break;
+     end_loop
+    
+   if (!ext_needed)
+     mark_for_replace_with_copy(I)
+end_loop
+
+For each insn, insn_sxt, in sxt_list
+   if (insn_sxt is marked for replacement)
+     replace_insn_with_copy(insn_sxt)
+end_loop
+
+--------------------------
+function: analyze_def(def)
+---------------------------
+return true if extension is needed, false otherwise.
+
+destination_operand = defined operand of source 
+source_operand = source operand of def 
+
+if (have_seen_this_insn_already (def))
+ return true;
+
+set_seen_this_insn_flag (def)
+
+analysis_result = analyze_result_def (def)
+switch (analysis_result)
+ case source_operand_is_extended:
+  return false
+ case stop_recursion:
+  return true
+ case continue_recursion: 
+  break;
+
+ext_needed = true;
+
+For all insns, insn_def, that USE and REACHED by the register of destination_operand 
+ ext_needed = analyze_def(insn_def))
+ if (ext_needed)
+  break;
+end_loop
+
+return ext_needed 
+
+--------------------------
+function: analyze_use(use)
+---------------------------
+return true if extension is needed, false otherwise.
+
+destination_operand = destination operand of use
+source_operand = source operand of use
+
+if (have_seen_this_insn_already (use))
+ return false;
+
+set_seen_this_insn_flag (use)
+
+analysis_result = analyze_result_use (use)
+switch (analysis_result)
+ case low_bits_not_affected_by_use:
+  return false
+ case low_bits_affected_by_use:
+  return true
+ case look_at_uses_of_destination_operand
+  break;
+
+ext_needed = true;
+For all insns, insn_use, that USE the register of destination_operand 
+    ext_needed = analyze_use(insn_use))
+    if (ext_needed)
+     break;
+end_loop
+
+return ext_needed 
+
+REFERENCES:
+
+"Effective Sign Extension Elimination", Kawahito, Komatsu, Nakatani. 
+IBM Tokyo Researc Laboratory.
+
+"New sign/zero extension elimination pass", deVries.
+http://gcc.gnu.org/ml/gcc-patches/2010-10/msg01529.html
+*/
+
+/*
+Iteration 4: pre-ZERO_EXTEND version, duplicates sign_extend at uses
+Iteration 5: begin supporting ZERO_EXTEND, crashes on Coremark.
+Iteration 6: revert to 4, support SI:HI sign_extensions.
+Iteration 7: Add support for zero extend. This version deletes
+ "inserted" duplicate extensions when redundant and propagates
+ the copied value. This propagate fails in other_tests/test2.sh.
+ I am reverting back to replacing the "inserted" extension to a copy.
+ Copy propagation should always be able to eliminate this copy.
+ Coremark was stable, however.
+Iteration 8: Revert to change extensions to copy, regardless of whether
+ the extension was duplicated or not. 
+ Refactor setting of dest,src in analyze_ext_use, analyze_ext_def, now
+ handled with a single function.
+Iteration 9: 
+ Inserted redundant extensions at function return points.
+ Sorted the order that extensions are processed by loop depth.
+ Additional cases in upper_bits_do_not_affect_dest
+Iteration 10:
+ Fixes for test failures. A major problem was uncovered where
+ the "visited" flag was not properly cleared. This meant that
+ each time a new extension was processed, it appeared that some
+ extensions were visited already and there were not. The result
+ was false removals. This fix significantly affects the benchmark.
+ Another change was to comment out the duplicate_exts_at_uses. This
+ seemed to have little effect now that the visited flag issue is
+ fixed. 
+Iteration 11:
+ Cleanup warnings during build.
+Iteration 12:
+ QImode support started.
+Iteration 13:
+ Redesign and refactor analyze_ext_use, analyze_ext_def
+Iteration 14:
+ Continue redesign and refactor of analyze_ext_use, analyze_ext_def
+ Debugging paper_example.c
+Iteration 15:
+ cond_c fix
+Iteration 16: (not tested)
+ Refactor check_compare code 
+ Refactor action decision in PARALLEL 
+ Allow pass-thru on insns that are marked for replace copy 
+ instead of stopping recursion if we see a marked insn.
+ Examining lshiftrt.c program (signed and unsigned).
+Iteration 17: 
+ Refactor mostly complete. Passed all local testing including
+ nas and perfect. Best coremark results so far.
+Iteration 18:
+ Oops. analyze_ext_def was disabled. Enabling it improves
+ Coremark. Passed coremark, perfect.
+Iteration 19:
+ Local tests are passing. Tested with glibc.
+ Added statistics.
+ Fixed elimination from CALL output in operand_is_extended.
+  This impacted Coremark went from 6300 to 6170. But is necessary.
+ More safety for used regs in analyze_ext_def.
+ More safety for the types of extensions.
+Iteration 20:
+ Fixes for various tests.
+Iteration 21:
+ pr43017 -funroll_loops fix.
+Iteration 22:
+ Fixes for AND immediate in operand_is_extended.
+ Cosmetic cleanup.
+Iteration 23:
+ Fixes for consumer-2,spec2k,spec2k6. Handle 
+ SUBREG_PROMOTED_VAR_P flags on operands whose
+ dependent extension has been eliminated.
+Iteration 24:
+ Fixed problem in native build during bootstrapping.
+ Extelim was considering debug_insns and should have
+ ignored them. This resulted in a compare fail between
+ stage2 and stage3.
+Iteration 25:
+ - Post-release 4.6.1 development
+ - Full duplication of extensions at uses turned on.
+ - Recursion into original extension no longer kills optimization (analyze_ext_def only)
+ - Allow some duplication into the same block if it enables insn selection
+ - Allow CCmode and CCUNSmode into mode_supported_p
+Iteration 26:
+ - Solve ICEs due to null df-ref.
+Iteration 27:
+ - Fixed issue with duplication of extension at a self-assign.
+ - Some fixes for copying flags during duplication
+ - Some fixes for counting register uses.
+Iteration 28:
+ - Fixed issue with duplication of extension when use has multiple
+   reaching definitions.
+Iteration 29:
+ - Release candidate for Q42011 release iteration.
+Iteration 30:
+ - Turn off extension duplication - minimally effective
+Iteration 31:
+ - Turn on extension duplication for specific case to allow
+   'rldic' insn generation.
+Iteration 32:
+ - Fix issue with spec2k6 soplex where zero-extends duplicated
+   even if shift is already zero-extended.
+Iteration 33:
+ - Fix issue with spec2k perlbmk using '-O3 -flto -funroll-loops'
+   where the duplication of an extension was wrong because
+   the register rtx's are shared. See save_ext_use_p() for details.
+Iteration 34:
+ -  Bug Fix: Clearquest issue ENGR00239811. 
+   We end up with consecutive extensions (one inserted, one previously there) due
+   to extension insertions are return insns.
+   This is not great, but shouldn't be catastrophic as one will be transformed to a copy.
+   The order in which the extensions are processed in windows and linux is different,
+   however. The 'combine' pass fails to treat the windows/linux cases equally and 
+   misses an important extension in the windows program. Combine is complex and 
+   there's no obvious reason why it is failing, so we disallow an extension insertion
+   at the return insn if the previous insn is an extension.
+Iteration 35:
+ - Port to gcc 4.8 ( vec.h and bb_loop_depth )
+Iteration 36:
+ - We end up with consecutive extensions (one inserted, one previously there) for
+   return instructions. Updated to select active 'prev_insn'.
+*/
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "tm_p.h"
+#include "flags.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "basic-block.h"
+#include "insn-config.h"
+#include "function.h"
+#include "expr.h"
+#include "insn-attr.h"
+#include "recog.h"
+#include "toplev.h"
+#include "target.h"
+#include "timevar.h"
+#include "optabs.h"
+#include "insn-codes.h"
+#include "rtlhooks-def.h"
+#include "output.h"
+#include "params.h"
+#include "timevar.h"
+#include "tree-pass.h"
+#include "cgraph.h"
+#include "df.h"
+#include "vec.h"
+#include "cfgloop.h"
+
+/* Feature flags */
+/* Duplicate extensions at each immediate use */
+#define EXTELIM_DUPLICATE_EXTS_AT_USES 1
+/* Dump DF information also in dump */
+#define EXTELIM_DF_DUMP 0
+
+
+/* Typedefs */
+typedef unsigned int insn_flag_t;/* Insn flags type */
+typedef int extelim_uid_t;       /* UID type */
+
+typedef struct GTY (()) ext_record
+{
+  rtx ext;                      /* The extension insn */
+  vec<rtx, va_gc> *ext_uses;
+                                /* List of use records for this extension. For some
+                                   some extensions, we will duplicate the extension
+                                   at these use points. */
+  vec<rtx, va_gc> *ext_updates; 
+                               /* List of rtx that need to be updated if the extension
+                                   is to be eliminated. For example, SUBREG_PROMOTED flags
+                                   on SUBREG uses defined by this extension should
+                                   be reset since the extension is eliminated. The PROMOTED
+                                   flag is no longer valid. */
+} *ext_record_t;
+
+typedef struct regspec_cb_data
+{
+  unsigned int regno;
+  rtx exp;
+} regspec_cb_data_t;
+
+/* Static variables */
+vec<insn_flag_t, va_gc>  *insn_flags; 
+vec<ext_record_t, va_gc> *extensions;
+vec<rtx, va_gc> *returns;
+
+     static extelim_uid_t max_uid;      /* Max UID insn value for insn_flags allocation */
+     static ext_record_t current_ext_record; /* Current extension record being processed */
+
+/* Statistics */
+     static int num_cand;               /* Number of extensions detected */
+     static int num_cand_ignored;       /* Number of extensions ignored */
+     static int num_cand_transformed;   /* Number of extensions transformed to copy */
+
+/* Basic information about the extension being processed */
+     enum machine_mode ext_to_mode;     /* Mode extended to */
+     enum machine_mode ext_from_mode;   /* Mode extended from */
+     enum rtx_code ext_code;            /* Sign or zero extend */
+
+/* Insn use analysis possible results */
+     enum insn_use_results
+     {
+       EXTELIM_ANALYSIS_RESULT_LOWBITS_NOT_AFFECTED,
+       EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED,
+       EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION
+     };
+
+/* Insn def analysis possible results */
+     enum insn_def_results
+     {
+       EXTELIM_ANALYSIS_RESULT_DEF_EXTENDED,
+       EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION,
+       EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION
+     };
+
+/* Insn flags for this pass */
+#define       EXTELIM_NONE           0
+#define       EXTELIM_SEEN           (1<<0)     /* Mark insn as visited during DF traversal */
+#define       EXTELIM_REPLACE_COPY   (1<<1)     /* Mark ext insn as replace with copy */
+#define       EXTELIM_INSERTED       (1<<2)     /* Mark ext insn as algorithmically inserted */
+#define       EXTELIM_INSERTED_FOR   (1<<3)     /* Mark use insn for which ext has been inserted */
+
+
+/* Query the insn flag */
+
+static bool insn_flag_p (insn_flag_t set_p, extelim_uid_t uid)
+{
+  insn_flag_t * flags;
+  
+  if (vec_safe_iterate (insn_flags, uid, &flags))
+    {
+      if ((*flags & set_p) == set_p)
+        return true;
+    }
+
+  return false;
+}
+
+/* Set the insn flags */
+
+static void
+insn_flag_set (insn_flag_t flags, extelim_uid_t uid)
+{
+  insn_flag_t *set;
+  gcc_assert (vec_safe_iterate (insn_flags, uid, &set));
+  *set |= flags;
+}
+
+/* Clear insn flags */
+
+static void
+insn_flag_clear (insn_flag_t flags, extelim_uid_t uid)
+{
+  insn_flag_t * clear;
+  gcc_assert (vec_safe_iterate (insn_flags, uid, &clear));
+  *clear &= ~flags;
+}
+
+/* Set static variable max_uid to the largest
+   insn uid found in the module plus 1. This will be the
+   size of the vector for insn flags. */
+
+static void
+set_max_uid (void)
+{
+  basic_block bb;
+  rtx insn;
+  extelim_uid_t lmax_uid = 0;
+
+  FOR_EACH_BB_FN (bb, cfun) FOR_BB_INSNS (bb, insn)
+  {
+    if (INSN_P (insn))
+      {
+        if (INSN_UID (insn) > lmax_uid)
+          lmax_uid = INSN_UID (insn);
+      }
+  }
+  max_uid = lmax_uid + 1;
+}
+
+/* Re-initializes the requested insn flags to their reset state */
+
+static void
+reinit_insn_flags (insn_flag_t flags_to_be_reset)
+{
+  extelim_uid_t i;
+
+  /* Account for new insns */
+  set_max_uid ();
+
+  for (i = 0; i < max_uid; i++)
+    {
+      insn_flag_clear (flags_to_be_reset, i);
+    }
+}
+
+/* Init the vector for insn flags. One
+   vector element per insn is created.
+   The flags are init'd to EXTELIM_NONE. */
+
+static void
+init_flags_vector (void)
+{
+  /* Get the maximum uid value. We'll use this
+     information to set up a vector of max_uid
+     length. Each element of the vector will hold
+     the pass-specific flags for each insn. */
+  max_uid = 0;
+  set_max_uid ();
+
+  /* Allocate and populate vector of insn flags */
+  /* Vector is init'd to 0 (EXTELIM_NONE) */
+  vec_safe_grow_cleared (insn_flags, max_uid);
+}
+
+/* Initialize this pass */
+
+static void
+init_pass (void)
+{
+  /* Init insn flags vector */
+  init_flags_vector ();
+
+  /* Init statics */
+  vec_alloc(extensions, 0);
+  vec_alloc(returns, 0);
+
+  /* This pass requires def-use chain information */
+  df_chain_add_problem (DF_DU_CHAIN + DF_UD_CHAIN);
+  df_analyze ();
+}
+
+static void
+free_extensions (void)
+{
+  ext_record_t ext_record;
+  unsigned i;
+
+  FOR_EACH_VEC_SAFE_ELT (extensions, i, ext_record)
+    {
+      if (!vec_safe_is_empty(ext_record->ext_uses))
+        vec_free(ext_record->ext_uses);
+      if (!vec_safe_is_empty(ext_record->ext_updates))
+        vec_free(ext_record->ext_updates);
+    }
+      
+  if (!vec_safe_is_empty(extensions))
+    vec_free(extensions);
+}
+
+/* Clean up this pass */
+
+static void
+finish_pass (void)
+{
+  free_extensions ();
+  if (!vec_safe_is_empty(insn_flags))
+    vec_free(insn_flags);
+  if (!vec_safe_is_empty(returns))
+    vec_free(returns);
+}
+
+static void
+update_uid_vectors (extelim_uid_t uid)
+{
+  vec_safe_grow_cleared(insn_flags, uid + 1);
+}
+
+/* Emit a insn before a given insn, update vector lengths
+   of those vectors that are indexed by uid. Return uid
+   of the inserted insn. */
+
+static extelim_uid_t
+extelim_emit_before (rtx new_insn, rtx before_insn)
+{
+  rtx seq;
+  extelim_uid_t new_uid;
+
+  start_sequence ();
+  emit_insn (new_insn);
+  seq = get_insns ();
+  end_sequence ();
+  new_insn = emit_insn_before (seq, before_insn);
+
+  /* Expand the flags vector to hold the new insn and set the
+     inserted flag on the insn. */
+  new_uid = INSN_UID (new_insn);
+  update_uid_vectors (new_uid);
+  return new_uid;
+}
+
+/* Utility function to find the REG exp 
+   given an rtx */
+
+static rtx
+register_exp (rtx exp)
+{
+  if (REG_P (exp))
+    {
+      return exp;
+    }
+  else if (GET_CODE (exp) == SUBREG)
+    {
+      return SUBREG_REG (exp);
+    }
+  else
+    return NULL;
+}
+
+/* Check whether this is a sign extension.  */
+
+static bool
+extension_p (rtx insn, rtx * dest, rtx * inner, int *preserved_size)
+{
+  rtx src, op0;
+
+  /* Detect set of reg.  */
+  if (GET_CODE (PATTERN (insn)) != SET)
+    return false;
+
+  src = SET_SRC (PATTERN (insn));
+  *dest = SET_DEST (PATTERN (insn));
+
+  if (!REG_P (*dest))
+    return false;
+
+  if (GET_CODE (src) == SIGN_EXTEND || GET_CODE (src) == ZERO_EXTEND)
+    {
+      op0 = XEXP (src, 0);
+
+      /* Determine amount of least significant bits preserved by operation.  */
+      if (GET_CODE (src) == AND)
+        *preserved_size = ctz_hwi (~UINTVAL (XEXP (src, 1)));
+      else
+        *preserved_size = GET_MODE_BITSIZE (GET_MODE (op0));
+
+      if (GET_CODE (op0) == SUBREG)
+        {
+          if (subreg_lsb (op0) != 0)
+            return false;
+
+          *inner = SUBREG_REG (op0);
+          return true;
+        }
+      else if (REG_P (op0))
+        {
+          *inner = op0;
+          return true;
+        }
+    }
+
+  return false;
+}
+
+/* Return true if this is the last use of a
+   register, false otherwise.  */
+
+static bool
+reg_is_dead_p (rtx insn, rtx reg_expr)
+{
+  rtx link;
+  gcc_assert (REG_P (reg_expr));
+
+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+    {
+      if (REG_NOTE_KIND (link) == REG_DEAD && REG_P (XEXP (link, 0)))
+        {
+          if (REGNO (XEXP (link, 0)) == REGNO (reg_expr))
+            return true;
+        }
+    }
+  return false;
+}
+
+/* Return true if we don't want to place this
+   extension in the candidate extensions list because of the
+   previous insn. Return false otherwise. */
+
+static bool
+ignore_extension_prev_p (rtx ext_insn, rtx prev_insn)
+{
+  rtx prev_dest, prev_src, prev;
+  rtx ext_src, ext = PATTERN (ext_insn);
+
+  /* Beginning of block reached */
+  if (prev_insn == NULL_RTX)
+    return false;
+
+  prev = PATTERN (prev_insn);
+
+  if (GET_CODE (prev) != SET)
+    return false;
+
+  if (GET_CODE (ext) != SET)
+    return false;
+
+  prev_dest = SET_DEST (prev);
+  prev_src = SET_SRC (prev);
+
+  /* Source register of sign extension */
+  ext_src = XEXP (SET_SRC (ext), 0);
+
+  /* Check previous insns */
+
+  /* Previous insn is a load whose dest is the
+     extension's source  and the dest reg is
+     dead */
+  if (MEM_P (prev_src) && (prev_dest = register_exp (prev_dest)))
+    {
+      if ((ext_src = register_exp (ext_src)))
+        {
+          if ((REGNO (prev_dest) == REGNO (ext_src))
+              && reg_is_dead_p (ext_insn, ext_src))
+            return true;
+        }
+    }
+  return false;
+}
+
+/* Return true if we don't want to place this
+   extension in the candidate extensions list because of the
+   next insn. Return false otherwise. */
+
+static bool
+ignore_extension_next_p (rtx ext_insn, rtx next_insn)
+{
+  rtx next = PATTERN (next_insn);
+  rtx ext = PATTERN (ext_insn);
+
+  if (GET_CODE (ext) != SET)
+    return false;
+
+  /* Check next insns */
+  if (!NONDEBUG_INSN_P (next_insn) || NOTE_P (next_insn))
+    return false;
+
+  if (GET_CODE (next) != SET)
+    return false;
+
+  /* zero-extend followed by left shift by 1 -- this sequence will be
+     detected by the insn selection. */
+  if (GET_CODE (SET_SRC (ext)) == ZERO_EXTEND)
+    {
+      if (GET_CODE (SET_SRC (next)) == ASHIFT
+          && CONST_INT_P (XEXP (SET_SRC (next), 1))
+          && UINTVAL (XEXP (SET_SRC (next), 1)) == 0x1)
+        return true;
+    }
+
+  return false;
+}
+
+/* Find extensions and store them in the extensions vector.  */
+
+static bool
+find_extensions (void)
+{
+  basic_block bb;
+  rtx insn, dest, inner, real_insn;
+  int preserved_size;
+  ext_record_t extrec;
+  bool has_extensions;
+
+  /* For all insns, call note_use for each use in insn.  */
+  FOR_EACH_BB_FN (bb, cfun)
+  {
+    FOR_BB_INSNS (bb, insn)
+    {
+      if (!NONDEBUG_INSN_P (insn))
+        continue;
+
+      if (!extension_p (insn, &dest, &inner, &preserved_size))
+        {
+          continue;
+        }
+
+      /* We do not consider extensions that follow a load for
+         this target, as the code selector optimizes the sequence
+         to a load with sign extend or load with zero extend. */
+      real_insn = prev_active_insn (insn);
+      if (real_insn && ignore_extension_prev_p (insn, real_insn))
+        {
+          if (dump_file)
+            fprintf (dump_file, "extension at uid=%d ignored\n",
+                     INSN_UID (insn));
+          num_cand_ignored++;
+          continue;
+        }
+      /* We don't consider certain sequences that are picked up by
+         insn selection. */
+      real_insn = next_active_insn (insn);
+      if (real_insn && ignore_extension_next_p (insn, real_insn))
+        {
+          if (dump_file)
+            fprintf (dump_file, "extension at uid=%d ignored\n",
+                     INSN_UID (insn));
+          num_cand_ignored++;
+          continue;
+        }
+
+      /* Only looking at sign extensions to DImode, SImode, or HImode  */
+      if (GET_MODE_BITSIZE (SImode) != preserved_size
+          && GET_MODE_BITSIZE (HImode) != preserved_size
+          && GET_MODE_BITSIZE (QImode) != preserved_size)
+        continue;
+
+      extrec = (ext_record_t) xmalloc (sizeof (struct ext_record));
+      extrec->ext = insn;
+      vec_alloc(extrec->ext_uses, 0);
+      vec_alloc(extrec->ext_updates, 0);
+      vec_safe_push(extensions, extrec);
+      num_cand++;
+    }
+  }
+
+  if (dump_file)
+    {
+      if (! vec_safe_is_empty(extensions)) 
+        fprintf (dump_file, "\n");
+      else
+        fprintf (dump_file, "no extensions found.\n");
+    }
+
+  has_extensions = !vec_safe_is_empty(extensions);
+  return (has_extensions);
+}
+
+/* Return true if the rtx mode is a supported mode for
+   this optimization, false otherwise. */
+
+static bool
+mode_supported_p (rtx exp)
+{
+  if (GET_MODE (exp) != QImode
+      && GET_MODE (exp) != HImode
+      && GET_MODE (exp) != SImode 
+      && GET_MODE (exp) != DImode
+      && GET_MODE (exp) != CCmode
+      && GET_MODE (exp) != CCUNSmode)
+    return false;
+
+  return true;
+}
+
+/* Return true if the rtx is a function return expr, false otherwise */
+
+static bool
+return_val_p (rtx dest)
+{
+  if ((REG_P (dest) || GET_CODE (dest) == PARALLEL) &&
+      REG_FUNCTION_VALUE_P (dest))
+    {
+      return true;
+    }
+  return false;
+}
+
+
+/* A 'for_each_rtx' callback returning 1 if the rtx is a
+   REG or SUBREG rtx. The first matching rtx found stops the 
+   rtx traversal. */
+
+static int
+reg_or_subreg_rtx (rtx * x, void *data)
+{
+  regspec_cb_data_t *ldata = (regspec_cb_data_t *) data;
+
+  if (REG_P (*x))
+    {
+      ldata->exp = *x;
+      return 1;
+    }
+
+  if (GET_CODE (*x) == SUBREG)
+    {
+      ldata->exp = SUBREG_REG (*x);
+      return 1;
+    }
+
+  return 0;
+}
+
+/* A 'for_each_rtx' callback returning 1 if the rtx is a
+   REG or SUBREG rtx whose register number is that passed
+   in the data parameter. Data parameter's rtx value is
+   set to the matching rtx if found. */
+
+static int
+reg_or_subreg_rtx_regno (rtx * x, void *data)
+{
+  regspec_cb_data_t *ldata = (regspec_cb_data_t *) data;
+
+  if (REG_P (*x) && (REGNO (*x) == ldata->regno))
+    {
+      ldata->exp = *x;
+      return 1;
+    }
+  if (GET_CODE (*x) == SUBREG && (REGNO (SUBREG_REG (*x)) == ldata->regno))
+    {
+      ldata->exp = SUBREG_REG (*x);
+      return 1;
+    }
+  return 0;
+}
+
+/* Callback that counts the number of register operands
+   in an expression. Return 0 to allow all rtxs to be
+   traversed. */
+
+static int
+count_reg_operands (rtx * x, void *data)
+{
+  regspec_cb_data_t *ldata = (regspec_cb_data_t *) data;
+
+  if (register_exp (*x) != NULL)
+    {
+      ldata->regno++;
+    }
+  return 0;
+}
+
+/* Count the number of register operands in an expression.
+   We use the regspec_cb_data_t regno field as the number
+   of register operands we found in an expression. */
+
+static int
+num_reg_operands (rtx x)
+{
+  int rv;
+  regspec_cb_data_t data;
+  data.regno = 0;
+  data.exp = NULL_RTX;
+
+  if ((rv = for_each_rtx (&x, count_reg_operands, (void *) &data)) == 0)
+    return (data.regno);        /* contains the count */
+  else
+    return 0;
+}
+
+/* Find the SUBREG or REG rtx corresponding to regno in the given rtx.
+   Return NULL_RTX if the regno rtx is not found. */
+
+static rtx
+find_regspec_regno (unsigned int regno, rtx x)
+{
+  int rv;
+  regspec_cb_data_t data;
+  data.regno = regno;
+  data.exp = NULL_RTX;
+
+  if ((rv = for_each_rtx (&x, reg_or_subreg_rtx_regno, (void *) &data)) != 0)
+    return (data.exp);
+  else
+    return NULL_RTX;
+}
+
+/* Find a REG or SUBREG rtx, starting at expr x.
+   Return NULL_RTX if no REG or SUBREG rtx is found.
+   If found, the rtx returned is a REG (not SUBREG) */
+
+static rtx
+find_regspec (rtx x)
+{
+  int rv;
+  regspec_cb_data_t data;
+  data.regno = -1;              /* not used */
+  data.exp = NULL_RTX;
+
+  if ((rv = for_each_rtx (&x, reg_or_subreg_rtx, (void *) &data)) != 0)
+    return (data.exp);
+  else
+    return NULL_RTX;
+}
+
+/* Return true if the expression defines single register, regno. */
+
+static bool
+expr_defines_regno_p (rtx insn, unsigned int regno)
+{
+  rtx reg;
+  if (GET_CODE (insn) == SET)
+    {
+      reg = SET_DEST (insn);
+      if (find_regspec_regno (regno, reg) != NULL_RTX)
+        return true;
+    }
+  return false;
+}
+
+/* Return true if the insn defines a single register, regno.
+   Return false otherwise */
+
+static bool
+defines_regno_p (rtx insn_insn, unsigned int regno, int indent)
+{
+  extelim_uid_t uid = INSN_UID (insn_insn);
+  df_ref *p_def;
+
+  /* Get the operands defined */
+  p_def = DF_INSN_UID_DEFS (uid);
+
+  if (!p_def)
+    return false;
+
+  if (*(p_def + 1) != NULL)
+    {
+      if (dump_file)
+        fprintf (dump_file, "%*suid=%d defines multiple registers\n",
+                 indent, " ", uid);
+      return false;
+    }
+
+  if (DF_REF_REGNO (*p_def) != regno)
+    {
+      if (dump_file)
+        fprintf (dump_file, "%*suid=%d defines does not define %d\n",
+                 indent, " ", uid, regno);
+      return false;
+    }
+
+  return true;
+}
+
+/* The operand is already extended and the extension is compatible with
+   the originating extension with respect to type and size.
+   E.g. zero_extend:HI meets and AND r,#0xffff. Another example
+   is LSHIFT:SI left or right and zero_extend:SI, because the 
+   instruction selected is rlwinm and clears the upper 32 bits.
+   Other examples in the code. Return true if a compatible extension
+   is found, false otherwise. */
+
+static bool
+operand_is_extended (rtx dest, rtx srcexp, int indent)
+{
+  /* Output of a CALL is already extended. 
+     To ensure that the return value is not modified by the extend,
+     the extend from mode size must be at least the size of the CALL output. 
+     Example - this is redundant since output of CALL is extended.
+     X:SI = CALL ...
+     Y:DI = sign_extend:DI (X:SI) */
+  if (GET_CODE (srcexp) == CALL
+      && (GET_MODE_BITSIZE (ext_from_mode)) >=
+      GET_MODE_BITSIZE (GET_MODE (dest)))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...is extended already (CALL insn output)\n", indent,
+                 " ");
+      return true;
+    }
+
+  /* Output is load immediate or load constant */
+  if (CONST_INT_P (srcexp))
+    {
+      bool is_extended;
+      if (ext_from_mode == QImode && (UINTVAL (srcexp) <= 0xff))
+        is_extended = true;
+      else if (ext_from_mode == HImode && (UINTVAL (srcexp) <= 0xffff))
+        is_extended = true;
+      else if (ext_from_mode == SImode && (UINTVAL (srcexp) <= 0xffffffff))
+        is_extended = true;
+      else
+        is_extended = false;
+
+      if (is_extended)
+        {
+          if (dump_file)
+            fprintf (dump_file,
+                     "%*s... is extended already (CONST_INT load)\n", indent,
+                     " ");
+          return true;
+        }
+    }
+
+  /* Sign extension of the same type as the originating extension.
+     Here the candidate defines the register used in the originating extension.
+     The originating extension will be replaced by a copy if it is found to be
+     redundant with respect to the candidate extension. 
+     The candidate (this extension dest,src) must write the at least the same bits as the 
+     originating extension in order to be redundant. So, we follow these rules:
+
+     cand_to_mode == machine mode of the destination for this candidate extension
+     cand_from_mode == machine mode of the source for this candidate extension
+     ext_to_mode == machine mode of the originating extension output
+     ext_from_mode == machine mode of the originating extension input
+
+     SIZE(cand_to_mode) >= SIZE(extend_to_mode) && SIZE(cand_from_mode) <= SIZE(extend_from_mode)
+
+     Example 1:
+     Candidate (HI->SI extension)
+     DI       SI   HI QI 0
+     |        |<---|  |  |
+
+     Originating (SI->DI)
+     DI       SI   HI QI 0
+     |<-------|    |  |  |
+
+     Not redundant, candidate does not cover the original bits:
+     SIZE(cand_to_mode)[SI] !>= SIZE(extend_to_mode)[DI]
+
+     Example 2:
+     Candidate (QI->DI extension)
+     DI       SI   HI QI 0
+     |<-------|----|--|  |
+
+     Originating (HI->SI)
+     DI       SI   HI QI 0
+     |        |<---|  |  |
+
+     Redundant, candidate covers the original bits:
+     SIZE(cand_to_mode) [DI] >= SIZE(extend_to_mode) [SI]
+     AND
+     SIZE(cand_from_mode) [QI] <= SIZE(extend_from_mode) [HI]
+   */
+  if (GET_CODE (srcexp) == ext_code)
+    {
+      enum machine_mode cand_from_mode = GET_MODE (XEXP (srcexp, 0));
+      enum machine_mode cand_to_mode = GET_MODE (dest);
+      if ((GET_MODE_BITSIZE (cand_to_mode) >= GET_MODE_BITSIZE (ext_to_mode))
+          && (GET_MODE_BITSIZE (cand_from_mode) <=
+              GET_MODE_BITSIZE (ext_from_mode)))
+        {
+          if (dump_file)
+            fprintf (dump_file,
+                     "%*s...is already extended (redundant extension)\n",
+                     indent, " ");
+          return true;
+        }
+    }
+
+  /* Encountered an insn with the same effect as extension, e.g.
+     AND (regspec) (const_int). E.g. AND (reg:SI) (0x7fff) is equivalent
+     to ZERO_EXTEND:DI (reg:HI) or SIGN_EXTEND:DI (reg:HI). The code selection
+     for AND zero extends the entire register, so we don't have to
+     check that srcexp extends to at least ext_to_mode size. */
+  if ((GET_CODE (srcexp) == AND) && CONST_INT_P (XEXP (srcexp, 1)))
+    {
+      if (ext_from_mode == QImode && (UINTVAL (XEXP (srcexp, 1)) <= 0x7f))
+        return true;
+      else if (ext_from_mode == HImode
+               && (UINTVAL (XEXP (srcexp, 1)) <= 0x7fff))
+        return true;
+      else if (ext_from_mode == SImode
+               && (UINTVAL (XEXP (srcexp, 1)) <= 0x7fffffff))
+        return true;
+    }
+
+  return false;
+}
+
+/* Determine if the operation allows us to continue the propagation. 
+   We kill the propagation for all operations except copy. This
+   ensures that the extended operand that we may find eventually
+   is not modified by insns in the def-use chain. It's harsh,
+   but it's safest eliminate all but the most benign (copy) operations
+   in the propagation chain. */
+
+static bool
+continue_def_propagation (rtx srcexp)
+{
+  /* Only continue if its a copy -- that is, the srcexp is a register expression */
+  if ( register_exp (srcexp) )
+    return true;
+
+  return false;
+}
+
+/* Helper for insn_def_analysis_result.
+   The register operand, src is set here. Recall we
+   can only handle one register operand in the src expression.
+   We one of 3 states:
+   1) Determine the operand is extended, ...DEF_EXTENDED returned.
+   2) Determine the propagation can continue, ...DEF_CONTINUE_RECURSION returned. 
+   3) Otherwise, ...DEF_STOP_RECURSION is returned. */
+static enum insn_def_results
+insn_def_analysis_result_1 (rtx insn, bool treat_as_copy,
+                            unsigned int regno_def ATTRIBUTE_UNUSED,
+                            rtx * src, int indent)
+{
+  rtx dest, srcexp;
+  int num_operands;
+
+  /* Insn has to be an expression we can analyze */
+  if (GET_CODE (insn) != SET)
+    {
+      if (dump_file)
+        fprintf (dump_file, "%*s...is not a SET expression\n", indent, " ");
+      return EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+    }
+  dest = SET_DEST (insn);
+  srcexp = SET_SRC (insn);
+
+  /* Dest must be a reg, not expression */
+  if (!REG_P (dest))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...dest is not a simple register\n", indent, " ");
+      return EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+    }
+
+  /* First check whether the operand is extended already. If so,
+     we can leave immediately successfully. */
+  if (operand_is_extended (dest, srcexp, indent) && !treat_as_copy)
+    return (EXTELIM_ANALYSIS_RESULT_DEF_EXTENDED);
+
+
+  /* Failing to determine that the operand is already extended, 
+     we have to validate that we have register operands to propagate. */
+  num_operands = num_reg_operands (srcexp);
+
+  /* At least one register operand required for propagation. */
+  if (num_operands == 0)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...no register operands in RHS\n", indent, " ");
+      return EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+    }
+
+  /* Only one register operand is allowed in the RHS since we can't
+     can't propagate more than one register. */
+  if (num_operands > 1)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...found multiple register operands in RHS\n", indent,
+                 " ");
+      return EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+    }
+
+  /* Find the used operand in the src expression */
+  *src = find_regspec (srcexp);
+  if (*src == NULL_RTX || !mode_supported_p (*src))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...src operand reg=%d cannot be found or is unsupported mode\n",
+                 indent, " ", regno_def);
+      return EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+    }
+
+  /* This is an extension, but it is previously marked to be transformed to a copy.
+     We just treat it as a copy even though it hasn't been transformed yet. So 
+     continue the propagation. */
+  if (treat_as_copy)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...%s is treated as a copy (marked for replace)\n",
+                 indent, " ", GET_RTX_NAME (GET_CODE (srcexp)));
+      return (EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION);
+    }
+
+  /* Validate that it's ok to continue propagation with this operand. */
+  if (continue_def_propagation (srcexp))
+    return (EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION);
+
+  /* Else we default to halting the search for a redundant extension */
+  return (EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION);
+}
+
+/* Determine if the insn extends it's destination register in
+   a manner such that the original extension is redundant. */
+
+static enum insn_def_results
+insn_def_analysis_result (rtx insn_insn, unsigned int regno_def, rtx * src,
+                          int indent)
+{
+  bool treat_as_copy = false;
+
+  /* Insn must only define one output */
+  if (!defines_regno_p (insn_insn, regno_def, indent))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...defines more than 1 output\n", indent, " ");
+      return EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+    }
+
+  /* We want to treat this extension as a copy and continue propagation.
+     Otherwise, it would be detected again as redundant. */
+  if (insn_flag_p (EXTELIM_REPLACE_COPY, INSN_UID (insn_insn)))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*suse at uid=%d is marked to transform to copy\n", indent,
+                 " ", INSN_UID (insn_insn));
+      treat_as_copy = true;
+    }
+
+  /* Do the analysis */
+  return (insn_def_analysis_result_1
+          (PATTERN (insn_insn), treat_as_copy, regno_def, src, indent));
+}
+
+/* Analyze each of the expressions in a PARALLEL expression. As each of
+   the expressions may yield a different state, select the most conservative
+   state to return. */
+
+static enum insn_def_results
+insn_def_analysis_2 (rtx insn_def, unsigned int regno_def, rtx * src,
+                     int indent)
+{
+  int i;
+  rtx insn = PATTERN (insn_def);
+  enum insn_def_results action;
+  enum insn_def_results return_action =
+    EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION;
+
+  gcc_assert (GET_CODE (insn) == PARALLEL);
+
+  for (i = XVECLEN (insn, 0) - 1; i >= 0; i--)
+    {
+      rtx body = XVECEXP (insn, 0, i);
+      /* Only act on the expressions that define regno_def */
+      if (!expr_defines_regno_p (body, regno_def))
+        continue;
+      /* Determine the next action */
+      action = insn_def_analysis_result_1 (body, false /* treat_as_copy */ ,
+                                           regno_def, src, indent);
+      /* The result of this expression stops the recursion, i.e. no
+         longer reasonable to continue looking at further recursion. */
+      if (action == EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION)
+        return action;
+      /* Only return EXTENDED if there are no other different actions
+         in the series. Otherwise, CONTINUE_RECURSION is returned. */
+      if (action == EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION)
+        return_action = action;
+      else if (return_action ==
+               EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION)
+        return_action = EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION;
+      else
+        return_action = action;
+    }
+  return (return_action);
+}
+
+/* Helper 1 for insn_def_analysis */
+
+static enum insn_def_results
+insn_def_analysis_1 (rtx insn_def, unsigned int regno_def, rtx * src,
+                     int indent)
+{
+  rtx def = PATTERN (insn_def);
+  enum insn_def_results action;
+
+  switch (GET_CODE (def))
+    {
+    case PARALLEL:
+      action = insn_def_analysis_2 (insn_def, regno_def, src, indent);
+      break;
+    default:
+      action = insn_def_analysis_result (insn_def, regno_def, src, indent);
+      break;
+    }
+  return action;
+}
+
+/* We look at the definition of a register that is either the
+   sign or zero extend source register or a definition that that
+   has been propagated to here via analyze_ext_def. The objective
+   is to determine, by looking at the operation and operands, whether
+   the register is sign/zero extended by virtue of the operation and/or
+   operands. If so, the original extension is redundant.
+   The function returns one of 3 possible states after analyzing the
+   insn:
+   1. EXTELIM_ANALYSIS_RESULT_DEF_EXTENDED - we determined that the
+   insn does indeed extend the original source extension register.
+   analyze_ext_def returns FALSE, therefore, ending the recursion
+   and propagation.
+   2. EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION - we determined that 
+   the insn does not meet the criteria to continue the recursive search.
+   Some conditions causing this may be multiple operands defining this
+   register (we only propagate on a single input operand) or the insn
+   defines more than one output or the operation does not allow
+   a previous extension to propagate, e.g. an arithmetic shift on
+   a SI value clears the upper bits using rlwinm. MUL, DIV, MOD
+   stop recursion because the result is longer than the input size,
+   thus impacting the possible previous extension.
+   3. EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION - we found an
+   operation with one register operand and the operation will not
+   affect a previous extension if one exists. ADD, SUB are examples.
+   We continue looking up the chain at the definition of the operand
+   for an extended result. 
+   If we run into a previous extension marked for replacement during
+   recursion, we treat it as a copy (CONTINUE_RECURSION since the
+   extension is preserved by the copy). */
+
+static enum insn_def_results
+insn_def_analysis (rtx insn_def, unsigned int regno_def, rtx * src,
+                   int indent)
+{
+  return (insn_def_analysis_1 (insn_def, regno_def, src, indent));
+}
+
+/* Analyze the insn defining the source of the sign extension.
+   If it can be determined that the definition is already
+   sign extended, return false. Otherwise, return true if 
+   extension is needed. */
+
+static bool
+analyze_ext_def (rtx insn_def, unsigned int regno_def, int indent)
+{
+  extelim_uid_t uid;
+  rtx def = PATTERN (insn_def);
+  rtx src;
+  df_ref df_def, *p_use;
+  bool ext_needed, indent_once;
+  struct df_link *link;
+  enum insn_def_results analysis_result;
+
+  gcc_assert (def != NULL);
+
+  uid = INSN_UID (insn_def);
+
+  /* If we seen the originating extension again, return false (ext not needed) */
+  if (current_ext_record->ext == insn_def)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*sdef at uid=%d is original extension\n", indent, " ", uid);
+      return false;
+    }
+
+  /* The recursion has to definitively end with an operand being
+     extended (and compatible with the originating extension). If
+     we see the insn again, this could return a faulty positive (false),
+     so we return true here instead of false. See pr43017 (-funroll-loops)
+     as an example. */
+  if (insn_flag_p (EXTELIM_SEEN, uid))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*sdef at uid=%d is visited already\n", indent, " ", uid);
+      return true;
+    }
+
+  /* Mark this insn as seen */
+  insn_flag_set (EXTELIM_SEEN, uid);
+
+  analysis_result = insn_def_analysis (insn_def, regno_def, &src, indent);
+  switch (analysis_result)
+    {
+      /* We know conclusively that the register defined in this expression
+         is already extended. */
+    case EXTELIM_ANALYSIS_RESULT_DEF_EXTENDED:
+      if (dump_file)
+        fprintf (dump_file, "%*sdef at uid=%d is extended\n", indent, " ",
+                 uid);
+      return false;
+      break;
+      /* We know conclusively that we cannot continue the recursion. Perhaps 
+         the expression defines multiple registers, etc. */
+    case EXTELIM_ANALYSIS_RESULT_DEF_STOP_RECURSION:
+      if (dump_file)
+        fprintf (dump_file, "%*sdef at uid=%d cannot be propagated\n", indent,
+                 " ", uid);
+      return true;
+      break;
+      /* Continue to look at the operands of this expression. They may be extended
+         already. */
+    case EXTELIM_ANALYSIS_RESULT_DEF_CONTINUE_RECURSION:
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  /* This is the operand for which we want to find definitions. There should
+     only be one operand as we have previously checked for operations with only
+     one register operand as the src previously. */
+  p_use = DF_INSN_UID_USES (uid);
+  gcc_assert (p_use != NULL);
+
+  /* Make sure that this use is the one returned in src. Otherwise we simply
+     stop the propagation. Note the DF_INSN_UID_USES works at the insn
+     level, so a PARALLEL pattern may return many uses, hence the need
+     to validate the correct use here. */
+  if ((*p_use == NULL) || (DF_REF_REGNO (*p_use) != REGNO (src)))
+    return true;
+
+  ext_needed = true;
+  indent_once = true;
+  for (link = DF_REF_CHAIN (*p_use); link; link = link->next)
+    {
+      rtx insn_def;
+      df_def = link->ref;
+      if (!df_def)
+        continue;
+      /* Link must be to a definition of the use */
+      if (!DF_REF_REG_DEF_P (df_def))
+        continue;
+      /* Ignore ARTIFICIAL defs */
+      if (DF_REF_IS_ARTIFICIAL (df_def))
+        continue;
+      insn_def = DF_REF_INSN (df_def);
+      /* Don't consider debug_insns */
+      if (!NONDEBUG_INSN_P (insn_def))
+        continue;
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*sdef of reg=%d at uid=%d\n", indent, " ",
+                 DF_REF_REGNO (df_def), INSN_UID (insn_def));
+      /* Set indent for dump formatting */
+      if (indent_once)
+        {
+          ++indent;
+          indent_once = false;
+        }
+      ext_needed = analyze_ext_def (insn_def, DF_REF_REGNO (df_def), indent);
+      if (ext_needed)
+        break;
+    }
+
+  if (dump_file)
+    fprintf (dump_file,
+             "%*sext %s needed\n", indent, " ", ext_needed ? "" : "not");
+
+  return ext_needed;
+}
+
+/* Determine whether the expression needs to be saved for this extension.
+   The expression will be updated in some way if the extension is ultimately
+   eliminated. */
+
+static bool
+exp_needs_update_p (rtx exp)
+{
+  if (GET_CODE (exp) == SUBREG
+      && (SUBREG_PROMOTED_VAR_P (exp)))
+    {
+      return true;
+    }
+  return false;
+}
+
+/* Some expressions may need to be updated if the originating extension
+   is eliminated. For example, SUBREG_PROMOTED flags on uses are no longer
+   valid if the extension is eliminated. Save the expression here. */
+
+static void
+save_ext_update (ext_record_t extrec, rtx exp)
+{
+  /* Save this expression to be updated if the extension is eliminated. */
+  vec_safe_push(extrec->ext_updates, exp);
+}
+
+/* Check a compare operation to determine whether the operands
+   of the compare use the upper bits of the extension. Return
+   true if the upper bits are not relevant in the compare, false
+   otherwise. */
+
+static bool
+check_compare (rtx dest, rtx src)
+{
+  /* Detect 
+     (set (reg:CC r0) (compare:CC (REGSPEC) (REGSPEC)))
+     or
+     (set (reg:CC r0) (compare:CC (REGSPEC) (CONST)))
+     where REGSPEC is (reg:mm r) or (subreg:mm (reg:MM r) n) 
+     CONST is a constant integer.
+     The mode size of compare ops must be less than the
+     mode of the original extension for the upper bits to
+     be irrelevant. 
+     An exception is made for mode sizes less than a word size.
+     For our targets, there is no 'cmph' insn, so we bail out 
+     if we see a comparison of sizes less than a word (SI). */
+  if (REG_P (dest)
+      && (GET_MODE (dest) == CCmode || GET_MODE (dest) == CCUNSmode)
+      && GET_CODE (src) == COMPARE
+      && (GET_MODE (src) == CCmode || GET_MODE (src) == CCUNSmode))
+    {
+      rtx compare_op0 = XEXP (src, 0);
+      rtx compare_op1 = XEXP (src, 1);
+
+      /* Check the first operand, op0, size. */
+      if ((REG_P (compare_op0) || GET_CODE (compare_op0) == SUBREG)
+          && (GET_MODE_BITSIZE (GET_MODE (compare_op0)) <=
+              GET_MODE_BITSIZE (ext_from_mode)))
+        {
+          /* Half word compares and smaller are performed as word compares, so upper bits are used. */
+          if (GET_MODE_BITSIZE (GET_MODE (compare_op0)) < SImode)
+            return false;
+
+          /* Now check the other operand, op1. */
+          if ((REG_P (compare_op1) || GET_CODE (compare_op1) == SUBREG)
+              && (GET_MODE_BITSIZE (GET_MODE (compare_op1)) <=
+                  GET_MODE_BITSIZE (ext_from_mode)))
+            return true;
+
+          /* Compare to constant, we know op0 already meets size constraints. */
+          if (CONST_INT_P (compare_op1))
+            return true;
+        }
+    }
+  return false;
+}
+
+/* Determine condition a, whether the upper bits are relevant to the operation.
+   Return false if we prove the upper bits are not relevant in the operation,
+   true otherwise. */
+
+static bool
+operation_uses_upper_bits (rtx dest, rtx src, unsigned int regno_use,
+                           int indent ATTRIBUTE_UNUSED)
+{
+  rtx regspec_src = find_regspec_regno (regno_use, src);
+
+  if (check_compare (dest, src))
+    return false;
+
+  /* Store of regno to mem, size stored is the same or smaller than the extended from size */
+  if (MEM_P (dest)
+      && (GET_MODE_BITSIZE (GET_MODE (dest)) <=
+          GET_MODE_BITSIZE (ext_from_mode))
+      /* Ensure the used register is being stored and not used in another capacity, say, as a pointer. */
+      && (regspec_src))
+    return false;
+
+  /* Operation operand size is the same or smaller than the extended from size */
+  if (regspec_src)
+    {
+      if (GET_MODE_BITSIZE (GET_MODE (regspec_src)) <=
+          GET_MODE_BITSIZE (ext_from_mode))
+        return false;
+    }
+
+  /* Default to the safest result */
+  return true;
+}
+
+/* Determine if this insn also extends to the size or greater of the original extension.
+   Sign extend can propagate to zero extend and vice-versa because the upper bits
+   haven't affected the low bits up to now throughout the propagation. */
+
+static bool
+operation_extends_to_upper_bits_size (rtx src, int indent ATTRIBUTE_UNUSED)
+{
+  /* Sign extension of the same type as the originating extension.
+     Here the candidate uses the register defined by the originating extension.
+     If the candidate is found to be redundant, the originating extension is
+     replaced with a copy.
+
+     We follow these rules:
+
+     dest_mode == machine mode of the destination for this candidate extension
+     (it's the same mode as the src, e,g, reg:DI = sign_extend:DI ...)
+     src_mode == machine mode of the source for this candidate extension
+     (the mode of the used register, SI in this case, e.g. reg:DI = sign_extend:DI (subreg:SI (reg:DI))
+     ext_to_mode == machine mode of the originating extension output
+     ext_from_mode == machine mode of the originating extension input
+
+     SIZE(cand_from_mode) >= SIZE(extend_from_mode) && SIZE(cand_to_mode) <= SIZE(extend_to_mode)  
+
+     Example 1:
+     Originating (SI->DI)
+     DI       SI   HI QI 0
+     |<-------|    |  |  |
+
+     Candidate (HI->SI extension)
+     DI       SI   HI QI 0
+     |        |<---|  |  |
+
+     Not redundant, candidate does not cover the original bits:
+     SIZE(dest_mode)[SI] !<= SIZE(extend_to_mode)[DI]
+
+     Example 2:
+     Originating (HI->SI)
+     DI       SI   HI QI 0
+     |        |<---|  |  |
+
+     Candidate (QI->DI extension)
+     DI       SI   HI QI 0
+     |<-------|----|--|  |
+
+     Redundant, candidate covers the original bits:
+     SIZE(cand_to_mode) [DI] >= SIZE(extend_to_mode) [SI]
+     AND
+     SIZE(cand_from_mode) [QI] <= SIZE(extend_from_mode) [HI] */
+  if (GET_CODE (src) == ext_code)
+    {
+      /* Extend is redundant if we don't overwrite the source of the
+         previous extension and extends to at least the extent of the original. */
+      enum machine_mode cand_from_mode = GET_MODE (XEXP (src, 0));
+      enum machine_mode cand_to_mode = GET_MODE (src);
+      if (GET_MODE_BITSIZE (cand_from_mode) <=
+          GET_MODE_BITSIZE (ext_from_mode)
+          && (GET_MODE_BITSIZE (cand_to_mode) >=
+              GET_MODE_BITSIZE (ext_to_mode)))
+        return true;
+    }
+
+  /* Encountered an insn with the same effect as extension, e.g.
+     AND (regspec) (const_int). E.g. AND (reg:SI) (0xffff) is equivalent
+     to ZERO_EXTEND:DI (reg:HI) */
+  if ((GET_CODE (src) == AND) && CONST_INT_P (XEXP (src, 1)))
+    {
+      /* Extends to at least the original extension size */
+      if (GET_MODE_BITSIZE (GET_MODE (src)) >= GET_MODE_BITSIZE (ext_to_mode))
+        {
+          if (ext_from_mode == QImode && (UINTVAL (XEXP (src, 1)) <= 0xff))
+            return true;
+          else if (ext_from_mode == HImode
+                   && (UINTVAL (XEXP (src, 1)) <= 0xffff))
+            return true;
+          else if (ext_from_mode == SImode
+                   && (UINTVAL (XEXP (src, 1)) <= 0xffffffff))
+            return true;
+          else
+            return false;
+        }
+    }
+  return false;
+}
+
+/* Determine whether the operation's upper bits subtly or overtly affects the low bits. */
+
+static bool
+operation_implicitly_affects_lowbits (rtx dest, rtx src,
+                                      unsigned int regno_use, int indent)
+{
+  rtx regspec = find_regspec_regno (regno_use, src);
+
+  /* First, a return expression must be assumed to affect the lowbits as the return value
+     must be extended properly. */
+  if (return_val_p (dest))
+    {
+      if (dump_file)
+        {
+          fprintf (dump_file, "%*sDestination is a return value\n", indent,
+                   " ");
+        }
+      return true;
+    }
+
+  /* These operations implicitly affect the lowbits, except where noted. */
+  switch (GET_CODE (src))
+    {
+    case MULT:
+    case DIV:
+    case UDIV:
+    case UMOD:
+    case MOD:
+      /* Normally, yes, these operations return true (affects low bits). But when the 
+         the operand size is less than or equal to the "low bits" size AND the operation size
+         is the same as the operand size, the operation is performed only on the "low bits"
+         and the "upper bits" do not contribute to the output. */
+      if (regspec
+          && (GET_MODE_BITSIZE (GET_MODE (regspec)) <=
+              GET_MODE_BITSIZE (ext_from_mode))
+          && GET_MODE_BITSIZE (GET_MODE (src)) ==
+          GET_MODE_BITSIZE (GET_MODE (regspec)))
+        return false;
+      return true;
+
+      break;
+      /* Shift rights normally affect the low bits. There can be special cases where this
+         is not true, such a the operand size is smaller than the extended from size, e.g.
+         set (reg:SI Y) (zero_extend:SI (subreg:HI (reg:SI X)))
+         set (reg:QI Z) (lshiftrt (subreg:QI (reg:SI Y))
+         The shift of the QI data is not affected by the extension of HI data unless the
+         shift is large enough to encroach into the QI bits. This seems rare and I do not
+         check for it. */
+    case LSHIFTRT:
+    case ASHIFTRT:
+      return true;
+      break;
+      /* Other operations are known not to impact the low bits */
+    default:
+      return false;
+    }
+
+}
+
+/* The operation directly defines a propagatable output. Several
+   operations do not define such output. E.g. MEM (loads) do not
+   define an output based on the operation. USE is another example,
+   as it isn't a real operation. */
+
+static bool
+operation_directly_defines_an_output (rtx dest, rtx src,
+                                      int indent ATTRIBUTE_UNUSED)
+{
+  switch (GET_CODE (src))
+    {
+    case REG:
+    case SUBREG:
+    case PLUS:
+    case MINUS:
+    case NEG:
+    case MULT:
+    case DIV:
+    case MOD:
+    case UDIV:
+    case UMOD:
+    case AND:
+    case IOR:
+    case XOR:
+    case NOT:
+    case ASHIFT:
+    case ROTATE:
+    case ASHIFTRT:
+    case LSHIFTRT:
+    case ROTATERT:
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
+    case TRUNCATE:
+      return true;
+      break;
+      /* OK to propagate if the output of IF_THEN_ELSE is a register */
+    case IF_THEN_ELSE:
+      if (REG_P (dest))
+        return true;
+      break;
+      /* All others are assumed not to generate a normal output */
+    default:
+      break;
+    }
+  return false;
+}
+
+/* Helper for insn_use_analysis_result */
+
+static enum insn_use_results
+insn_use_analysis_result_1 (rtx insn, bool treat_as_copy,
+                            unsigned int regno_use, rtx * dest, int indent)
+{
+  rtx src;
+  bool cond_a, cond_b, cond_c, cond_d;
+
+  if (GET_CODE (insn) != SET)
+    return EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+
+  *dest = SET_DEST (insn);
+  src = SET_SRC (insn);
+
+  /* Bail out on inline assembly also */
+  if (GET_CODE (src) == ASM_INPUT || GET_CODE (src) == ASM_OPERANDS)
+    return EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+
+  /* Bail out on non supported types */
+  if (!mode_supported_p (*dest))
+    return EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+
+  /* First, we determine cond_c (is a redundant extension) because it gates the
+     other conditions. */
+  if ((cond_c = operation_extends_to_upper_bits_size (src, indent)))
+    {
+      if (treat_as_copy)
+        {
+          if (dump_file)
+            fprintf (dump_file,
+                     "%*s...%s is treated as a copy (marked for replace)\n",
+                     indent, " ", GET_RTX_NAME (GET_CODE (src)));
+          return EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION;
+        }
+
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...%s is a redundant extension\n",
+                 indent, " ", GET_RTX_NAME (GET_CODE (src)));
+      return EXTELIM_ANALYSIS_RESULT_LOWBITS_NOT_AFFECTED;
+    }
+
+  cond_a = operation_uses_upper_bits (*dest, src, regno_use, indent);
+
+  cond_b =
+    operation_implicitly_affects_lowbits (*dest, src, regno_use, indent);
+
+  cond_d = operation_directly_defines_an_output (*dest, src, indent);
+
+  /* Operation implicitly affects low bits */
+  if (cond_b)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...%s implicitly affects low bits\n",
+                 indent, " ", GET_RTX_NAME (GET_CODE (src)));
+      return EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+    }
+
+  /* Neither cond_a nor cond_b affects the low bits */
+  if (!cond_a)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...%s does not use upper bits\n",
+                 indent, " ", GET_RTX_NAME (GET_CODE (src)));
+      return EXTELIM_ANALYSIS_RESULT_LOWBITS_NOT_AFFECTED;
+    }
+
+  /* To continue recursion, the operation must define a 
+     meaningful output. */
+  if (!cond_d)
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*s...%s does not define a propagatable output\n",
+                 indent, " ", GET_RTX_NAME (GET_CODE (src)));
+      return EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+    }
+
+  /* This leaves cond_a, meaning we need to continue down the chain
+     to see if the low bits are ultimately affected by the upper bits. */
+  return EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION;
+}
+
+/* Determine the action based on the insn conditions. The truth table is
+   simplified using if statements. Insns previously marked for replace by copy
+   are identified, these will be essentially be treated as copies now and not
+   be detected as redundant for this use. */
+static enum insn_use_results
+insn_use_analysis_result (rtx insn_insn, unsigned int regno_use, rtx * dest,
+                          int indent)
+{
+  bool treat_as_copy = false;
+  if (insn_flag_p (EXTELIM_REPLACE_COPY, INSN_UID (insn_insn)))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*suse at uid=%d is marked to transform to copy\n", indent,
+                 " ", INSN_UID (insn_insn));
+      treat_as_copy = true;
+    }
+  return (insn_use_analysis_result_1
+          (PATTERN (insn_insn), treat_as_copy, regno_use, dest, indent));
+}
+
+/* We have to analyze each expression action in a PARALLEL series.
+   Return the appropriate action for a series of expressions in a PARALLEL insn. 
+   LOWBITS_AFFECTED stops the loop. This leaves only CONTINUE_RECURSION
+   or LOWBITS_NOT_AFFECTED. LOWBITS_NOT_AFFECTED is only returned
+   if there are no other different actions in the series (no CONTINUE_RECURSION
+   states). For each CONTINUE_RECURSION action we encounter, the destination
+   registers must be identical since we can only propagate one use (one definition
+   of dest) should CONTINUE_RECURSION be returned. */
+
+static enum insn_use_results
+analyze_action (enum insn_use_results cur_action,
+                enum insn_use_results prev_action,
+                rtx * dest, rtx * prev_dest)
+{
+  enum insn_use_results return_action;
+
+  if (cur_action == EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED)
+    return cur_action;
+
+  if (cur_action == EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION)
+    return_action = cur_action;
+  else if (prev_action == EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION)
+    return_action = EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION;
+  else
+    return_action = cur_action;
+
+  if (return_action == EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION)
+    {
+      if (*prev_dest)
+        {
+          /* All bets off if the series defines multiple outputs */
+          if (*prev_dest != *dest)
+            return_action = EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+        }
+    }
+  /* Set prev_dest */
+  *prev_dest = *dest;
+
+  return return_action;
+}
+
+/* Helper 2 for insn_use_analysis. Return the appropriate action
+   for a series of expressions in a PARALLEL insn. */
+
+static enum insn_use_results
+insn_use_analysis_2 (rtx insn_use, unsigned int regno_use, rtx * dest,
+                     int indent)
+{
+  int i;
+  rtx insn = PATTERN (insn_use);
+  rtx prev_dest = NULL_RTX;
+  enum insn_use_results action;
+  enum insn_use_results return_action =
+    EXTELIM_ANALYSIS_RESULT_LOWBITS_NOT_AFFECTED;
+
+  gcc_assert (GET_CODE (insn) == PARALLEL);
+
+  /* We make a quick decision about call_insns here. Since the use reached
+     a call, we assume it's an outgoing parameter and thus must be extended
+     as per the ABI. */
+  if (CALL_P (insn_use))
+    {
+      if (dump_file)
+        fprintf (dump_file, "%*s...is a call parameter\n", indent, " ");
+      return EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED;
+    }
+
+  for (i = XVECLEN (insn, 0) - 1; i >= 0; i--)
+    {
+      rtx body = XVECEXP (insn, 0, i);
+      /* Only act on the expressions containing a use of regno_use. */
+      if (regno_use_in (regno_use, body) == NULL_RTX)
+        continue;
+
+      /* Determine the next action */
+      action = insn_use_analysis_result_1 (body, false /* treat as copy */ ,
+                                           regno_use, dest, indent);
+
+      /* Here we make a decision on the return action based on the previous actions.
+         This is done to accomodate different actions from different elements in the
+         PARALLEL series of expressions. */
+      return_action =
+        analyze_action (action, return_action, dest, &prev_dest);
+
+      /* The result of this expression stops the recursion, i.e.  "low bits"
+         are affected by the operation. */
+      if (return_action == EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED)
+        break;
+    }
+  return (return_action);
+}
+
+/* Helper 1 for insn_use_analysis */
+
+static enum insn_use_results
+insn_use_analysis_1 (rtx insn_use, unsigned int regno_use, rtx * dest,
+                     int indent)
+{
+  rtx use = PATTERN (insn_use);
+  enum insn_use_results action;
+
+  switch (GET_CODE (use))
+    {
+    case PARALLEL:
+      action = insn_use_analysis_2 (insn_use, regno_use, dest, indent);
+      break;
+    default:
+      action = insn_use_analysis_result (insn_use, regno_use, dest, indent);
+      break;
+    }
+
+  return action;
+}
+
+/* Analyze the insn and determine the next course of action in the
+   use analysis loop.
+   There are several conditions to consider:
+
+   1. The "extended from" mode. This is an enum machine_mode value
+   that determines what is the size extended. It is derived from the
+   source of the original extension. It is the "low bits" value.
+   It is these range of bits that cannot be affected by the operation's
+   "upper bits" in order to determine whether the extend is useful or not.
+   Examples: 
+   (1) set (reg:DI Y (zero_extend:DI (subreg:QI (reg:DI X))) ==> low bits = QI
+   (2) set (reg:SI Y (sign_extend:SI (reg:HI X) ==> low bits = HI
+
+   2. The "extend to" mode. This is the size extended to in the original
+   extension. It is the "upper bits" value. The entire extended to size may 
+   be used subsequently or it may be subreg'd to a smaller or larger sizes 
+   later in the propagation.
+   For example (1) above, "upper bits" is DI, and (2) "upper bits" is SI.
+
+   3. The code, ext_code, of the original extension, either ZERO_EXTEND or SIGN_EXTEND.
+
+   4. Operation code. For an insn, the actual operation code corresponding to
+   a machine instruction. For certain codes, we know that the "low bits" of the
+   result are modified by the insn because of the values in the "upper bits" of the
+   input operand. We say the operation implicitly uses the "upper bits" to modify the
+   "low bits". For other codes, the "upper bits" do not affect the output result
+   in the "low bits". 
+
+   If the operation does implicitly use the "upper bits" to modify
+   the "low bits", it is instantly a deal killer. The original extension must be 
+   preserved. 
+
+   If the operation does not implicitly use "upper bits" to modify the "low bits",
+   then the action to take depends on the operation operand size relative to 
+   "low bits" size.
+
+   We only want to deal with codes that map to real instructions,
+   like ADD, SUB, MULT, LSHIFTRT, etc. Codes such as PARALLEL, etc. do not map to
+   instruction and must be dissected to extract the real instructions.
+
+   Furthermode, for recursion to continue, the operation and operand must define
+   an output related to the input operand (the use register). This doesn't happen
+   for operations such as "mem" where the output is indirectly related to the
+   input operand. 
+
+   5. Operation mode. The operation mode of the operation code. This sometimes impacts
+   the effect of the operation. For example MULT:SI and MULT:DI map to two different
+   machine instructions and both may have operands of SI mode. However, the MULT:SI 
+   results will be oblivious to the upper bits of the DI register whereas, SI part of
+   MULT:DI result will be affected by the upper bits of the DI register.
+
+   Several conditions determine the action to take based on the various inputs.
+
+   The truth table inputs are A, B, and C. The truth table output is the action to take. 
+
+   A. True if the used operand mode size is greater than the extended_from ("low bits") mode size.
+   B. True if the operation implicitly uses upper bits to define the low bits  
+   C. True if the operation also extends the output to upper bits size
+   D. True if the operation and input operand directly define an output operand.
+
+   Condition A. means the upper bits are in use in the operation. The extend _may_ be needed, 
+   all things being equal, so the action would be to continue recursion to the use of the
+   defined operand, i.e. return CONTINUE_RECURSION.
+
+   Condition B. means the "low bits" are modified by the extended portion of the register
+   by virtue of the operation. For example, logical shift right, where the extended
+   portion is shifted into the "low bits". Another example, multiply, where the machine
+   uses the extended portion implicitly to calculate the results, some of which are 
+   reflected in the "low bits" of the result. The extension is definitely needed in these 
+   cases for this use, so return LOWBITS_AFFECTED. Recursion is stopped and analysis of 
+   this extension is halted.
+
+   Condition C. means the operation and it's operands perform the same extension as
+   the originating extension. The operation must extend to the same size _or higher_ of
+   the original extension. In this case, the original extension is truly redundant and
+   we return LOWBITS_NOT_AFFECTED for this use.
+
+   Condtion D. means the operation and operand directly define an output operand. For most
+   arithmetic and unary operations this is true. For mem and other internal operations,
+   e.g. USE, this is false.
+
+      Condition                      Action                 Comments
+    ==================================================================
+    A.     B.     C.     D.
+    ------------------------------------------------------------------
+    X      X      true   true     LOW_BITS_NOT_AFFECTED  extend is redundant
+    ------------------------------------------------------------------
+    false  false  false  X        LOW_BITS_NOT_AFFECTED  used operand is smaller than "low bits"
+    ------------------------------------------------------------------
+    false  true   false  true     LOW_BITS_AFFECTED      "low bits" modified implicitly by operation
+    ------------------------------------------------------------------
+    true   false  false  true     CONTINUE_RECURSION     "low bits" _may_ be impacted by next uses
+    ------------------------------------------------------------------
+    true   true   false  true     LOW_BITS_AFFECTED      "low bits" modified implicitly by operation */
+
+static enum insn_use_results
+insn_use_analysis (rtx insn_use, unsigned int regno_use, rtx * dest,
+                   int indent)
+{
+  return (insn_use_analysis_1 (insn_use, regno_use, dest, indent));
+}
+
+/* Analyze the operation and operands of this use of a sign extension
+   target register. If the target register's upper bits do not
+   affect the result of the operation, then the sign extension is
+   useless. Returns true if the extension is needed, false 
+   otherwise. */
+
+static bool
+analyze_ext_use (rtx insn_use, unsigned int regno_use, int indent)
+{
+  bool ext_needed, indent_once;
+  unsigned int dest_target_regno;
+  extelim_uid_t uid;
+  rtx use = PATTERN (insn_use), dest;
+  df_ref df_use, *p_def;
+  struct df_link *link;
+  enum insn_use_results analysis_result;
+
+  gcc_assert (use != NULL);
+
+  uid = INSN_UID (insn_use);
+
+  if (insn_flag_p (EXTELIM_SEEN, uid))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*suse at uid=%d is visited already\n", indent, " ", uid);
+      return false;
+    }
+
+  /* Mark this insn as seen */
+  insn_flag_set (EXTELIM_SEEN, uid);
+
+  analysis_result = insn_use_analysis (insn_use, regno_use, &dest, indent);
+  switch (analysis_result)
+    {
+      /* We know conclusively that the "upper bits" of the extended
+         entity do not impact the "low bits" of the output of the operation. */
+    case EXTELIM_ANALYSIS_RESULT_LOWBITS_NOT_AFFECTED:
+      if (dump_file)
+        fprintf (dump_file, "%*suse at uid=%d is not affected\n", indent, " ",
+                 uid);
+      return false;
+      break;
+      /* We know conclusively that the "upper bits" of the extended
+         entity _do_ impact the "low bits" of the output of the operation. */
+    case EXTELIM_ANALYSIS_RESULT_LOWBITS_AFFECTED:
+      if (dump_file)
+        fprintf (dump_file, "%*suse at uid=%d is affected\n", indent, " ",
+                 uid);
+      return true;
+      break;
+      /* Continue to look at the uses of the result to determine the impact
+         of the "upper bits" */
+    case EXTELIM_ANALYSIS_RESULT_CONTINUE_RECURSION:
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  /* We reach here because the action taken is CONTINUE_RECURSION.
+     Continue to look at the uses of the destination register recursively. 
+     If the propagation ultimately ends where the upper bits are not significant 
+     to the final output, then the extension can be removed. */
+  if (!REG_P (dest))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*sdest of uid=%d (SET) is not a register\n", indent, " ",
+                 uid);
+      return true;
+    }
+
+  dest_target_regno = REGNO (dest);
+
+  /* What this insn defines */
+  p_def = DF_INSN_UID_DEFS (uid);
+
+  /* Ref must be valid and there must be only one definition and it must be the
+     destination */
+  if ((*p_def == NULL) || (*(p_def + 1) != NULL))
+    return true;
+
+  gcc_assert (DF_REF_REGNO (*p_def) == dest_target_regno);
+
+  ext_needed = true;
+  indent_once = true;
+  for (link = DF_REF_CHAIN (*p_def); link; link = link->next)
+    {
+      rtx insn_use, use_exp;
+      df_use = link->ref;
+      if (!df_use)
+        continue;
+      /* Link must be a USE of the DEF */
+      if (!DF_REF_REG_USE_P (df_use))
+        continue;
+      /* Ignore ARTIFICIAL USES */
+      if (DF_REF_IS_ARTIFICIAL (df_use))
+        continue;
+      insn_use = DF_REF_INSN (df_use);
+      /* Don't consider debug_insns */
+      if (!NONDEBUG_INSN_P (insn_use))
+        continue;
+      use_exp = DF_REF_REG (df_use);
+
+      if (exp_needs_update_p (use_exp))
+        {
+          if (dump_file)
+            fprintf (dump_file,
+                     "%*ssaved reg=%d expression for update\n", indent, " ", DF_REF_REGNO (df_use));
+          save_ext_update (current_ext_record, use_exp);
+        }
+
+      if (dump_file)
+        fprintf (dump_file,
+                 "%*suse at uid=%d of reg=%d\n", indent, " ",
+                 INSN_UID (insn_use), DF_REF_REGNO (df_use));
+      /* Set indent for dump formatting */
+      if (indent_once)
+        {
+          ++indent;
+          indent_once = false;
+        }
+      ext_needed = analyze_ext_use (insn_use, DF_REF_REGNO (df_use), indent);
+      if (ext_needed)
+        break;
+    }
+
+  if (dump_file)
+    fprintf (dump_file,
+             "%*sext %s needed\n", indent, " ", ext_needed ? "" : "not");
+
+  return ext_needed;
+}
+
+/* Set a flag on an insn indicating that it is
+   marked for replacement by a copy insn or for
+   deletion. */
+
+static void
+mark_replace_with_copy (rtx ext)
+{
+  extelim_uid_t uid = INSN_UID (ext);
+  insn_flag_set (EXTELIM_REPLACE_COPY, uid);
+}
+
+/* Get the mode that we are sign/zero extending from */
+
+static enum machine_mode
+get_ext_from_mode (rtx src)
+{
+  rtx regexp;
+  gcc_assert (GET_CODE (src) == ZERO_EXTEND || GET_CODE (src) == SIGN_EXTEND);
+
+  /* The SUBREG or REG mode of the extend operand */
+  regexp = XEXP (src, 0);
+  return (GET_MODE (regexp));
+}
+
+/* Perform the action on the expression. Return true
+   if any action performed, false otherwise. */
+
+static bool 
+process_ext_update (rtx exp)
+{
+  /* Reset SUBREG_PROMOTED state to false */
+  if (GET_CODE (exp) == SUBREG
+      && SUBREG_PROMOTED_VAR_P (exp))
+    {
+      SUBREG_PROMOTED_VAR_P (exp) = 0;
+      return true;
+    }
+
+  return false;
+}
+
+/* Process the current extension record, looking at all the
+   the expressions that need to be updated because this
+   extension will be replaced by a copy. */
+
+static void
+process_ext_updates (ext_record_t extrec)
+{
+  unsigned i;
+  rtx exp;
+  bool updated=false;
+
+
+  FOR_EACH_VEC_SAFE_ELT (extrec->ext_updates, i, exp)
+    {
+      updated |= process_ext_update (exp);
+    }
+
+  if (dump_file && updated)
+    fprintf (dump_file, " updates processed for extension at uid=%d\n",
+             INSN_UID (extrec->ext));
+}
+
+/* Try to eliminate the sign extension by examining the
+   definitions of the extension source and the uses
+   of the extension destination. */
+
+static void
+eliminate_one_extend (rtx ext)
+{
+  rtx src, dest, regexp;
+  df_ref df_use, df_def, *ext_use, *ext_def;
+  unsigned int ext_dest_regno, ext_src_regno, def_use_count = 1;
+  bool ext_needed = true;
+  extelim_uid_t uid = INSN_UID (ext);
+  struct df_link *link;
+  const char *inserted =
+    insn_flag_p (EXTELIM_INSERTED, uid) ? "inserted" : "";
+
+  /* Reset desired per insn flags for each extension analyzed */
+  reinit_insn_flags (EXTELIM_SEEN);
+
+  gcc_assert (GET_CODE (PATTERN (ext)) == SET);
+  src = SET_SRC (PATTERN (ext));
+  dest = SET_DEST (PATTERN (ext));
+
+  /* Save the basic information about the extension in a file global */
+  ext_to_mode = GET_MODE (dest);
+  ext_from_mode = get_ext_from_mode (src);
+  ext_code = GET_CODE (src);
+
+  /* Also mark this original extension as "SEEN" so we don't recurse into it. */
+  insn_flag_set (EXTELIM_SEEN, INSN_UID (ext));
+
+  /* Find the target of the extension */
+  if (!REG_P (dest))
+    return;
+  ext_dest_regno = REGNO (dest);
+
+  /* Find the source of the extension: set (REG:MODE (sign_extend (REG|SUBREG:MODE ... */
+  if ((regexp = register_exp (XEXP (src, 0))) == NULL)
+    return;
+  ext_src_regno = REGNO (regexp);
+
+  /* Iterate through the reaching definitions of the source of the extension 
+     recursively. If the source if already sign extended, mark the 
+     extension for replacement with a copy or deletion (deletion if it was
+     inserted in the duplication pass). */
+  ext_use = DF_INSN_UID_USES (uid);
+  /* There is only one use in a sign/zero extension insn and it must be the
+     source register */
+  gcc_assert (*(ext_use + 1) == NULL);
+  gcc_assert (DF_REF_REGNO (*ext_use) == ext_src_regno);
+
+  /* Now look at all the reaching definitions of this use */
+  for (link = DF_REF_CHAIN (*ext_use); link; link = link->next)
+    {
+      rtx insn_def;
+      df_def = link->ref;
+      if (!df_def)
+        continue;
+      /* Link must be to a definition of the use */
+      if (!DF_REF_REG_DEF_P (df_def))
+        continue;
+      /* Ignore ARTIFICIAL defs */
+      if (DF_REF_IS_ARTIFICIAL (df_def))
+        continue;
+      insn_def = DF_REF_INSN (df_def);
+      /* Don't consider debug_insns */
+      if (!NONDEBUG_INSN_P (insn_def))
+        continue;
+      if (dump_file)
+        fprintf (dump_file,
+                 " analyze def #%d of reg=%d at uid=%u\n",
+                 def_use_count, DF_REF_REGNO (*ext_use), INSN_UID (insn_def));
+      ext_needed = analyze_ext_def (insn_def, DF_REF_REGNO (*ext_use), 2);
+      if (ext_needed)
+        break;
+      def_use_count++;
+    }
+
+  /* Try the def-use chains if the extension wasn't marked by the
+     previous pass. */
+  if (ext_needed)
+    {
+      /* Defs of the sign extension */
+      ext_def = DF_INSN_UID_DEFS (uid);
+      /* There is only one def in a sign extension insn and it must be the
+         destination */
+      gcc_assert (*(ext_def + 1) == NULL);
+      gcc_assert (DF_REF_REGNO (*ext_def) == ext_dest_regno);
+
+      /* Counter for debug dump */
+      def_use_count = 1;
+      /* Reset desired per insn flags for each extension analyzed */
+      reinit_insn_flags (EXTELIM_SEEN);
+      /* Also mark this original extension as "SEEN" so we don't recurse into it. */
+      insn_flag_set (EXTELIM_SEEN, INSN_UID (ext));
+
+      /* Iterate over the reached uses of extension destination register recursively.
+         If the destination register's upper bits are ultimately not
+         relevant, the extension can be marked for replacement with a
+         copy. */
+      for (link = DF_REF_CHAIN (*ext_def); link; link = link->next)
+        {
+          rtx insn_use, use_exp;
+          df_use = link->ref;
+          if (!df_use)
+            continue;
+          /* Link must be a USE of the DEF */
+          if (!DF_REF_REG_USE_P (df_use))
+            continue;
+          /* Ignore ARTIFICIAL USES */
+          if (DF_REF_IS_ARTIFICIAL (df_use))
+            continue;
+          insn_use = DF_REF_INSN (df_use);
+          /* Don't consider debug_insns */
+          if (!NONDEBUG_INSN_P (insn_use))
+            continue;
+          use_exp = DF_REF_REG (df_use);
+
+          if (exp_needs_update_p (use_exp))
+            {
+              if (dump_file)
+                fprintf (dump_file,
+                         " saved reg=%d expression for update\n", DF_REF_REGNO (df_use));
+              save_ext_update (current_ext_record, use_exp);
+            }
+            
+          if (dump_file)
+            fprintf (dump_file,
+                     " analyze use #%d at uid=%u of reg=%d\n",
+                     def_use_count, INSN_UID (insn_use),
+                     DF_REF_REGNO (*ext_def));
+          ext_needed = analyze_ext_use (insn_use, DF_REF_REGNO (*ext_def), 2);
+          if (ext_needed)
+            break;
+          def_use_count++;
+        }
+    }
+
+  /* The extension is not needed. The rtl for the extension is marked
+     for replace by copy. */
+  if (!ext_needed)
+    {
+      process_ext_updates (current_ext_record);
+
+      if (dump_file)
+        fprintf (dump_file,
+                 ":) mark %s extension insn uid=%d for copy replacement\n",
+                 inserted, INSN_UID (ext));
+      mark_replace_with_copy (ext);
+      num_cand_transformed++;
+    }
+  else
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 ":( %s extension insn uid=%d is needed\n", inserted,
+                 INSN_UID (ext));
+    }
+}
+
+/* Replace the sign extension with a copy instruction
+
+   example 1:
+   from:
+        dest              src
+   (set (reg:DI destreg) (sign_extend:DI (reg:SI srcreg)))
+   to:
+   (clobber (reg:DI destreg))
+   (set (subreg:SI (reg:DI destreg) 4) (reg:SI srcreg)) 
+
+   or
+
+   example 2:
+   from:
+        dest             src
+   (set (reg:DI destreg) (sign_extend:DI (subreg:SI (reg:DI srcreg) 4)))
+   to:
+   (clobber (reg:DI destreg))
+   (set (subreg:SI (reg:DI destreg) 4) (subreg:SI (reg:DI srcreg) 4)) 
+
+   or
+
+   example 3:
+   from:
+        dest             src
+   (set (reg:SI destreg) (sign_extend:SI (subreg:HI (reg:SI srcreg) 2)))
+   to:
+   (clobber (reg:SI destreg))
+   (set (subreg:HI (reg:SI destreg) 2) (subreg:HI (reg:SI srcreg) 2)) */
+
+static void
+replace_with_copy (rtx ext)
+{
+  rtx extension = PATTERN (ext);
+  rtx ext_op, src, dest, insns, cp_dest, cp_src;
+  enum machine_mode inner_mode;
+  gcc_assert (GET_CODE (extension) == SET);
+
+  dest = SET_DEST (extension);
+  src = SET_SRC (extension);
+
+  /* The sign extension operand */
+  ext_op = XEXP (src, 0);
+  /* Get the inner mode */
+  inner_mode = GET_MODE (ext_op);
+  gcc_assert (inner_mode == SImode || inner_mode == HImode
+              || inner_mode == QImode);
+
+  /* Make dest a SUBREG:mm */
+  cp_dest = gen_lowpart_SUBREG (inner_mode, dest);
+
+  /* Copy src is the sign extension target register */
+  cp_src = ext_op;
+
+  /* ??? clobber is needed for rtl consistency, don't know why */
+  start_sequence ();
+  emit_clobber (dest);
+  emit_move_insn (cp_dest, cp_src);
+  insns = get_insns ();
+  end_sequence ();
+  emit_insn_before (insns, ext);
+
+  delete_insn (ext);
+}
+
+/* Iterate through extensions, replace those extensions
+   that are marked as so with a copy insn. */
+
+static void
+replace_ext_with_copy (void)
+{
+  ext_record_t extrec;
+  unsigned i;
+
+  FOR_EACH_VEC_SAFE_ELT (extensions, i, extrec)
+  {
+    const char *inserted = insn_flag_p (EXTELIM_INSERTED,
+                                        INSN_UID (extrec->
+                                                  ext)) ? "inserted" : "";
+    if (insn_flag_p (EXTELIM_REPLACE_COPY, INSN_UID (extrec->ext)))
+      {
+        if (dump_file)
+          fprintf (dump_file,
+                   " replace %s extension uid=%d with a copy\n", inserted,
+                   INSN_UID (extrec->ext));
+        replace_with_copy (extrec->ext);
+      }
+  }
+}
+
+
+/* Copy the RTX flags from old to new */
+
+static void
+copy_flags (rtx oldrtx, rtx newrtx)
+{
+  if (RTX_FLAG (oldrtx, in_struct))
+    RTX_FLAG (newrtx, in_struct) = true;
+
+  if (RTX_FLAG (oldrtx, volatil))
+    RTX_FLAG (newrtx, volatil) = true;
+
+  if (RTX_FLAG (oldrtx, unchanging))
+    RTX_FLAG (newrtx, unchanging) = true;
+
+  if (RTX_FLAG (oldrtx, frame_related))
+    RTX_FLAG (newrtx, frame_related) = true;
+
+  if (RTX_FLAG (oldrtx, jump))
+    RTX_FLAG (newrtx, jump) = true;
+
+  if (RTX_FLAG (oldrtx, call))
+    RTX_FLAG (newrtx, call) = true;
+
+  if (RTX_FLAG (oldrtx, return_val))
+    RTX_FLAG (newrtx, return_val) = true;
+}
+
+/* Iterate through the insn notes looking for 'kind'. If 
+   found replace the register rtx with the new rtx. */
+
+static void
+update_notes (enum reg_note kind, rtx insn, rtx reg, rtx new_reg)
+{
+  rtx link;
+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+    if (REG_NOTE_KIND (link) == kind)
+      {
+        rtx op0 = XEXP (link, 0);
+        if (kind == REG_DEAD)
+          if (REG_P (op0) && op0 == reg)
+            XEXP (link, 0) = new_reg;
+      }
+}
+
+
+
+#if EXTELIM_DUPLICATE_EXTS_AT_USES
+/* Insert a duplicate sign extension at the use point.
+   Add a flag indicating this extension is algorithmically
+   added. Since the "inserted" extensions have the form
+   regX = sign_extend (subreg:mm (reg:MM regX), offset), 
+   they can simply be deleted if they are redundant since we 
+   are at a reaching use of the original definition. We also 
+   mark the use insn where the insert occurs so we don't insert 
+   the same extension from another def at this use. */
+
+static void
+insert_duplicate_ext_at_use (rtx ext_insn, rtx use_insn)
+{
+  int i;
+  rtx ext = PATTERN (ext_insn), ext_src, ext_dest;
+  rtx new_ext_src_inner, new_ext_src_outer, new_ext_part;
+  rtx new_ext_dest, new_ext_insn;
+  extelim_uid_t new_uid;
+  df_ref *p_df_uses;
+  unsigned int ext_dest_regno;
+  enum machine_mode inner_mode;
+  bool sign_extend_p =
+    GET_CODE (SET_SRC (PATTERN (ext_insn))) == SIGN_EXTEND ? true : false;
+
+  /* This new extension must be of the form:
+     set (reg:MM X (sign_extend:MM (subreg:mm (reg:MM X)))) 
+     where mm is smaller than MM. */
+  ext_dest = SET_DEST (ext);
+  ext_src = SET_SRC (ext);
+
+  gcc_assert (REG_P (register_exp (ext_dest)));
+
+  /* A copy of the extend destination register to a new virtual register */
+  new_ext_dest = gen_reg_rtx (GET_MODE (ext_dest));
+  /* A copy of the extend source (same reg as dest), REG_P */
+  new_ext_src_inner = copy_rtx (ext_dest);
+  /* Get inner mode, either mm for SUBREG:mm (REG:MM) or MM for (REG:MM) */
+  if (GET_CODE (XEXP (ext_src, 0)) == SUBREG)
+    inner_mode = GET_MODE (XEXP (ext_src, 0));
+  else if (REG_P (XEXP (ext_src, 0)))
+    inner_mode = GET_MODE (XEXP (ext_src, 0));
+  else
+    /* Can't determine sign_extend operand */
+    gcc_unreachable ();
+
+  /* Make a subreg rtx */
+  new_ext_src_outer = gen_lowpart_SUBREG (inner_mode, new_ext_src_inner);
+  /* Make a sign/zero extend insn */
+  new_ext_part = sign_extend_p
+    ? gen_rtx_SIGN_EXTEND (GET_MODE (ext_dest), new_ext_src_outer)
+    : gen_rtx_ZERO_EXTEND (GET_MODE (ext_dest), new_ext_src_outer);
+  /* (set (new:MM (sign_extend:MM (subreg:mm (reg:MM ext_dest))))) */
+  new_ext_insn = gen_rtx_SET (VOIDmode, new_ext_dest, new_ext_part);
+
+  /* Now update the use */
+  /* Operands used by this the use_insn */
+  ext_dest_regno = REGNO (register_exp (ext_dest));
+  for (p_df_uses = DF_INSN_UID_USES (INSN_UID (use_insn)), i = 0; *p_df_uses;
+       p_df_uses++, i++)
+    {
+      if (DF_REF_REGNO (*p_df_uses) == ext_dest_regno)
+        {
+          rtx use_reg = DF_REF_REG (*p_df_uses);
+
+          /*  Replace the register use in use_insn with the new register. If the use
+             is a subreg pattern, replace the innermost reg. */
+          replace_rtx (PATTERN (use_insn), register_exp (use_reg),
+                       new_ext_dest);
+          /* Update flags on new dest reg */
+          copy_flags (register_exp (use_reg), new_ext_dest);
+          /* Update any notes associated with use reg and use_insn */
+          update_notes (REG_DEAD, use_insn, register_exp (use_reg), new_ext_dest);
+          /* DF info must be updated since existing insn is changed */
+          if (df_insn_rescan (use_insn))
+            {
+              p_df_uses = DF_INSN_UID_USES (INSN_UID (use_insn));
+	      p_df_uses += i;
+            }
+        }
+    }
+
+  new_uid = extelim_emit_before (new_ext_insn, use_insn);
+  insn_flag_set (EXTELIM_INSERTED, new_uid);
+}
+
+/* Allow the duplication of the extension even if the extension
+   and the duplication use are in the same block. */
+
+static bool
+allow_duplication_p (rtx ext_insn, rtx use_insn)
+{
+  rtx ext = PATTERN (ext_insn);
+  rtx use = PATTERN (use_insn);
+  rtx insn;
+  basic_block bb;
+  bool found_zxt=false;
+
+  /* Do not allow duplication if use is already preceded by a ZERO_EXTEND in this 
+     basic block. Start at beginning of block and search down until the use insn. */
+
+  bb = BLOCK_FOR_INSN (use_insn);
+  FOR_BB_INSNS (bb, insn)
+    {
+      if (!NONDEBUG_INSN_P (insn))
+        continue;
+      if (insn == use_insn)
+        break;
+      if ((GET_CODE (PATTERN (insn)) == SET)
+          && (GET_CODE (SET_SRC (PATTERN (insn))) == ZERO_EXTEND))
+        found_zxt=true;
+    }
+
+  /* We must have found the use insn (and therefore insn is not null) */
+  gcc_assert(insn != NULL_RTX);
+
+  if (found_zxt)
+    return false;
+
+  if (GET_CODE (SET_SRC (use)) == ASHIFT && GET_CODE (SET_SRC (ext)) == ZERO_EXTEND)
+    return true;
+
+  return false;
+}
+
+/* Determine if the extension should be duplicated at this use point.
+   Return true if yes, false otherwise. */
+
+static bool
+save_ext_use_p (ext_record_t extrec, rtx use_insn)
+{
+  rtx ext_insn, ext, ext_dest, use = PATTERN (use_insn);
+  df_ref df_use, df_def;
+  struct df_link *link;
+
+  ext_insn = extrec->ext;
+  ext = PATTERN (ext_insn);
+  ext_dest = SET_DEST (ext);
+
+  if (GET_CODE (use) != SET)
+    return false;
+
+  /* 1. If the use defines itself, e.g.
+     128 = ZERO_EXTEND (159) ; the def
+     ...
+     128 = ASHIFT (128) ; the use
+     ...
+     use 128 ; use reached by the self-assign above
+     then disallow the duplication. RTX's are shared within an insn 
+     so you end up with
+     128 = ZERO_EXTEND (159)
+     ...
+     NewVR = ZERO_EXTEND (128) ; the duplicate extension
+     NewVR = ASHIFT(NewVR) ; wrong! should define 128 for next use 
+     ...
+     use 128
+  */
+  if (REGNO(SET_DEST(use)) == REGNO(SET_DEST(ext)))
+    return false;
+  
+
+  /* 2. Duplicate the extension at certain CODEs that are known to generate 
+     a target insn when paired with the extension duplication. E.g. 
+     128 = ZERO_EXTEND (159)
+     153 = ASHIFT (128)
+     will match a single rldic insn. This limits extension duplication to points where it is
+     possibly beneficial if the original extension is deleted. It doesn't guarantee that
+     the original extension will be deleted, however, because the elimination pass has to
+     make that decision. */
+  if (INSN_P (ext_insn) && INSN_P (use_insn))
+    {
+      if ( ! allow_duplication_p (ext_insn, use_insn))
+          return false;
+    }
+
+  /* 3. Check if all other definitions reaching this use are already extended,
+     and therefore duplicating the extension does not change the value
+     of that reaching definition. (testcase: nof/muldf3.c) */
+  df_use = df_find_use (use_insn, ext_dest);
+
+  /* Iterate through definitions reaching this use */
+  for (link = DF_REF_CHAIN (df_use); link; link = link->next)
+    {
+      rtx insn_def, def;
+      df_def = link->ref;
+      if (!df_def)
+        continue;
+      /* Link must be to a definition of the use */
+      if (!DF_REF_REG_DEF_P (df_def))
+        continue;
+      /* Ignore ARTIFICIAL defs */
+      if (DF_REF_IS_ARTIFICIAL (df_def))
+        continue;
+      insn_def = DF_REF_INSN (df_def);
+      def = PATTERN (insn_def);
+
+      /* If def is a PARALLEL, find the SET */
+      if (GET_CODE (def) == PARALLEL)
+	{
+	  int i;
+	  for (i = 0; i < XVECLEN (def, 0); i++)
+	    {
+	      rtx body = XVECEXP (def, 0, i);
+	      if (GET_CODE (body) == SET)
+		{
+		  def = body;
+		  break;
+		}
+	      return false;
+	    }
+	}
+
+      /* Don't consider debug_insns */
+      if (!NONDEBUG_INSN_P (insn_def))
+        continue;
+
+      /* The original extension, obviously ignore this one. */
+      if (insn_def == ext_insn)
+        continue;
+
+      /* We must know what mode we are extending from in 'operand_is_extended' */
+      ext_from_mode = get_ext_from_mode ( SET_SRC (ext) );
+
+      /* Here we check whether the defined operand is already extended (insn_def) with
+         respect to the potentially duplicated extension (ext). Bail out if any reaching
+         defs are not extended. */ 
+      if ( ! operand_is_extended (ext, SET_SRC (def), 2 /* indent */) ) 
+          return false;
+    }
+  return true;
+}
+
+/* Save the use insn in the extension records list of
+   uses. At the next phase, we will duplicate the extension
+   at these use points. */
+
+static void
+save_ext_use (ext_record_t extrec, rtx use_insn)
+{
+  /* Mark the use insn, it will have a duplicate inserted */
+  insn_flag_set (EXTELIM_INSERTED_FOR, INSN_UID (use_insn));
+  /* Save use to the list of uses to be duplicated for this extension. */
+  vec_safe_push(extrec->ext_uses, use_insn);
+}
+
+
+/* Save the qualified use of an extension to a list */
+
+static void
+gather_ext_uses_info (ext_record_t extrec)
+{
+  rtx ext;
+  df_ref *ext_def, df_use;
+  unsigned int def_use_count = 1;
+  extelim_uid_t uid;
+  struct df_link *link;
+
+  gcc_assert (extrec != NULL);
+  ext = extrec->ext;
+  uid = INSN_UID (ext);
+
+  /* Insn level defs of the sign extension */
+  ext_def = DF_INSN_UID_DEFS (uid);
+  /* There is only one def in a sign extension insn */
+  gcc_assert (*(ext_def + 1) == NULL);
+
+  /* Iterate over the reached uses of extension destination register.
+     Duplicate the extension at the use point. */
+  for (link = DF_REF_CHAIN (*ext_def); link; link = link->next)
+    {
+      rtx insn_use;
+      df_use = link->ref;
+      if (!df_use)
+        continue;
+      /* Link must be a USE of the DEF */
+      if (!DF_REF_REG_USE_P (df_use))
+        continue;
+      /* Ignore ARTIFICIAL USES */
+      if (DF_REF_IS_ARTIFICIAL (df_use))
+        continue;
+      insn_use = DF_REF_INSN (df_use);
+
+      /* Don't consider debug_insns */
+      if (!NONDEBUG_INSN_P (insn_use))
+        continue;
+
+      if (dump_file)
+        fprintf (dump_file,
+                 " use #%d: insert duplicate extension of reg=%d at uid=%u? ",
+                 def_use_count, DF_REF_REGNO (*ext_def), INSN_UID (insn_use));
+
+      /* Determine whether its worthwhile duplicating the extension at this use */
+      if (save_ext_use_p (extrec, insn_use))
+        {
+          if (dump_file)
+            fprintf (dump_file, "  yes\n");
+          save_ext_use (extrec, insn_use);
+        }
+      else
+        {
+          if (dump_file)
+            fprintf (dump_file, "  no\n");
+        }
+      def_use_count++;
+    }
+}
+
+/* At each use point of the sign extension, unless the 
+   use is obviously already sign extended, insert a 
+   sign extension insn before the use if criteria for inserting
+   a duplicate extension is met.
+   Do this in 2 passes to avoid confusing the dataflow information. */
+
+static void
+duplicate_exts_at_uses (void)
+{
+  unsigned i, j;
+  ext_record_t extrec;
+  rtx use_insn;
+
+  if (dump_file)
+    fprintf (dump_file, "Duplicate Extension at Uses pass.\n");
+
+  /* Get the uses where the extensions will be duplicated */
+  FOR_EACH_VEC_SAFE_ELT (extensions, i, extrec)
+  {
+    if (dump_file)
+      fprintf (dump_file, "gathering extension uid=%u use information\n",
+               INSN_UID (extrec->ext));
+    gather_ext_uses_info (extrec);
+  }
+
+  /* Now duplicate the extensions at the appropriate use points */
+  FOR_EACH_VEC_SAFE_ELT (extensions, i, extrec)
+  {
+    FOR_EACH_VEC_SAFE_ELT (extrec->ext_uses, j, use_insn)
+    {
+      insert_duplicate_ext_at_use (extrec->ext, use_insn);
+    }
+  }
+}
+#endif /* EXTELIM_DUPLICATE_EXTS_AT_USES */
+
+/* Determine if an instruction is a return insn */
+
+static rtx
+return_p (rtx rtn_insn)
+{
+  rtx rtn = PATTERN (rtn_insn), dest;
+  int i;
+
+  if (GET_CODE (rtn) != SET)
+    return false;
+
+  dest = SET_DEST (rtn);
+
+  /* Is a return value? */
+  if ((REG_P (dest) || GET_CODE (dest) == PARALLEL) &&
+      REG_FUNCTION_VALUE_P (dest))
+    {
+      /* Simple SET, return the insn */
+      if (REG_P (dest))
+        return rtn_insn;
+      /* PARALLEL, find the embedded rtx */
+      if (GET_CODE (dest) == PARALLEL)
+        for (i = XVECLEN (rtn_insn, 0) - 1; i >= 0; i--)
+          {
+            rtx body = XVECEXP (rtn_insn, 0, i);
+            if (GET_CODE (body) == SET)
+              {
+                dest = SET_DEST (body);
+                if (REG_FUNCTION_VALUE_P (dest))
+                  return body;
+              }
+          }
+    }
+  /* Not a return */
+  return NULL;
+}
+
+/* Find all return RTLs in the function and save them in
+   a list. */
+
+static bool
+find_returns (void)
+{
+  basic_block bb;
+  rtx insn, rtn_insn;
+  bool found = false;
+
+  /* For all insns  */
+  FOR_EACH_BB_FN (bb, cfun)
+  {
+    FOR_BB_INSNS (bb, insn)
+    {
+      if (!NONDEBUG_INSN_P (insn))
+        continue;
+
+      if ((rtn_insn = return_p (insn)) == NULL)
+        {
+          continue;
+        }
+      if (dump_file)
+        fprintf (dump_file, " found return at uid=%u\n", INSN_UID (rtn_insn));
+
+      vec_safe_push(returns, rtn_insn);
+      found = true;
+    }
+  }
+
+  return (found);
+}
+
+/* Get the signedness and machine mode of the function */
+
+static bool
+get_return_info (bool * signed_p, enum machine_mode *return_mode)
+{
+  tree rtninfo;
+
+  if ((rtninfo = DECL_RESULT (current_function_decl)) != NULL)
+    {
+      *signed_p = !TYPE_UNSIGNED (TREE_TYPE (rtninfo));
+      *return_mode = DECL_MODE (rtninfo);
+      return true;
+    }
+  return false;
+}
+
+/* If the dest mode of the return is larger than
+   the function return mode, we can subreg the return
+   insn to the return mode and extend to the destination.
+   E.g. unsigned, return mode: HImode
+   set (reg/i:DI Y) (reg:DI X) 
+   becomes
+   set (reg:DI new) (zero_extend:DI (subreg:HI (reg:DI X)))
+   set (reg/i:DI Y) (reg:DI new) */
+
+static void
+make_ext_at_rtn (rtx rtn_insn, bool fun_signed_p, enum machine_mode fun_mode)
+{
+  rtx rtn = PATTERN (rtn_insn);
+  rtx dest, src, new_ext_dest, new_ext_src, new_ext_outer, new_ext_part,
+    new_ext_insn, prev_insn = prev_active_insn (rtn_insn);
+  extelim_uid_t new_uid;
+  gcc_assert (GET_CODE (rtn) == SET);
+
+  dest = SET_DEST (rtn);
+  src = SET_SRC (rtn);
+
+  /* Do not insert extension if the preceeding insn is already an extension. 
+     - Bug: ENGR00239811. 
+     We end up with consecutive extensions (one inserted, one previously there).
+     This is not great, but shouldn't be catastrophic as one will be transformed to a copy.
+     The order in which the extensions are processed in windows and linux is different,
+     however. Combine fails to treat either case equally and misses an important extension
+     in the windows program. Combine is complex and there's no obvious reason why it is
+     failing, so this will have to do. */
+ if (prev_insn)
+    {
+      prev_insn = PATTERN(prev_insn);
+      if (GET_CODE (prev_insn) == SET) 
+        {
+          enum rtx_code prev_code = GET_CODE (SET_SRC (prev_insn));
+          if (prev_code == ZERO_EXTEND || prev_code == SIGN_EXTEND) 
+            {
+              if (dump_file)
+                fprintf (dump_file, "failed-- prev insn is an extension\n");
+              return;
+            }
+        }
+    }
+
+  /* Deal with scalar rtn values only */
+  if (fun_mode != DImode
+      && fun_mode != SImode && fun_mode != HImode && fun_mode != QImode)
+    {
+      if (dump_file)
+        fprintf (dump_file, "failed-- not scalar return mode\n");
+      return;
+    }
+
+  /* Dest and src have to have the same mode. This should always be
+     true for well formed rtl, but we check anyway. */
+  if (GET_MODE (dest) != GET_MODE (src))
+    {
+      if (dump_file)
+        fprintf (dump_file, "failed-- dest and src modes differ\n");
+      return;
+    }
+
+  /* Also check that we are dealing with simple regs here. */
+  if (!REG_P (dest) || !REG_P (src))
+    {
+      if (dump_file)
+        fprintf (dump_file, "failed-- dest or src is not REG_P\n");
+      return;
+    }
+
+  /* The return reg mode should never be smaller than fun return mode. If the
+     same size, however, we can't subreg either, so return */
+  if (GET_MODE_BITSIZE (GET_MODE (dest)) <= GET_MODE_BITSIZE (fun_mode))
+    {
+      if (dump_file)
+        fprintf (dump_file,
+                 "failed-- dest size mode is smaller or equal to function mode size\n");
+      return;
+    }
+
+  /* From here we should be able to build a subreg since the function return mode
+     size is smaller than the return register mode size */
+  new_ext_dest = gen_reg_rtx (GET_MODE (src));  /*  set (reg:MM new) */
+  new_ext_src = copy_rtx (src); /*  copy of X, copyX */
+  new_ext_outer = gen_lowpart_SUBREG (fun_mode, new_ext_src);   /*  subreg:mm (reg:MM copyX) */
+  new_ext_part = fun_signed_p   /*  extend:MM (subreg:mm (reg:MM copyX)) */
+    ? gen_rtx_SIGN_EXTEND (GET_MODE (src), new_ext_outer)
+    : gen_rtx_ZERO_EXTEND (GET_MODE (src), new_ext_outer);
+  /* Put it together */
+  new_ext_insn = gen_rtx_SET (VOIDmode, new_ext_dest, new_ext_part);
+
+  /* Modify src of return insn to use new pseudo */
+  replace_rtx (PATTERN (rtn_insn), src, new_ext_dest);
+  /* Update flags on new dest reg */
+  copy_flags (src, new_ext_dest);
+  /* Update any notes associated with replaced register */
+  update_notes (REG_DEAD, rtn_insn, src, new_ext_dest);
+  /* Rescan the modified insn */
+  df_insn_rescan (rtn_insn);
+  /* Insert the new insn */
+  new_uid = extelim_emit_before (new_ext_insn, rtn_insn);
+
+  if (dump_file)
+    fprintf (dump_file, "success\n");
+}
+
+/* Insert extensions at return points. Scan the RTL
+   for the return statements. Determine if the RTL 
+   can be modified to insert an extension. Modify the
+   return to insert the extension. */
+
+static void
+insert_ext_at_returns (void)
+{
+  bool signed_p;
+  enum machine_mode return_mode;
+  rtx rtn_insn;
+  int i;
+
+  /* Generate list of return rtls for the function */
+  if (dump_file)
+    {
+      fprintf (dump_file, "Insert Extensions at Returns pass.\n");
+      fprintf (dump_file, "gathering return insns...\n");
+    }
+
+  if (!find_returns ())
+    return;
+
+  if (!get_return_info (&signed_p, &return_mode))
+    return;
+
+  /* For each return instruction, generate a sign/zero extend
+     if the current return size is larger than the function
+     return mode. */
+  FOR_EACH_VEC_SAFE_ELT (returns, i, rtn_insn)
+  {
+    if (dump_file)
+      fprintf (dump_file, " making extension at return uid=%u...",
+               INSN_UID (rtn_insn));
+    make_ext_at_rtn (rtn_insn, signed_p, return_mode);
+  }
+}
+
+/* Compare two extension records by loop depth.
+   Used by VEC_qsort to sort the order in which extensions
+   are processed. */
+
+static int
+ext_record_compare (const void *p_er1, const void *p_er2)
+{
+  const ext_record_t er1 = *(const ext_record_t *) p_er1;
+  const ext_record_t er2 = *(const ext_record_t *) p_er2;
+  basic_block bb1, bb2;
+  rtx ext1, ext2;
+
+  if (er1 == er2)
+    return 0;
+
+  ext1 = er1->ext;
+  ext2 = er2->ext;
+
+  bb1 = BLOCK_FOR_INSN (ext1);
+  bb2 = BLOCK_FOR_INSN (ext2);
+
+  /* Sort high to low */
+  return (bb_loop_depth(bb2) - bb_loop_depth(bb1));
+}
+
+static bool
+gate_handle_extelim (void)
+{
+  return (optimize > 0 && flag_extelim
+          && !flag_wrapv && !flag_trapv && flag_strict_overflow);
+}
+
+/* The main interface to this optimization. */
+static unsigned int
+rest_of_handle_extelim (void)
+{
+  ext_record_t ext;
+  unsigned i;
+
+  init_pass ();
+
+  /* Find initial sign extension candidates */
+  if (!find_extensions ())
+    {
+      finish_pass ();
+      return 0;
+    }
+
+  /* Insert sign extension at return points in
+     the function. */
+  insert_ext_at_returns ();
+
+  /* Duplicate the sign extensions at their use
+     points unless the use is already obviously sign
+     extended or extension is already added. */
+#if EXTELIM_DUPLICATE_EXTS_AT_USES
+  duplicate_exts_at_uses ();
+#endif
+
+  /* Update DF information since now have new insns. */
+  df_finish_pass (true);
+  df_chain_add_problem (DF_DU_CHAIN + DF_UD_CHAIN);
+  df_analyze ();
+
+#if EXTELIM_DF_DUMP
+  if (dump_file)
+    df_dump (dump_file);
+#endif
+
+  /* Init statistics */
+  num_cand = 0;
+  num_cand_ignored = 0;
+  num_cand_transformed = 0;
+
+  /* Free old extensions list, generate new one that includes
+     the new extensions. */
+  free_extensions ();
+
+ if (!find_extensions ())
+    {
+      finish_pass ();
+      return 0;
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "\nRTL After Extension Duplication\n");
+      print_rtl (dump_file, get_insns ());
+    }
+
+  if (dump_file)
+    fprintf (dump_file, "Begin extension elimination analysis\n");
+
+  /* Sort the extensions by loop depth. We want to try to eliminate
+     those in innermost loops (highest loop depth) first. */
+  if (!vec_safe_is_empty(extensions))
+    extensions->qsort(ext_record_compare);
+
+  /* Iterate through extension worklist */
+  FOR_EACH_VEC_SAFE_ELT (extensions, i, ext)
+  {
+    rtx ext_insn = ext->ext;
+    rtx ext_src = SET_SRC (PATTERN (ext_insn));
+    const char *ext_name =
+      GET_CODE (ext_src) == SIGN_EXTEND ? "sign" : "zero";
+    const char *inserted =
+      insn_flag_p (EXTELIM_INSERTED, INSN_UID (ext_insn)) ? "inserted" : "";
+    extelim_uid_t uid = INSN_UID (ext_insn);
+
+    if (dump_file)
+      fprintf (dump_file,
+               "<analyzing %s %s extension uid=%u> (loop_depth=%d)\n",
+               inserted, ext_name, uid,
+               bb_loop_depth(BLOCK_FOR_INSN (ext_insn)));
+
+    current_ext_record = ext;
+    eliminate_one_extend (ext->ext);
+  }
+
+  if (dump_file)
+    fprintf (dump_file, "Begin extension elimination transformations\n");
+
+  replace_ext_with_copy ();
+
+  if (dump_file)
+    fprintf (dump_file, "\nRTL After Extension Elimination\n");
+
+  finish_pass ();
+
+  /* Print statistics */
+  if (dump_file)
+    {
+      fprintf (dump_file,
+               "Number of extensions ignored: %d (of %d candidiates)\nDETECTION EFFECTIVENESS: %f%%\n",
+               num_cand_ignored, num_cand,
+               ((float) (num_cand - num_cand_ignored) / (float) num_cand) *
+               100);
+      fprintf (dump_file,
+               "Number of extensions converted to copy: %d (of %d candidiates)\nCONVERSION EFFECTIVENESS: %f%%\n",
+               num_cand_transformed, num_cand,
+               ((float) num_cand_transformed / (float) num_cand) * 100);
+    }
+  return 0;
+}
+
+namespace {
+
+const pass_data pass_data_rtl_extelim =
+{
+  RTL_PASS,							/* type */
+  "extelim", 							/* name */
+  OPTGROUP_NONE,						/* optinfo_flags */
+  true,								/* has_gate */
+  true,								/* has_execute */
+  TV_EXTELIM,							/* tv_id */
+  0,								/* properties_required */
+  0,								/* properties_provided */
+  0,								/* properties_destroyed */
+  0,								/* todo_flags_start */
+  ( TODO_df_finish | TODO_verify_rtl_sharing ),		/* todo_flags_finish */
+};
+
+class pass_rtl_extelim : public rtl_opt_pass
+{
+public:
+  pass_rtl_extelim (gcc::context *ctxt)
+    : rtl_opt_pass (pass_data_rtl_extelim, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate () { return gate_handle_extelim (); }
+  unsigned int execute () { return rest_of_handle_extelim (); }
+
+}; // class pass_rtl_extelim
+
+} // anon namespace
+
+rtl_opt_pass *
+make_pass_rtl_extelim (gcc::context *ctxt)
+{
+  return new pass_rtl_extelim (ctxt);
+}
+
diff -rNu gcc-4.9.2/gcc/config/rs6000/fsl-linux.h test/gcc-4.9.2/gcc/config/rs6000/fsl-linux.h
--- gcc-4.9.2/gcc/config/rs6000/fsl-linux.h	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/fsl-linux.h	2018-04-02 14:15:41.000000000 +0800
@@ -0,0 +1,4 @@
+
+/* The C soft-float libraries have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC  "%{msoft-float:/nof}"
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi0.S test/gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi0.S
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi0.S	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi0.S	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,57 @@
+/*
+ * crt0.S -- startup file for PowerPC systems.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include "ppc-asm.h"
+
+	.file	"sim-crt0.S"
+	.text
+FUNC_START(_start)
+	lis	r0,0
+	stw	r0,0(sp)	/* clear back chain */
+	stwu	sp,-64(sp)	/* push another stack frame */
+
+	/* Let her rip */
+#if defined (__powerpc64__)
+	.section ".init"
+._init:
+	.text
+	bl	FUNC_NAME(_init)
+	nop
+	/* return value from main is argument to exit */
+	bl	FUNC_NAME(exit)
+	nop
+#else
+	bl	FUNC_NAME(__init)
+	bl	FUNC_NAME(main)#
+	/* return value from main is argument to exit */
+	bl	FUNC_NAME(exit)
+#endif
+FUNC_END(_start)
+
+	.extern	FUNC_NAME(atexit)
+	.globl	FUNC_NAME(__atexit)
+	.section ".sdata","aw"
+	.align	2
+FUNC_NAME(__atexit):			/* tell C's eabi-ctor's we have an atexit function */
+#if defined (__powerpc64__)
+	.long	FUNC_NAME(atexit)	/* and that it is to register __do_global_dtors */
+#else
+	.long	FUNC_NAME(atexit)@fixup	/* and that it is to register __do_global_dtors */
+
+	.section ".fixup","aw"
+	.align	2
+	.long	FUNC_NAME(__atexit)
+#endif
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi9.S test/gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi9.S
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi9.S	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/crtaeabi9.S	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,12 @@
+#include "ppc-asm.h"
+
+	.file	"sim-crt9.S"
+
+#if defined (__powerpc64__)
+	.section ".init","ax"
+	bl	FUNC_NAME(main)
+	nop
+	/* return value from main is argument to exit */
+	bl	FUNC_NAME(exit)
+	nop
+#endif
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/fstat.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/fstat.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/fstat.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/fstat.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,30 @@
+/* fstat.c -- get status of a file.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include <sys/stat.h>
+#include "glue.h"
+
+/*
+ * fstat -- Since we have no file system, we just return an error.
+ */
+int
+_DEFUN (fstat, (fd, buf),
+       int fd _AND
+       struct stat *buf)
+{
+  buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
+  buf->st_blksize = 0;
+
+  return (0);
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/getpid.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/getpid.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/getpid.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/getpid.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,25 @@
+/* getpid.c -- get the current process id.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include "glue.h"
+
+/*
+ * getpid -- only one process, so just return 1.
+ */
+int
+_DEFUN (getpid, (),
+        )
+{
+  return __MYPID;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/glue.h test/gcc-4.9.2/gcc/config/rs6000/libaeabi/glue.h
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/glue.h	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/glue.h	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,31 @@
+/* glue.h -- common definitions for "glue" fucntions.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include <_ansi.h>
+
+#ifndef NULL
+#  define NULL 0
+#endif
+
+#ifdef __NO_UNDERSCORE__
+#  define _end    end
+#  define _exit	  exit
+#endif
+
+extern char _end[];                /* _end is set in the linker command file */
+
+/* only one prcess support, as this is OS dependant */
+#define __MYPID 1
+
+
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/isatty.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/isatty.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/isatty.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/isatty.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,27 @@
+/* isatty.c -- chek the terminal device.
+ * 
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include "glue.h"
+
+/*
+ * isatty -- returns 1 if connected to a terminal device,
+ *           returns 0 if not. Since we're hooked up to a
+ *           serial port, we'll say yes _AND return a 1.
+ */
+int
+_DEFUN (isatty, (fd),
+       int fd)
+{
+  return (1);
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/kill.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/kill.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/kill.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/kill.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,29 @@
+/* kill.c -- remove a process.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include <unistd.h>
+#include "glue.h"
+
+/*
+ * kill -- go out via exit...
+ */
+int
+_DEFUN (kill, (pid, sig),
+        int pid _AND 
+        int sig)
+{
+  if(pid == __MYPID)
+    _exit(sig);
+  return 0;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/mcount.S test/gcc-4.9.2/gcc/config/rs6000/libaeabi/mcount.S
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/mcount.S	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/mcount.S	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,27 @@
+/*
+ * mcount.S -- dummy module for profiling.
+ *
+ * Copyright (c) 1997 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include "ppc-asm.h"
+
+	.file	"mcount-dummy.S"
+	.text
+FUNC_START(_mcount)
+	mflr	r11
+	lwz	r0,4(sp)
+	mtctr	r11
+	mtlr	r0
+	bctr
+FUNC_END(_mcount)
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/putnum.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/putnum.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/putnum.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/putnum.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,41 @@
+/* putnum.c -- put a hex number on the output device.
+ * 
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include "glue.h"
+
+/*
+ * putnum -- print a 32 bit number in hex
+ */
+void
+_DEFUN (putnum, (num),
+	unsigned int num)
+{
+  char  buf[9];
+  int   cnt;
+  char  *ptr;
+  int   digit;
+  
+  ptr = buf;
+  for (cnt = 7 ; cnt >= 0 ; cnt--) {
+    digit = (num >> (cnt * 4)) & 0xf;
+    
+    if (digit <= 9)
+      *ptr++ = (char) ('0' + digit);
+    else
+      *ptr++ = (char) ('a' - 10 + digit);
+  }
+
+  *ptr = (char) 0;
+  print (buf);
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-abort.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-abort.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-abort.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-abort.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,22 @@
+/*
+ * sim-abort.c -- PowerPC abort support when running under the simulator.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include <stdlib.h>
+void abort(void)
+{
+  write (2, "Abort called.\n", sizeof("Abort called.\n")-1);
+  exit (1);
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-errno.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-errno.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-errno.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-errno.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,28 @@
+/*
+ * sim-errno.c -- return address of errno for current thread.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include <errno.h>
+#include <reent.h>
+
+/* syscall handler branches here in case of error. */
+
+int
+_cerror (e)
+     int e;
+{
+  _REENT->_errno = e;
+  return -1;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-getrusage.S test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-getrusage.S
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-getrusage.S	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-getrusage.S	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,25 @@
+/*
+ * sim-getrusage.S -- PowerPC simulator getrusage call.
+ *
+ * Copyright (c) 1995, 2000, 2001 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include "ppc-asm.h"
+
+FUNC_START(getrusage)
+	li	r0,117
+	sc
+	bns+	0f
+	b	FUNC_NAME(_cerror)
+0:	blr
+FUNC_END(getrusage)
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-inbyte.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-inbyte.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-inbyte.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-inbyte.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,26 @@
+/*
+ * sim-inbyte.c -- read a character from standard input.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+int
+inbyte ()
+{
+  char c;
+
+  if (read (0, &c, 1) <= 0)
+    return -1;
+
+  return c;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-print.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-print.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-print.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-print.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,43 @@
+/* sim-print.c -- print a string on the output device.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+/*
+ * print -- do a raw print of a string
+ */ 
+void
+print (ptr)
+     char *ptr;
+{
+  int len = 0;
+  char *p = ptr;
+
+  while (*p != '\0')
+    p++;
+
+  write (1, ptr, p-ptr);
+}
+
+/*
+ * outbyte -- write a single character.
+ */
+
+void
+outbyte (c_int)
+     int c_int;
+{
+  char c = c_int;
+
+  write (1, &c, 1);
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-sbrk.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-sbrk.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-sbrk.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/sim-sbrk.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,31 @@
+/*
+ * sim-sbrk.c -- PowerPC sbrk support when running under the simulator.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+extern char _end[];
+static char *curbrk = _end;
+extern char *brk(char *);
+
+char *
+sbrk (incr)
+     int incr;
+{
+  char *oldbrk = curbrk;
+  curbrk = brk (oldbrk + incr);
+  if (curbrk == oldbrk)
+    return (char *) -1;
+
+  return oldbrk;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/simulator.S test/gcc-4.9.2/gcc/config/rs6000/libaeabi/simulator.S
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/simulator.S	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/simulator.S	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,95 @@
+/*
+ * simulator.S -- PowerPC simulator system calls.
+ *
+ * Copyright (c) 1995, 2000, 2001 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include "ppc-asm.h"
+
+FUNC_START(_exit)
+	li	r0, 1
+	sc
+
+/*
+ * Insure that the debugger tells the client that the PC is in _exit,
+ * not whatever function happens to follow this function.
+ */
+
+0:	trap
+	b	0b			/* we never should return, but... */
+
+FUNC_END(_exit)
+
+FUNC_START(read)
+	li	r0,3
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(read)
+
+FUNC_START(write)
+	li	r0,4
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(write)
+
+FUNC_START(open)
+	li	r0,5
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(open)
+
+FUNC_START(close)
+	li	r0,6
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(close)
+
+FUNC_START(brk)
+	li	r0,45
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(brk)
+
+FUNC_START(access)
+	li	r0,33
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(access)
+
+FUNC_START(dup)
+	li	r0,41
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(dup)
+
+FUNC_START(gettimeofday)
+	li	r0,116
+	sc
+	bns+	0f
+	b	FUNC_NAME(_cerror)
+0:	blr
+FUNC_END(gettimeofday)
+
+FUNC_START(lseek)
+	li	r0,199
+	sc
+	bnslr+
+	b	FUNC_NAME(_cerror)
+FUNC_END(lseek)
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/stat.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/stat.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/stat.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/stat.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,30 @@
+/* stat.c -- Get the status of a file.
+ *
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include <sys/stat.h>
+#include <errno.h>
+#include "glue.h"
+
+/*
+ * stat -- Since we have no file system, we just return an error.
+ */
+int
+_DEFUN (stat, (path, buf),
+       const char *path _AND
+       struct stat *buf)
+{
+  errno = EIO;
+  return (-1);
+}
+
diff -rNu gcc-4.9.2/gcc/config/rs6000/libaeabi/unlink.c test/gcc-4.9.2/gcc/config/rs6000/libaeabi/unlink.c
--- gcc-4.9.2/gcc/config/rs6000/libaeabi/unlink.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/libaeabi/unlink.c	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,28 @@
+/* unlink.c -- remove a file.
+ * 
+ * Copyright (c) 1995 Cygnus Support
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+#include <errno.h>
+#include "glue.h"
+
+/*
+ * unlink -- since we have no file system, 
+ *           we just return an error.
+ */
+int
+_DEFUN (unlink, (path),
+        char * path)
+{
+  errno = EIO;
+  return (-1);
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/linux64.h test/gcc-4.9.2/gcc/config/rs6000/linux64.h
--- gcc-4.9.2/gcc/config/rs6000/linux64.h	2014-07-25 01:25:19.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/linux64.h	2018-04-02 14:15:42.000000000 +0800
@@ -367,14 +367,14 @@
 #undef	LINK_OS_DEFAULT_SPEC
 #define LINK_OS_DEFAULT_SPEC "%(link_os_linux)"
 
-#define GLIBC_DYNAMIC_LINKER32 "/lib/ld.so.1"
+#define GLIBC_DYNAMIC_LINKER32 SYSTEMLIBS_DIR "ld.so.1"
 #ifdef LINUX64_DEFAULT_ABI_ELFv2
-#define GLIBC_DYNAMIC_LINKER64 "%{mabi=elfv1:/lib64/ld64.so.1;:/lib64/ld64.so.2}"
+#define GLIBC_DYNAMIC_LINKER64 "%{mabi=elfv1:" SYSTEMLIBS_DIR "ld64.so.1;:" SYSTEMLIBS_DIR "ld64.so.2}"
 #else
-#define GLIBC_DYNAMIC_LINKER64 "%{mabi=elfv2:/lib64/ld64.so.2;:/lib64/ld64.so.1}"
+#define GLIBC_DYNAMIC_LINKER64 "%{mabi=elfv2:" SYSTEMLIBS_DIR "ld64.so.2;:" SYSTEMLIBS_DIR "ld64.so.1}"
 #endif
-#define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER32 SYSTEMLIBS_DIR "ld-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER64 SYSTEMLIBS_DIR "ld64-uClibc.so.0"
 #if DEFAULT_LIBC == LIBC_UCLIBC
 #define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:" G ";:" U "}"
 #elif DEFAULT_LIBC == LIBC_GLIBC
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000-builtin.def test/gcc-4.9.2/gcc/config/rs6000/rs6000-builtin.def
--- gcc-4.9.2/gcc/config/rs6000/rs6000-builtin.def	2014-06-14 05:56:16.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000-builtin.def	2018-04-02 14:15:30.000000000 +0800
@@ -632,6 +632,42 @@
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+/* Power ISA 2.07 altivec */
+#define BU_ALTIVC2_2(ENUM, NAME, ATTR, ICODE)                          \
+  RS6000_BUILTIN_2 (ALTIVEC_BUILTIN_ ## ENUM,          /* ENUM */      \
+                   "__builtin_altivec_" NAME,          /* NAME */      \
+                   (RS6000_BTM_ALTIVEC                 /* MASK */      \
+                    | RS6000_BTM_ALTIVEC2),                            \
+                   (RS6000_BTC_ ## ATTR                /* ATTR */      \
+                    | RS6000_BTC_BINARY),                              \
+                   CODE_FOR_ ## ICODE)                 /* ICODE */
+
+#define BU_ALTIVC2_X(ENUM, NAME, ATTR)                                 \
+  RS6000_BUILTIN_X (ALTIVEC_BUILTIN_ ## ENUM,          /* ENUM */      \
+                   "__builtin_altivec_" NAME,          /* NAME */      \
+                   (RS6000_BTM_ALTIVEC                 /* MASK */      \
+                    | RS6000_BTM_ALTIVEC2),                            \
+                   (RS6000_BTC_ ## ATTR                /* ATTR */      \
+                    | RS6000_BTC_SPECIAL),                             \
+                   CODE_FOR_nothing)                   /* ICODE */
+
+#define BU_ALTIVC2_OVERLOAD_2(ENUM, NAME)                              \
+  RS6000_BUILTIN_2 (ALTIVEC_BUILTIN_VEC_ ## ENUM,      /* ENUM */      \
+                   "__builtin_vec_" NAME,              /* NAME */      \
+                   (RS6000_BTM_ALTIVEC                 /* MASK */      \
+                    | RS6000_BTM_ALTIVEC2),                            \
+                   (RS6000_BTC_OVERLOADED              /* ATTR */      \
+                    | RS6000_BTC_BINARY),                              \
+                   CODE_FOR_nothing)                   /* ICODE */
+
+#define BU_ALTIVC2_OVERLOAD_X(ENUM, NAME)                              \
+  RS6000_BUILTIN_X (ALTIVEC_BUILTIN_VEC_ ## ENUM,      /* ENUM */      \
+                   "__builtin_vec_" NAME,              /* NAME */      \
+                   (RS6000_BTM_ALTIVEC                 /* MASK */      \
+                    | RS6000_BTM_ALTIVEC2),                            \
+                   (RS6000_BTC_OVERLOADED              /* ATTR */      \
+                    | RS6000_BTC_SPECIAL),                             \
+                   CODE_FOR_nothing)                   /* ICODE */
 #endif
 
 /* Insure 0 is not a legitimate index.  */
@@ -685,6 +721,9 @@
 BU_ALTIVEC_D (DSTSTT,	      "dststt",		MISC,  	altivec_dststt)
 
 /* Altivec 2 argument builtin functions.  */
+BU_ALTIVC2_2 (VABSDUB,        "vabsdub",	CONST,	altivec_vabsdub)
+BU_ALTIVC2_2 (VABSDUH,        "vabsduh",	CONST,	altivec_vabsduh)
+BU_ALTIVC2_2 (VABSDUW,        "vabsduw",	CONST,	altivec_vabsduw)
 BU_ALTIVEC_2 (VADDUBM,        "vaddubm",	CONST,	addv16qi3)
 BU_ALTIVEC_2 (VADDUHM,	      "vadduhm",	CONST,	addv8hi3)
 BU_ALTIVEC_2 (VADDUWM,	      "vadduwm",	CONST,	addv4si3)
@@ -876,6 +915,9 @@
 BU_ALTIVEC_X (LVEBX,		"lvebx",	    MEM)
 BU_ALTIVEC_X (LVEHX,		"lvehx",	    MEM)
 BU_ALTIVEC_X (LVEWX,		"lvewx",	    MEM)
+BU_ALTIVC2_X (LVEXBX,		"lvexbx",	    MEM)
+BU_ALTIVC2_X (LVEXHX,		"lvexhx",	    MEM)
+BU_ALTIVC2_X (LVEXWX,		"lvexwx",	    MEM)
 BU_ALTIVEC_X (LVXL,		"lvxl",		    MEM)
 BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    MEM)
 BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    MEM)
@@ -901,9 +943,19 @@
 BU_ALTIVEC_C (LVLXL,		"lvlxl",	    MEM)
 BU_ALTIVEC_C (LVRX,		"lvrx",		    MEM)
 BU_ALTIVEC_C (LVRXL,		"lvrxl",	    MEM)
+BU_ALTIVC2_X (LVTLX,           "lvtlx",            MEM)
+BU_ALTIVC2_X (LVTLXL,          "lvtlxl",           MEM)
+BU_ALTIVC2_X (LVTRX,           "lvtrx",            MEM)
+BU_ALTIVC2_X (LVTRXL,          "lvtrxl",           MEM)
+BU_ALTIVC2_X (LVSWX,           "lvswx",            MEM)
+BU_ALTIVC2_X (LVSWXL,          "lvswxl",           MEM)
+BU_ALTIVC2_X (LVSM,            "lvsm",             MEM)
 BU_ALTIVEC_X (STVEBX,		"stvebx",	    MEM)
 BU_ALTIVEC_X (STVEHX,		"stvehx",	    MEM)
 BU_ALTIVEC_X (STVEWX,		"stvewx",	    MEM)
+BU_ALTIVC2_X (STVEXBX,         "stvexbx",          MEM)
+BU_ALTIVC2_X (STVEXHX,         "stvexhx",          MEM)
+BU_ALTIVC2_X (STVEXWX,         "stvexwx",          MEM)
 BU_ALTIVEC_X (STVXL,		"stvxl",	    MEM)
 BU_ALTIVEC_X (STVXL_V2DF,	"stvxl_v2df",	    MEM)
 BU_ALTIVEC_X (STVXL_V2DI,	"stvxl_v2di",	    MEM)
@@ -915,6 +967,12 @@
 BU_ALTIVEC_C (STVLXL,		"stvlxl",	    MEM)
 BU_ALTIVEC_C (STVRX,		"stvrx",	    MEM)
 BU_ALTIVEC_C (STVRXL,		"stvrxl",	    MEM)
+BU_ALTIVC2_X (STVFLX,          "stvflx",           MEM)
+BU_ALTIVC2_X (STVFLXL,         "stvflxl",          MEM)
+BU_ALTIVC2_X (STVFRX,          "stvfrx",           MEM)
+BU_ALTIVC2_X (STVFRXL,         "stvfrxl",          MEM)
+BU_ALTIVC2_X (STVSWX,          "stvswx",           MEM)
+BU_ALTIVC2_X (STVSWXL,         "stvswxl",          MEM)
 BU_ALTIVEC_X (MASK_FOR_LOAD,	"mask_for_load",    MISC)
 BU_ALTIVEC_X (MASK_FOR_STORE,	"mask_for_store",   MISC)
 BU_ALTIVEC_X (VEC_INIT_V4SI,	"vec_init_v4si",    CONST)
@@ -959,6 +1017,10 @@
 BU_ALTIVEC_OVERLOAD_D (DSTSTT,	   "dststt")
 
 /* 2 argument Altivec overloaded builtins.  */
+BU_ALTIVC2_OVERLOAD_2 (ABSD,	   "absd")
+BU_ALTIVC2_OVERLOAD_2 (ABSDUB,	   "absdub")
+BU_ALTIVC2_OVERLOAD_2 (ABSDUH,	   "absduh")
+BU_ALTIVC2_OVERLOAD_2 (ABSDUW,	   "absduw")
 BU_ALTIVEC_OVERLOAD_2 (ADD,	   "add")
 BU_ALTIVEC_OVERLOAD_2 (ADDC,	   "addc")
 BU_ALTIVEC_OVERLOAD_2 (ADDS,	   "adds")
@@ -1131,10 +1193,20 @@
 BU_ALTIVEC_OVERLOAD_X (LVEBX,	   "lvebx")
 BU_ALTIVEC_OVERLOAD_X (LVEHX,	   "lvehx")
 BU_ALTIVEC_OVERLOAD_X (LVEWX,	   "lvewx")
+BU_ALTIVC2_OVERLOAD_X (LVEXBX,	   "lvexbx")
+BU_ALTIVC2_OVERLOAD_X (LVEXHX,	   "lvexhx")
+BU_ALTIVC2_OVERLOAD_X (LVEXWX,	   "lvexwx")
 BU_ALTIVEC_OVERLOAD_X (LVLX,	   "lvlx")
 BU_ALTIVEC_OVERLOAD_X (LVLXL,	   "lvlxl")
 BU_ALTIVEC_OVERLOAD_X (LVRX,	   "lvrx")
 BU_ALTIVEC_OVERLOAD_X (LVRXL,	   "lvrxl")
+BU_ALTIVC2_OVERLOAD_X (LVTLX,	   "lvtlx")
+BU_ALTIVC2_OVERLOAD_X (LVTLXL,	   "lvtlxl")
+BU_ALTIVC2_OVERLOAD_X (LVTRX,	   "lvtrx")
+BU_ALTIVC2_OVERLOAD_X (LVTRXL,	   "lvtrxl")
+BU_ALTIVC2_OVERLOAD_X (LVSWX,	   "lvswx")
+BU_ALTIVC2_OVERLOAD_X (LVSWXL,	   "lvswxl")
+BU_ALTIVC2_OVERLOAD_X (LVSM,	   "lvsm")
 BU_ALTIVEC_OVERLOAD_X (LVSL,	   "lvsl")
 BU_ALTIVEC_OVERLOAD_X (LVSR,	   "lvsr")
 BU_ALTIVEC_OVERLOAD_X (PROMOTE,	   "promote")
@@ -1148,10 +1220,19 @@
 BU_ALTIVEC_OVERLOAD_X (STVEBX,	   "stvebx")
 BU_ALTIVEC_OVERLOAD_X (STVEHX,	   "stvehx")
 BU_ALTIVEC_OVERLOAD_X (STVEWX,	   "stvewx")
+BU_ALTIVC2_OVERLOAD_X (STVEXBX,	   "stvexbx")
+BU_ALTIVC2_OVERLOAD_X (STVEXHX,	   "stvexhx")
+BU_ALTIVC2_OVERLOAD_X (STVEXWX,	   "stvexwx")
 BU_ALTIVEC_OVERLOAD_X (STVLX,	   "stvlx")
 BU_ALTIVEC_OVERLOAD_X (STVLXL,	   "stvlxl")
 BU_ALTIVEC_OVERLOAD_X (STVRX,	   "stvrx")
 BU_ALTIVEC_OVERLOAD_X (STVRXL,	   "stvrxl")
+BU_ALTIVC2_OVERLOAD_X (STVFLX,	   "stvflx")
+BU_ALTIVC2_OVERLOAD_X (STVFLXL,	   "stvflxl")
+BU_ALTIVC2_OVERLOAD_X (STVFRX,	   "stvfrx")
+BU_ALTIVC2_OVERLOAD_X (STVFRXL,	   "stvfrxl")
+BU_ALTIVC2_OVERLOAD_X (STVSWX,	   "stvswx")
+BU_ALTIVC2_OVERLOAD_X (STVSWXL,	   "stvswxl")
 BU_ALTIVEC_OVERLOAD_X (VCFSX,	   "vcfsx")
 BU_ALTIVEC_OVERLOAD_X (VCFUX,	   "vcfux")
 BU_ALTIVEC_OVERLOAD_X (VSPLTB,	   "vspltb")
@@ -1928,6 +2009,81 @@
 BU_SPE_X (MFSPEFSCR,	      "mfspefscr",	MISC)
 BU_SPE_X (MTSPEFSCR,	      "mtspefscr",	MISC)
 
+#define BU_ISEL_X(ENUM, NAME)						\
+  RS6000_BUILTIN_X (RS6000_BUILTIN_ISEL ## ENUM,	/* ENUM */	\
+		    "__builtin_isel" NAME,		/* NAME */	\
+		    RS6000_BTM_ISEL,			/* MASK */	\
+		    (RS6000_BTC_OVERLOADED | RS6000_BTC_PURE),		        /* ATTR */	\
+		    CODE_FOR_nothing)			/* ICODE */
+#define BU_ISEL_OVERLOAD_X(ENUM, NAME)				\
+  RS6000_BUILTIN_X (RS6000_BUILTIN_ISEL_ ## ENUM,	/* ENUM */	\
+		    "__builtin_isel" NAME,		/* NAME */	\
+		    RS6000_BTM_ISEL,			/* MASK */	\
+		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
+		     | RS6000_BTC_PURE),				\
+		    CODE_FOR_nothing)			/* ICODE */
+/* ISEL builtins.  */
+/* Generic versions that get resolved to specific builtins.  */
+BU_ISEL_X(EQ, "eq")
+BU_ISEL_X(GT, "gt")
+BU_ISEL_X(LT, "lt")
+BU_ISEL_X(GTU, "gtu")
+BU_ISEL_X(LTU, "ltu")
+/* Same deal, but for 64-bit comparisons.  */
+BU_ISEL_X(EQD, "eqd")
+BU_ISEL_X(GTD, "gtd")
+BU_ISEL_X(LTD, "ltd")
+BU_ISEL_X(GTDU, "gtdu")
+BU_ISEL_X(LTDU, "ltdu")
+
+/* Each set of arguments is polymorphic in selected arguments and return
+   value.  */
+#undef RS6000_ISEL_BASE
+#define RS6000_ISEL_BASE(ARG, PRED, CMP, NAME)     \
+  BU_ISEL_OVERLOAD_X(PRED##CMP##_##ARG##_SS, NAME) \
+  BU_ISEL_OVERLOAD_X(PRED##CMP##_##ARG##_PP, NAME) \
+  BU_ISEL_OVERLOAD_X(PRED##CMP##_##ARG##_UU, NAME)
+
+#undef RS6000_ISEL_PTR_ARG
+#define RS6000_ISEL_PTR_ARG(PRED, CMP, NAME) RS6000_ISEL_BASE(PP, PRED, CMP, NAME)
+#undef RS6000_ISEL_SIGNED_ARG
+#define RS6000_ISEL_SIGNED_ARG(PRED, CMP, NAME) RS6000_ISEL_BASE(SS, PRED, CMP, NAME)
+#undef RS6000_ISEL_UNSIGNED_ARG
+#define RS6000_ISEL_UNSIGNED_ARG(PRED, CMP, NAME) RS6000_ISEL_BASE(UU, PRED, CMP, NAME)
+
+#undef RS6000_ISEL_EQ
+#define RS6000_ISEL_EQ(CMP, NAME)          \
+  RS6000_ISEL_PTR_ARG(EQ, CMP, NAME)       \
+  RS6000_ISEL_SIGNED_ARG(EQ, CMP, NAME)    \
+  RS6000_ISEL_UNSIGNED_ARG(EQ, CMP, NAME)
+
+#undef RS6000_ISEL_LT
+#define RS6000_ISEL_LT(CMP, NAME) RS6000_ISEL_SIGNED_ARG(LT, CMP, NAME)
+
+#undef RS6000_ISEL_GT
+#define RS6000_ISEL_GT(CMP, NAME) RS6000_ISEL_SIGNED_ARG(GT, CMP, NAME)
+
+#undef RS6000_ISEL_LTU
+#define RS6000_ISEL_LTU(CMP, NAME)         \
+  RS6000_ISEL_PTR_ARG(LTU, CMP, NAME)      \
+  RS6000_ISEL_UNSIGNED_ARG(LTU, CMP, NAME)
+
+#undef RS6000_ISEL_GTU
+#define RS6000_ISEL_GTU(CMP, NAME)         \
+  RS6000_ISEL_PTR_ARG(GTU, CMP, NAME)      \
+  RS6000_ISEL_UNSIGNED_ARG(GTU, CMP, NAME)
+
+RS6000_ISEL_EQ(CMPW, "eq")
+RS6000_ISEL_LT(CMPW, "lt")
+RS6000_ISEL_GT(CMPW, "gt")
+RS6000_ISEL_LTU(CMPW, "ltu")
+RS6000_ISEL_GTU(CMPW, "gtu")
+RS6000_ISEL_EQ(CMPD, "eqd")
+RS6000_ISEL_LT(CMPD, "ltd")
+RS6000_ISEL_GT(CMPD, "gtd")
+RS6000_ISEL_LTU(CMPD, "ltdu")
+RS6000_ISEL_GTU(CMPD, "gtdu")
+
 
 /* Power7 builtins, that aren't VSX instructions.  */
 BU_SPECIAL_X (POWER7_BUILTIN_BPERMD, "__builtin_bpermd", RS6000_BTM_POPCNTD,
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000.c test/gcc-4.9.2/gcc/config/rs6000/rs6000.c
--- gcc-4.9.2/gcc/config/rs6000/rs6000.c	2014-10-13 10:33:20.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000.c	2018-04-02 14:15:39.000000000 +0800
@@ -85,6 +85,7 @@
 #if TARGET_MACHO
 #include "gstab.h"  /* for N_SLINE */
 #endif
+#include "tree-pass.h"	/* for current_pass */
 
 #ifndef TARGET_NO_PROTOTYPE
 #define TARGET_NO_PROTOTYPE 0
@@ -1081,6 +1082,7 @@
 static bool is_load_insn (rtx, rtx *);
 static bool is_store_insn (rtx, rtx *);
 static bool set_to_load_agen (rtx,rtx);
+static void rs6000_reorg (void);
 static bool insn_terminates_group_p (rtx , enum group_termination);
 static bool insn_must_be_first_in_group (rtx);
 static bool insn_must_be_last_in_group (rtx);
@@ -1384,6 +1386,8 @@
 #define TARGET_SCHED_REORDER rs6000_sched_reorder
 #undef TARGET_SCHED_REORDER2
 #define TARGET_SCHED_REORDER2 rs6000_sched_reorder2
+#undef TARGET_MACHINE_DEPENDENT_REORG
+#define TARGET_MACHINE_DEPENDENT_REORG rs6000_reorg
 
 #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
 #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD rs6000_use_sched_lookahead
@@ -1460,7 +1464,7 @@
 #undef TARGET_RTX_COSTS
 #define TARGET_RTX_COSTS rs6000_rtx_costs
 #undef TARGET_ADDRESS_COST
-#define TARGET_ADDRESS_COST hook_int_rtx_mode_as_bool_0
+#define TARGET_ADDRESS_COST rs6000_address_costs
 
 #undef TARGET_DWARF_REGISTER_SPAN
 #define TARGET_DWARF_REGISTER_SPAN rs6000_dwarf_register_span
@@ -1624,6 +1628,9 @@
 #undef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION rs6000_set_current_function
 
+#undef TARGET_CASE_VALUES_THRESHOLD
+#define TARGET_CASE_VALUES_THRESHOLD rs6000_case_values_threshold
+
 #undef TARGET_LEGITIMATE_CONSTANT_P
 #define TARGET_LEGITIMATE_CONSTANT_P rs6000_legitimate_constant_p
 
@@ -1649,6 +1656,7 @@
 #undef RS6000_CPU
 };
 
+
 /* Look up a processor name for -mcpu=xxx and -mtune=xxx.  Return -1 if the
    name is invalid.  */
 
@@ -3063,6 +3071,7 @@
 rs6000_builtin_mask_calculate (void)
 {
   return (((TARGET_ALTIVEC)		    ? RS6000_BTM_ALTIVEC   : 0)
+          | ((TARGET_ALTIVEC2)              ? RS6000_BTM_ALTIVEC2  : 0)
 	  | ((TARGET_VSX)		    ? RS6000_BTM_VSX	   : 0)
 	  | ((TARGET_SPE)		    ? RS6000_BTM_SPE	   : 0)
 	  | ((TARGET_PAIRED_FLOAT)	    ? RS6000_BTM_PAIRED	   : 0)
@@ -3072,6 +3081,7 @@
 	  | ((TARGET_FRSQRTES)		    ? RS6000_BTM_FRSQRTES  : 0)
 	  | ((TARGET_POPCNTD)		    ? RS6000_BTM_POPCNTD   : 0)
 	  | ((rs6000_cpu == PROCESSOR_CELL) ? RS6000_BTM_CELL      : 0)
+	  | ((TARGET_ISEL) 		    ? RS6000_BTM_ISEL      : 0)
 	  | ((TARGET_P8_VECTOR)		    ? RS6000_BTM_P8_VECTOR : 0)
 	  | ((TARGET_CRYPTO)		    ? RS6000_BTM_CRYPTO	   : 0)
 	  | ((TARGET_HTM)		    ? RS6000_BTM_HTM	   : 0)
@@ -3122,6 +3132,10 @@
       && !global_options_set.x_flag_ira_loop_pressure)
     flag_ira_loop_pressure = 1;
 
+  if (!global_options_set.x_TARGET_OPT_MEMSET_STORE &&
+      (flag_tree_loop_distribution || flag_tree_loop_distribute_patterns))
+    TARGET_OPT_MEMSET_STORE = 1;
+
   /* Set the pointer size.  */
   if (TARGET_64BIT)
     {
@@ -3501,6 +3515,19 @@
 	  || rs6000_cpu == PROCESSOR_PPCE6500))
     rs6000_block_move_inline_limit = 128;
 
+  /* Those machines does not have fsqrt instruction */
+  if (rs6000_cpu == PROCESSOR_PPCE5500
+      || rs6000_cpu == PROCESSOR_PPCE6500)
+    target_flags &= ~(MASK_PPC_GPOPT);
+
+  /* Those machines implements a slow mfocr opcode */
+  if (rs6000_cpu == PROCESSOR_PPCE5500)
+    target_flags &= ~MASK_MFCRF;
+
+  if (rs6000_cpu == PROCESSOR_PPCE5500)
+      target_flags &= ~MASK_MFCRF;
+
+
   /* store_one_arg depends on expand_block_move to handle at least the
      size of reg_parm_stack_space.  */
   if (rs6000_block_move_inline_limit < (TARGET_POWERPC64 ? 64 : 32))
@@ -4074,6 +4101,12 @@
   if (TARGET_LINK_STACK == -1)
     SET_TARGET_LINK_STACK (rs6000_cpu == PROCESSOR_PPC476 && flag_pic);
 
+  /* If the user has not specified -fuse-load-updates nor -fno-use-load-updates
+   * in 64-bit, default to -fuse-load-updates
+   */
+  if (flag_use_load_updates == -1 && TARGET_64BIT)
+    flag_use_load_updates = 1;
+
   return ret;
 }
 
@@ -5902,8 +5935,8 @@
       if (TREE_CODE (type) == ARRAY_TYPE
 	  && TYPE_MODE (TREE_TYPE (type)) == QImode)
 	{
-	  if (align < BITS_PER_WORD)
-	    align = BITS_PER_WORD;
+	  if (align < (TARGET_ALTIVEC ? 128 : BITS_PER_WORD))
+	    align = (TARGET_ALTIVEC ? 128 : BITS_PER_WORD);
 	}
     }
 
@@ -13031,6 +13064,12 @@
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvehx, exp);
     case ALTIVEC_BUILTIN_STVEWX:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvewx, exp);
+    case ALTIVEC_BUILTIN_STVEXBX:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvexbx, exp);
+    case ALTIVEC_BUILTIN_STVEXHX:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvexhx, exp);
+    case ALTIVEC_BUILTIN_STVEXWX:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvexwx, exp);
     case ALTIVEC_BUILTIN_STVXL_V2DF:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvxl_v2df, exp);
     case ALTIVEC_BUILTIN_STVXL_V2DI:
@@ -13053,6 +13092,18 @@
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvrx, exp);
     case ALTIVEC_BUILTIN_STVRXL:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvrxl, exp);
+    case ALTIVEC_BUILTIN_STVFLX:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvflx, exp);
+    case ALTIVEC_BUILTIN_STVFLXL:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvflxl, exp);
+    case ALTIVEC_BUILTIN_STVFRX:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvfrx, exp);
+    case ALTIVEC_BUILTIN_STVFRXL:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvfrxl, exp);
+    case ALTIVEC_BUILTIN_STVSWX:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvswx, exp);
+    case ALTIVEC_BUILTIN_STVSWXL:
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvswxl, exp);
 
     case VSX_BUILTIN_STXVD2X_V1TI:
       return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v1ti, exp);
@@ -13201,6 +13252,15 @@
     case ALTIVEC_BUILTIN_LVXL_V4SF:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl_v4sf,
 					exp, target, false);
+    case ALTIVEC_BUILTIN_LVEXBX:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvexbx,
+					exp, target, false);
+    case ALTIVEC_BUILTIN_LVEXHX:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvexhx,
+					exp, target, false);
+    case ALTIVEC_BUILTIN_LVEXWX:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvexwx,
+					exp, target, false);
     case ALTIVEC_BUILTIN_LVXL:
     case ALTIVEC_BUILTIN_LVXL_V4SI:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl_v4si,
@@ -13242,6 +13302,27 @@
     case ALTIVEC_BUILTIN_LVRXL:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvrxl,
 					exp, target, true);
+    case ALTIVEC_BUILTIN_LVTLX:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvtlx,
+                                        exp, target, true);
+    case ALTIVEC_BUILTIN_LVTLXL:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvtlxl,
+                                        exp, target, true);
+    case ALTIVEC_BUILTIN_LVTRX:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvtrx,
+                                        exp, target, true);
+    case ALTIVEC_BUILTIN_LVTRXL:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvtrxl,
+                                        exp, target, true);
+    case ALTIVEC_BUILTIN_LVSWX:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvswx,
+                                        exp, target, true);
+    case ALTIVEC_BUILTIN_LVSWXL:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvswxl,
+                                        exp, target, true);
+    case ALTIVEC_BUILTIN_LVSM:
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvsm,
+                                        exp, target, true);
     case VSX_BUILTIN_LXVD2X_V1TI:
       return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v1ti,
 					exp, target, false);
@@ -13738,11 +13819,296 @@
 	   " -mlong-double-128 options", name);
   else if ((fnmask & RS6000_BTM_HARD_FLOAT) != 0)
     error ("Builtin function %s requires the -mhard-float option", name);
+  else if ((fnmask & RS6000_BTM_ISEL) != 0)
+    error ("Builtin function %s requires the -misel option", name);
   else
     error ("Builtin function %s is not supported with the current options",
 	   name);
 }
 
+/* isel builtins are a bit funny, because we want the user to be able to do:
+ *
+ *    char *p, *q, *r;
+ *       int x, y, z;
+ *          unsigned int a, b, c;
+ *             ...
+ *                p = __builtin_iseleq (i, j, q, r);
+ *                   x = __builtin_iseleq (i, j, y, z);
+ *                      a = __builtin_iseleq (i, j, b, c);
+ *
+ *                         and, of course, i and j may be of several different types depending on the
+ *                            condition.
+ *
+ *                               We handle this by having generic builtins that
+ *                                  TARGET_RESOLVE_OVERLOADED_BUILTIN takes and turns into calls to our
+ *                                     specific builtins.  */
+
+/* Macros to help constructing the isel_builtin_desc arrays.
+ *    These closely mirror the macros in rs6000-builtins.def.  */
+/* HACK: Use VOIDmode here as a constant approximation to Pmode and fix
+ *    at runtime.  We can't use Pmode because in biarch its definition is
+ *       not constant.  */
+#define ISEL_Pmode VOIDmode
+#define ISEL_BASE(FLAGS, ARG, RESULT, PRED, CMP, MODE, RMODE)          \
+  { NULL, FLAGS, RS6000_BUILTIN_ISEL_##PRED##CMP##_##ARG##_##RESULT,   \
+      PRED, MODE, RMODE },
+#define ISEL_P_RESULT(FLAGS, ARG, PRED, CMP, MODE, RMODE)              \
+  ISEL_BASE (FLAGS | ISEL_FLAG_SEL_PTR, ARG, PP, PRED,         \
+            CMP, MODE, ISEL_Pmode)
+#define ISEL_S_RESULT(FLAGS, ARG, PRED, CMP, MODE, RMODE)              \
+  ISEL_BASE (FLAGS | ISEL_FLAG_SEL_SIGNED, ARG, SS, PRED,              \
+            CMP, MODE, RMODE)
+#define ISEL_U_RESULT(FLAGS, ARG, PRED, CMP, MODE, RMODE)              \
+  ISEL_BASE (FLAGS | ISEL_FLAG_SEL_UNSIGNED, ARG, UU, PRED,            \
+            CMP, MODE, RMODE)
+
+#define ISEL_EXPAND_ARG(FLAG, ARG, PRED, CMP, MODE, RMODE)             \
+  ISEL_P_RESULT (FLAG, ARG, PRED, CMP, MODE, RMODE)            \
+  ISEL_S_RESULT (FLAG, ARG, PRED, CMP, MODE, RMODE)            \
+  ISEL_U_RESULT (FLAG, ARG, PRED, CMP, MODE, RMODE)
+#define ISEL_PTR_ARG(PRED, CMP, MODE)                          \
+  ISEL_EXPAND_ARG (ISEL_FLAG_CMP_PTR, PP, PRED, CMP, ISEL_Pmode, MODE)
+#define ISEL_SIGNED_ARG(PRED, CMP, MODE)                       \
+  ISEL_EXPAND_ARG (ISEL_FLAG_CMP_SIGNED, SS, PRED, CMP, MODE, MODE)
+#define ISEL_UNSIGNED_ARG(PRED, CMP, MODE)                     \
+  ISEL_EXPAND_ARG (ISEL_FLAG_CMP_UNSIGNED, UU, PRED, CMP, MODE, MODE)
+
+#define ISEL_EQ(CMP, MODE)                                     \
+  ISEL_PTR_ARG (EQ, CMP, MODE)                                 \
+  ISEL_SIGNED_ARG (EQ, CMP, MODE)                              \
+  ISEL_UNSIGNED_ARG (EQ, CMP, MODE)
+#define ISEL_LT(CMP, MODE) ISEL_SIGNED_ARG (LT, CMP, MODE)
+#define ISEL_GT(CMP, MODE) ISEL_SIGNED_ARG (GT, CMP, MODE)
+#define ISEL_LTU(CMP, MODE)                                    \
+  ISEL_PTR_ARG (LTU, CMP, MODE)                                        \
+  ISEL_UNSIGNED_ARG (LTU, CMP, MODE)
+#define ISEL_GTU(CMP, MODE)                                    \
+  ISEL_PTR_ARG (GTU, CMP, MODE)                                        \
+  ISEL_UNSIGNED_ARG (GTU, CMP, MODE)
+
+const struct isel_builtin_desc builtin_iselw[32] = {
+  ISEL_EQ (CMPW, SImode)
+  ISEL_LT (CMPW, SImode)
+  ISEL_GT (CMPW, SImode)
+  ISEL_LTU (CMPW, SImode)
+  ISEL_GTU (CMPW, SImode)
+  { "__builtin_iseleq", 0, RS6000_BUILTIN_ISELEQ, EQ, SImode, SImode },
+  { "__builtin_isellt", 0, RS6000_BUILTIN_ISELLT, LT, SImode, SImode },
+  { "__builtin_iselgt", 0, RS6000_BUILTIN_ISELGT, GT, SImode, SImode },
+  { "__builtin_iselltu", 0, RS6000_BUILTIN_ISELLTU, LTU, SImode, SImode },
+  { "__builtin_iselgtu", 0, RS6000_BUILTIN_ISELGTU, GTU, SImode, SImode }
+};
+
+const struct isel_builtin_desc builtin_iseld[32] = {
+  ISEL_EQ (CMPD, DImode)
+  ISEL_LT (CMPD, DImode)
+  ISEL_GT (CMPD, DImode)
+  ISEL_LTU (CMPD, DImode)
+  ISEL_GTU (CMPD, DImode)
+  { "__builtin_isel64eq", 0, RS6000_BUILTIN_ISELEQD, EQ, DImode, DImode },
+  { "__builtin_isel64lt", 0, RS6000_BUILTIN_ISELLTD, LT, DImode, DImode },
+  { "__builtin_isel64gt", 0, RS6000_BUILTIN_ISELGTD, GT, DImode, DImode },
+  { "__builtin_isel64ltu", 0, RS6000_BUILTIN_ISELLTDU, LTU, DImode, DImode },
+  { "__builtin_isel64gtu", 0, RS6000_BUILTIN_ISELGTDU, GTU, DImode, DImode }
+};
+
+/* Return the mode which DESC uses for comparisons.  */
+
+static enum machine_mode
+isel_cmp_mode (const struct isel_builtin_desc *desc)
+{
+  enum machine_mode mode = (enum machine_mode) desc->cmp_mode;
+
+  return (mode == VOIDmode ? Pmode : mode);
+}
+
+/* Return the mode in which DESC selects arguments.  */
+
+static enum machine_mode
+isel_sel_mode (const struct isel_builtin_desc *desc)
+{
+  enum machine_mode mode = (enum machine_mode) desc->sel_mode;
+
+  return (mode == VOIDmode ? Pmode : mode);
+}
+
+/* Return a tree describing the arguments for DESC according to CMPP:
+ *    true for comparison arguments, false for select arguments.  */
+
+static tree
+isel_argtype (const struct isel_builtin_desc *desc, bool cmpp)
+{
+  switch (desc->arg_flags & (cmpp
+                            ? ISEL_FLAG_CMP_MASK
+                            : ISEL_FLAG_SEL_MASK))
+    {
+    case ISEL_FLAG_CMP_PTR:
+    case ISEL_FLAG_SEL_PTR:
+      return ptr_type_node;
+    case ISEL_FLAG_CMP_SIGNED:
+      return (isel_cmp_mode (desc) == SImode
+             ? integer_type_node
+             : long_integer_type_node);
+    case ISEL_FLAG_SEL_SIGNED:
+      return (isel_sel_mode (desc) == SImode
+             ? integer_type_node
+             : long_integer_type_node);
+    case ISEL_FLAG_CMP_UNSIGNED:
+      return (isel_cmp_mode (desc) == SImode
+             ? unsigned_type_node
+             : long_unsigned_type_node);
+    case ISEL_FLAG_SEL_UNSIGNED:
+    default:
+      return (isel_sel_mode (desc) == SImode
+             ? unsigned_type_node
+             : long_unsigned_type_node);
+    }
+}
+
+/* Return a mnemonic string describing the argument or result of FLAGS
+ *    depending on CMPP.  */
+
+static const char *
+isel_strdesc (int flags, bool cmpp)
+{
+  switch (flags & (cmpp ? ISEL_FLAG_CMP_MASK : ISEL_FLAG_SEL_MASK))
+    {
+    case ISEL_FLAG_CMP_PTR:
+    case ISEL_FLAG_SEL_PTR:
+      return "p";
+    case ISEL_FLAG_CMP_SIGNED:
+    case ISEL_FLAG_SEL_SIGNED:
+      return "s";
+    case ISEL_FLAG_CMP_UNSIGNED:
+    case ISEL_FLAG_SEL_UNSIGNED:
+      return "u";
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Initialize N_DESC isel builtins from DESC.  SIGNED_TYPE holds the
+ *    basic type for signed variants of isel, UNSIGNED_TYPE the type for
+ *       unsigned variants.  */
+
+static void
+rs6000_init_isel_builtins (const struct isel_builtin_desc *desc, int n_descs)
+{
+  int i;
+  const char *is64 = (desc == &builtin_iselw[0] ? "32" : "64");
+
+  for (i = 0; i < n_descs; i++)
+    {
+      const struct isel_builtin_desc *d = &desc[i];
+      tree cmptype, seltype, ftype;
+
+      cmptype = isel_argtype (d, true);
+      seltype = isel_argtype (d, false);
+
+      ftype = build_function_type_list (seltype, cmptype, cmptype,
+                                       seltype, seltype, NULL_TREE);
+
+      if (d->name)
+       def_builtin (d->name, ftype, d->code);
+      else
+       {
+         char builtin_name[40];
+
+         sprintf (builtin_name, "__builtin_isel%s%s%s%s%s%s",
+                  is64,
+                  GET_RTX_NAME (d->cmp_code),
+                  GET_MODE_NAME (isel_cmp_mode (d)),
+                  isel_strdesc (d->arg_flags, true),
+                  isel_strdesc (d->arg_flags, false),
+                  GET_MODE_NAME (isel_sel_mode (d)));
+
+         def_builtin (ggc_strdup (builtin_name), ftype, d->code);
+       }
+    }
+}
+
+static rtx
+rs6000_expand_isel_builtin (const struct isel_builtin_desc *desc,
+                           int n_descs, tree exp, rtx target, int fcode)
+{
+  int i;
+
+  for (i = 0; i < n_descs; i++)
+    {
+      const struct isel_builtin_desc *d = &desc[i];
+
+      if (fcode == (int) d->code)
+       {
+         int opidx;
+         unsigned int j;
+         rtx cmp;
+         rtx operands[4];
+         enum insn_code icode;
+         enum machine_mode opmode;
+         enum machine_mode cmpmode = isel_cmp_mode (d);
+         enum machine_mode selmode = isel_sel_mode (d);
+
+         /* Determine underlying isel insn.  */
+         switch (d->cmp_code)
+           {
+           case GTU:
+           case LTU:
+             icode = (Pmode == SImode
+                      ? CODE_FOR_isel_unsigned_si
+                      : CODE_FOR_isel_unsigned_di);
+             break;
+           default:
+             icode = (Pmode == SImode
+                      ? CODE_FOR_isel_signed_si
+                      : CODE_FOR_isel_signed_di);
+             break;
+           }
+
+         for (j = 0; j < ARRAY_SIZE (operands); j++)
+           {
+             tree arg = CALL_EXPR_ARG (exp, j);
+
+             /* If we got invalid arguments, bail out before generating
+ *                 bad rtl.  */
+             if (arg == error_mark_node)
+               return const0_rtx;
+
+             operands[j] = expand_normal (arg);
+
+             /* Validate.  */
+             /* HACK: The isel pattern doesn't actually consume all the
+                operands to the builtin; it only consumes 2 and 3.  The
+                other two will be handed off to a compare
+                insn. Unfortunately, said insn is not named, so we
+                can't directly access its insn_data here.  Fake it by
+                validating operands 0 and 1 with the isel pattern; that
+                should be good enough.  */
+             opidx = (j < 2 ? 2 : j);
+             opmode = (j < 2 ? cmpmode : selmode);
+             if (! (*insn_data[icode].operand[opidx].predicate) (operands[j],
+                                                                 opmode))
+               operands[j] = copy_to_mode_reg (opmode, operands[j]);
+           }
+
+         /* Validate target.  */
+         if (target == NULL_RTX
+             || GET_MODE (target) != selmode
+             || ! (*insn_data[icode].operand[0].predicate) (target, selmode))
+           target = gen_reg_rtx (selmode);
+
+         /* Generate comparison.  */
+         cmp = gen_rtx_fmt_ee ((enum rtx_code)d->cmp_code, cmpmode,
+                               operands[0], operands[1]);
+
+         rs6000_emit_int_cmove (target, cmp, operands[2], operands[3]);
+
+         return target;
+       }
+    }
+
+  return NULL_RTX;
+}
+
 /* Expand an expression EXP that calls a built-in function,
    with result going to TARGET if that's convenient
    (and in mode MODE if that's convenient).
@@ -13896,6 +14262,24 @@
       break;
     }
 
+  if (TARGET_ISEL)
+    {
+      ret = rs6000_expand_isel_builtin (builtin_iselw,
+                                       ARRAY_SIZE (builtin_iselw),
+                                       exp, target, fcode);
+
+      if (ret != NULL_RTX)
+       return ret;
+    }
+  if (TARGET_ISEL64)
+    {
+      ret = rs6000_expand_isel_builtin (builtin_iseld,
+                                       ARRAY_SIZE (builtin_iseld),
+                                       exp, target, fcode);
+
+      if (ret != NULL_RTX)
+       return ret;
+    }
   if (TARGET_ALTIVEC)
     {
       ret = altivec_expand_builtin (exp, target, &success);
@@ -14154,6 +14538,10 @@
     paired_init_builtins ();
   if (TARGET_SPE)
     spe_init_builtins ();
+  if (TARGET_ISEL)
+    rs6000_init_isel_builtins (builtin_iselw, ARRAY_SIZE (builtin_iselw));
+  if (TARGET_ISEL64)
+    rs6000_init_isel_builtins (builtin_iseld, ARRAY_SIZE (builtin_iseld));
   if (TARGET_EXTRA_BUILTINS)
     altivec_init_builtins ();
   if (TARGET_HTM)
@@ -14624,6 +15012,9 @@
   def_builtin ("__builtin_altivec_lvebx", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEBX);
   def_builtin ("__builtin_altivec_lvehx", v8hi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEHX);
   def_builtin ("__builtin_altivec_lvewx", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEWX);
+  def_builtin ("__builtin_altivec_lvexbx", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEXBX);
+  def_builtin ("__builtin_altivec_lvexhx", v8hi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEXHX);
+  def_builtin ("__builtin_altivec_lvexwx", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEXWX);
   def_builtin ("__builtin_altivec_lvxl", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVXL);
   def_builtin ("__builtin_altivec_lvxl_v2df", v2df_ftype_long_pcvoid,
 	       ALTIVEC_BUILTIN_LVXL_V2DF);
@@ -14679,6 +15070,9 @@
 	       ALTIVEC_BUILTIN_STVXL_V16QI);
   def_builtin ("__builtin_altivec_stvebx", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVEBX);
   def_builtin ("__builtin_altivec_stvehx", void_ftype_v8hi_long_pvoid, ALTIVEC_BUILTIN_STVEHX);
+  def_builtin ("__builtin_altivec_stvexbx", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVEXBX);
+  def_builtin ("__builtin_altivec_stvexhx", void_ftype_v8hi_long_pvoid, ALTIVEC_BUILTIN_STVEXHX);
+  def_builtin ("__builtin_altivec_stvexwx", void_ftype_v4si_long_pvoid, ALTIVEC_BUILTIN_STVEXWX);
   def_builtin ("__builtin_vec_ld", opaque_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LD);
   def_builtin ("__builtin_vec_lde", opaque_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LDE);
   def_builtin ("__builtin_vec_ldl", opaque_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LDL);
@@ -14687,12 +15081,18 @@
   def_builtin ("__builtin_vec_lvebx", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEBX);
   def_builtin ("__builtin_vec_lvehx", v8hi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEHX);
   def_builtin ("__builtin_vec_lvewx", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEWX);
+  def_builtin ("__builtin_vec_lvexbx", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEXBX);
+  def_builtin ("__builtin_vec_lvexhx", v8hi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEXHX);
+  def_builtin ("__builtin_vec_lvexwx", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEXWX);
   def_builtin ("__builtin_vec_st", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_ST);
   def_builtin ("__builtin_vec_ste", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STE);
   def_builtin ("__builtin_vec_stl", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STL);
   def_builtin ("__builtin_vec_stvewx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEWX);
   def_builtin ("__builtin_vec_stvebx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEBX);
   def_builtin ("__builtin_vec_stvehx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEHX);
+  def_builtin ("__builtin_vec_stvexwx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEXWX);
+  def_builtin ("__builtin_vec_stvexbx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEXBX);
+  def_builtin ("__builtin_vec_stvexhx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEXHX);
 
   def_builtin ("__builtin_vsx_lxvd2x_v2df", v2df_ftype_long_pcvoid,
 	       VSX_BUILTIN_LXVD2X_V2DF);
@@ -14723,6 +15123,40 @@
   def_builtin ("__builtin_vec_vsx_st", void_ftype_opaque_long_pvoid,
 	       VSX_BUILTIN_VEC_ST);
 
+  /* Power ISA 2.07 */
+  def_builtin ("__builtin_altivec_lvtlx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVTLX);
+  def_builtin ("__builtin_altivec_lvtlxl", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVTLXL);
+  def_builtin ("__builtin_altivec_lvtrx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVTRX);
+  def_builtin ("__builtin_altivec_lvtrxl", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVTRXL);
+
+  def_builtin ("__builtin_vec_lvtlx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVTLX);
+  def_builtin ("__builtin_vec_lvtlxl", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVTLXL);
+  def_builtin ("__builtin_vec_lvtrx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVTRX);
+  def_builtin ("__builtin_vec_lvtrxl", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVTRXL);
+
+  def_builtin ("__builtin_altivec_stvflx",  void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVFLX);
+  def_builtin ("__builtin_altivec_stvflxl", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVFLXL);
+  def_builtin ("__builtin_altivec_stvfrx",  void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVFRX);
+  def_builtin ("__builtin_altivec_stvfrxl", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVFRXL);
+
+  def_builtin ("__builtin_vec_stvflx",  void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVFLX);
+  def_builtin ("__builtin_vec_stvflxl", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVFLXL);
+  def_builtin ("__builtin_vec_stvfrx",  void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVFRX);
+  def_builtin ("__builtin_vec_stvfrxl", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVFRXL);
+
+  def_builtin ("__builtin_altivec_lvswx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVSWX);
+  def_builtin ("__builtin_altivec_lvswxl", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVSWXL);
+  def_builtin ("__builtin_vec_lvswx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVSWX);
+  def_builtin ("__builtin_vec_lvswxl", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVSWXL);
+
+  def_builtin ("__builtin_altivec_lvsm",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVSM);
+  def_builtin ("__builtin_vec_lvsm",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVSM);
+
+  def_builtin ("__builtin_altivec_stvswx",  void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVSWX);
+  def_builtin ("__builtin_altivec_stvswxl", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_STVSWXL);
+  def_builtin ("__builtin_vec_stvswx",  void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVSWX);
+  def_builtin ("__builtin_vec_stvswxl", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVSWXL);
+
   def_builtin ("__builtin_vec_step", int_ftype_opaque, ALTIVEC_BUILTIN_VEC_STEP);
   def_builtin ("__builtin_vec_splats", opaque_ftype_opaque, ALTIVEC_BUILTIN_VEC_SPLATS);
   def_builtin ("__builtin_vec_promote", opaque_ftype_opaque, ALTIVEC_BUILTIN_VEC_PROMOTE);
@@ -15142,6 +15576,9 @@
     case ALTIVEC_BUILTIN_VMULEUH_UNS:
     case ALTIVEC_BUILTIN_VMULOUB_UNS:
     case ALTIVEC_BUILTIN_VMULOUH_UNS:
+    case ALTIVEC_BUILTIN_VABSDUB:
+    case ALTIVEC_BUILTIN_VABSDUH:
+    case ALTIVEC_BUILTIN_VABSDUW:
     case CRYPTO_BUILTIN_VCIPHER:
     case CRYPTO_BUILTIN_VCIPHERLAST:
     case CRYPTO_BUILTIN_VNCIPHER:
@@ -15628,7 +16065,64 @@
 
   if (optimize_size && bytes > 3 * clear_step)
     return 0;
-  if (! optimize_size && bytes > 8 * clear_step)
+
+  if (TARGET_OPT_MEMSET_STORE && !optimize_size)
+    {
+      if (rs6000_cpu == PROCESSOR_PPCE500MC)
+        {
+          /* Based on comparison of performance data between generating sequence
+             of store instructions and 'memset' call,'memset' executes faster if
+             the no of bytes is > 136.
+             An Upper bound limit has been set for the generation of store
+             instructions to prevent stack overflow due to code bloat.  */
+          if (bytes > (rs6000_max_block_clear ?
+             ((rs6000_max_block_clear > 256) ? 256 : rs6000_max_block_clear)  : 136))
+            return 0;
+        }
+      else if ((rs6000_cpu == PROCESSOR_PPC8540) && align >= 64)
+        {
+          /* Based on comparison of performance data between generating sequence
+             of store instructions (vector) and 'memset' call,'memset' executes faster if
+             the no of bytes is > 172.
+             An Upper bound limit has been set for the generation of store
+             instructions to prevent stack overflow due to code bloat.  */
+          if (bytes > (rs6000_max_block_clear ?
+             ((rs6000_max_block_clear > 256) ? 256 : rs6000_max_block_clear)  : 172))
+            return 0;
+        }
+      else if ((rs6000_cpu == PROCESSOR_PPCE5500 ||
+                rs6000_cpu == PROCESSOR_PPCE6500 ||
+                rs6000_cpu == PROCESSOR_PPCE500MC64) &&  TARGET_32BIT)
+        {
+          /* Based on comparison of performance data between generating sequence
+             of store instructions and 'memset' call,'memset' executes faster if
+             the no of bytes is > 120.
+             An Upper bound limit has been set for the generation of store
+             instructions to prevent stack overflow due to code bloat.  */
+          if (bytes > (rs6000_max_block_clear ?
+             ((rs6000_max_block_clear > 256) ? 256 : rs6000_max_block_clear)  : 120))
+            return 0;
+        }
+      else if ((rs6000_cpu == PROCESSOR_PPCE5500 ||
+                rs6000_cpu == PROCESSOR_PPCE6500 ||
+                rs6000_cpu == PROCESSOR_PPCE500MC64) &&  TARGET_64BIT)
+        {
+          /* Based on comparison of performance data between generating sequence
+             of store instructions and 'memset' call,'memset' executes faster if
+             the no of bytes is > 248.
+             An Upper bound limit has been set for the generation of store
+             instructions to prevent stack overflow due to code bloat.  */
+          if (bytes > (rs6000_max_block_clear ?
+             ((rs6000_max_block_clear > 512) ? 512 : rs6000_max_block_clear)  : 248))
+            return 0;
+        }
+          /* An Upper bound limit has been set for the generation of store
+             instructions to prevent stack overflow due to code bloat.  */
+      else if (bytes > (rs6000_max_block_clear ?
+              ((rs6000_max_block_clear > 256) ? 256 : rs6000_max_block_clear) : 8 * clear_step))
+        return 0;
+    }
+  else if (! optimize_size && bytes > 8 * clear_step)
     return 0;
 
   for (offset = 0; bytes > 0; offset += clear_bytes, bytes -= clear_bytes)
@@ -15649,7 +16143,9 @@
       else if (bytes >= 8 && TARGET_POWERPC64
 	       /* 64-bit loads and stores require word-aligned
 		  displacements.  */
-	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)))
+	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)
+		   || rs6000_cpu == PROCESSOR_PPCE5500
+		   || rs6000_cpu == PROCESSOR_PPCE6500))
 	{
 	  clear_bytes = 8;
 	  mode = DImode;
@@ -15782,7 +16278,9 @@
       else if (bytes >= 8 && TARGET_POWERPC64
 	       /* 64-bit loads and stores require word-aligned
 		  displacements.  */
-	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)))
+	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)
+		   || rs6000_cpu == PROCESSOR_PPCE5500
+		   || rs6000_cpu == PROCESSOR_PPCE6500))
 	{
 	  move_bytes = 8;
 	  mode = DImode;
@@ -15799,6 +16297,14 @@
 	  mode = SImode;
 	  gen_func.mov = gen_movsi;
 	}
+      else if (TARGET_COPY_UNALIGNED && bytes == 3 && offset > 0)
+	{
+	  /* We generate a single unaligned SI move instead of 2 (HI, QI) */
+	  move_bytes = 3;
+	  mode = SImode;
+	  gen_func.mov = gen_movsi;
+	  offset--;
+	}
       else if (bytes >= 2 && (align >= 16 || !STRICT_ALIGNMENT))
 	{			/* move 2 bytes */
 	  move_bytes = 2;
@@ -16932,12 +17438,11 @@
 
       if (legitimate_indirect_address_p (addr, false)	/* reg */
 	  || legitimate_indexed_address_p (addr, false)	/* reg+reg */
+	  || GET_CODE (addr) == PRE_MODIFY		/* VSX pre-modify */
 	  || (GET_CODE (addr) == AND			/* Altivec memory */
-	      && rclass == ALTIVEC_REGS
 	      && GET_CODE (XEXP (addr, 1)) == CONST_INT
 	      && INTVAL (XEXP (addr, 1)) == -16
-	      && (legitimate_indirect_address_p (XEXP (addr, 0), false)
-		  || legitimate_indexed_address_p (XEXP (addr, 0), false))))
+	      && VECTOR_MEM_ALTIVEC_P (mode)))
 	;
 
       else if (GET_CODE (addr) == PLUS)
@@ -26505,6 +27010,19 @@
             break;
           }
 
+      if ((rs6000_cpu == CPU_PPCE500MC
+          || rs6000_cpu_attr == CPU_PPCE500MC64
+          || rs6000_cpu_attr == CPU_PPCE5500
+          || rs6000_cpu_attr == CPU_PPCE6500)
+          && recog_memoized (dep_insn)
+          && (INSN_CODE (dep_insn) >= 0)
+          && (GET_CODE (PATTERN (insn)) == SET)
+          && (GET_CODE (PATTERN (dep_insn)) == SET) 
+          && (get_attr_type (insn) == TYPE_CMP)
+          && (get_attr_type (dep_insn) == TYPE_LOAD)
+          && (GET_CODE (XEXP (PATTERN (dep_insn), 1)) == MEM)
+          && legitimate_indexed_address_p (XEXP((XEXP (PATTERN (dep_insn), 1)),0), false))
+        return cost + 3;
 	/* Fall out to return default cost.  */
       }
       break;
@@ -27362,6 +27880,122 @@
   return cached_can_issue_more;
 }
 
+/* Implement TARGET_MACHINE_DEPENDENT_REORG.  */
+
+void
+remove_redundant_mov (void)
+{
+ basic_block bb;
+ rtx insn0,insn1,insn2,insn3;
+ rtx x,pat,pat0;
+ rtx operands[15];
+ 
+ FOR_EACH_BB_FN (bb, cfun)
+ {
+   FOR_BB_INSNS (bb,insn0)
+   {
+    insn1 = insn0;
+    if(insn1 == 0 )continue;
+    if (LABEL_P (insn1)
+       || BARRIER_P (insn1))insn1 = NEXT_INSN(insn1);
+    if(insn1 == 0)continue;
+
+    if (NEXT_INSN (insn1)
+       && BARRIER_P (NEXT_INSN (insn1)))continue;
+
+    while (NOTE_P (insn1)
+          || (NONJUMP_INSN_P (insn1)
+              && (GET_CODE (PATTERN (insn1)) == USE
+                 || GET_CODE (PATTERN (insn1)) == CLOBBER)))
+    {
+    	insn1 = NEXT_INSN (insn1);
+        if(insn1 == 0)break;
+    }
+    if(insn1 == 0)continue;
+
+    if (LABEL_P (insn1)
+      || BARRIER_P (insn1))continue;
+
+    pat = PATTERN (insn1);
+    x = pat0 = pat;
+    if (GET_CODE (x) != SET)continue;
+    x = XEXP (pat,0);
+    operands[0] = x;
+    if (! TARGET_POWERPC64)
+    {
+     if (! gpc_reg_operand (x, SImode))continue;
+    }
+    else
+    {
+     if (! gpc_reg_operand (x, DImode))continue;
+    } 
+    x = XEXP (XEXP (pat, 1), 0);
+    operands[1] = x;
+    insn2 = insn1;
+    do { insn2 = NEXT_INSN (insn2);
+       if (insn2 == 0) break; }
+    while (NOTE_P (insn2)
+         || (NONJUMP_INSN_P (insn2)
+             && (GET_CODE (PATTERN (insn2)) == USE
+                 || GET_CODE (PATTERN (insn2)) == CLOBBER)));
+    if(insn2 == 0)continue;
+    if (LABEL_P (insn2)
+        || BARRIER_P (insn2))continue;
+    pat = PATTERN (insn2);
+    x = pat;
+    if (GET_CODE (x) != SET)continue;
+    x = XEXP (pat, 0);
+    operands[3] = x;
+    if (! TARGET_POWERPC64)
+    {
+       if (! gpc_reg_operand (x, SImode))continue;
+    }
+    else
+    {
+       if (! gpc_reg_operand (x, DImode))continue;
+    }
+    x = XEXP (pat, 1);
+    if (!rtx_equal_p (operands[0], x))continue;
+    insn3 = insn2;
+    do { insn3 = NEXT_INSN (insn3);
+       if (insn3 == 0) break; }
+    while (NOTE_P (insn3)
+         || (NONJUMP_INSN_P (insn3)
+             && (GET_CODE (PATTERN (insn3)) == USE
+                 || GET_CODE (PATTERN (insn3)) == CLOBBER)));
+    if(insn3 == 0)continue;
+    if (LABEL_P (insn3)
+        || BARRIER_P (insn3))continue;
+    pat = PATTERN (insn3);
+    x = pat;
+    if (GET_CODE (x) != RETURN)continue;
+    if ((REGNO(operands[3]) == 3))
+    {
+      rtx ret_reg;
+      int insn_code_number;
+      
+      ret_reg = copy_rtx (operands[3]);
+      XEXP(pat0,0) = ret_reg;
+      insn_code_number = recog_memoized (insn1);
+      cleanup_subreg_operands (insn1);
+      if (! constrain_operands_cached (1))
+      {
+       /*operands does ot match to their constraints.so revert changes to insn*/
+        XEXP(pat0,0) = operands[0];
+      }
+      else
+        delete_insn (insn2);
+    }
+   }
+  }
+}
+
+static void
+rs6000_reorg (void)
+{
+  remove_redundant_mov ();
+}
+
 /* Return whether the presence of INSN causes a dispatch group termination
    of group WHICH_GROUP.
 
@@ -29899,6 +30533,29 @@
   return ret;
 }
 
+/* Address cost calculation.
+ * FIXME: Handle all addressing types */
+
+static int
+rs6000_address_costs (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,
+		   addr_space_t as ATTRIBUTE_UNUSED,
+		   bool speed ATTRIBUTE_UNUSED)
+{
+  if (toc_relative_expr_p (x, false))
+    {
+      rtx temp = XVECEXP (tocrel_base, 0, 0);
+      if (GET_CODE (temp) != SYMBOL_REF)
+        return 0;
+      return 5;
+    }
+  if (!strcmp (current_pass->name, "loop2_invariant")
+      && (GET_CODE (x) == LO_SUM)
+      && GET_CODE (XEXP (x, 1)) == SYMBOL_REF)
+    return 5;
+
+  return 0; 
+}
+
 /* Debug form of ADDRESS_COST that is selected if -mdebug=cost.  */
 
 static int
@@ -31304,6 +31961,22 @@
   return regno;
 }
 
+/* While mapping gcc register numbers to DWARF2 register numbers, 
+ * we digress a bit from the standard ABI.
+ * http://gcc.gnu.org/ml/gcc-patches/2012-11/msg02136.html
+ *
+ * The above change is handled by GDB, but CodeWarrior PowerPC debugger
+ * stricity follows the ABI especially while mapping the vector registers */
+
+unsigned int
+rs6000_fsl_dbx_register_number (unsigned int regno)
+{
+  if (global_options_set.x_rs6000_map_dwarf_vec_reg)
+    return rs6000_dbx_register_number (regno);
+
+  return regno;
+}
+
 /* target hook eh_return_filter_mode */
 static enum machine_mode
 rs6000_eh_return_filter_mode (void)
@@ -31418,6 +32091,7 @@
 static struct rs6000_opt_mask const rs6000_opt_masks[] =
 {
   { "altivec",			OPTION_MASK_ALTIVEC,		false, true  },
+  { "altivec2",			OPTION_MASK_ALTIVEC2,		false, true  },
   { "cmpb",			OPTION_MASK_CMPB,		false, true  },
   { "crypto",			OPTION_MASK_CRYPTO,		false, true  },
   { "direct-move",		OPTION_MASK_DIRECT_MOVE,	false, true  },
@@ -31476,6 +32150,7 @@
 static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =
 {
   { "altivec",		 RS6000_BTM_ALTIVEC,	false, false },
+  { "altivec2",		 RS6000_BTM_ALTIVEC2,	false, false },
   { "vsx",		 RS6000_BTM_VSX,	false, false },
   { "spe",		 RS6000_BTM_SPE,	false, false },
   { "paired",		 RS6000_BTM_PAIRED,	false, false },
@@ -31485,6 +32160,7 @@
   { "frsqrtes",		 RS6000_BTM_FRSQRTES,	false, false },
   { "popcntd",		 RS6000_BTM_POPCNTD,	false, false },
   { "cell",		 RS6000_BTM_CELL,	false, false },
+  { "isel",              RS6000_BTM_ISEL,       false, false },
   { "power8-vector",	 RS6000_BTM_P8_VECTOR,	false, false },
   { "crypto",		 RS6000_BTM_CRYPTO,	false, false },
   { "htm",		 RS6000_BTM_HTM,	false, false },
@@ -31968,6 +32644,21 @@
     }
 }
 
+/* Implement `CASE_VALUES_THRESHOLD'.  */
+/* Supply the default for --param case-values-threshold=0  */
+
+static unsigned int
+rs6000_case_values_threshold (void)
+{
+  if (rs6000_cpu == PROCESSOR_PPC8540
+      || rs6000_cpu == PROCESSOR_PPCE500MC
+      || rs6000_cpu == PROCESSOR_PPCE5500
+      || rs6000_cpu == PROCESSOR_PPCE6500)
+    return 8;
+
+  return 4;
+}
+
 
 /* Save the current options */
 
@@ -33090,3 +33781,20 @@
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-rs6000.h"
+
+bool
+rs6000_bypass_load_on_store_collision_p (rtx out_insn, rtx in_insn)
+{
+  /* The out_insn is a store and the in_insn is a load */
+  if (flag_bypass_load_on_store &&
+      (GET_CODE (PATTERN (out_insn)) == SET &&
+       GET_CODE (SET_DEST (PATTERN (out_insn))) == MEM &&
+       GET_CODE (SET_SRC (PATTERN (out_insn))) == REG) &&
+      (GET_CODE (PATTERN (in_insn)) == SET &&
+       GET_CODE (SET_DEST (PATTERN (in_insn))) == REG &&
+       GET_CODE (SET_SRC (PATTERN (in_insn))) == MEM))
+    return rtx_equal_p (SET_DEST (PATTERN (out_insn)),
+                        SET_SRC  (PATTERN (in_insn)));
+  else
+    return false;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000-c.c test/gcc-4.9.2/gcc/config/rs6000/rs6000-c.c
--- gcc-4.9.2/gcc/config/rs6000/rs6000-c.c	2014-10-13 10:33:20.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000-c.c	2018-04-02 14:15:33.000000000 +0800
@@ -322,17 +322,17 @@
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PPCGR");
   if ((flags & OPTION_MASK_POWERPC64) != 0)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PPC64");
-  if ((flags & OPTION_MASK_MFCRF) != 0)
+  if ((flags & OPTION_MASK_MFCRF) != 0 && rs6000_cpu != PROCESSOR_PPCE6500)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR4");
-  if ((flags & OPTION_MASK_POPCNTB) != 0)
+  if ((flags & OPTION_MASK_POPCNTB) != 0 && rs6000_cpu != PROCESSOR_PPCE5500 && rs6000_cpu != PROCESSOR_PPCE6500)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR5");
   if ((flags & OPTION_MASK_FPRND) != 0)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR5X");
-  if ((flags & OPTION_MASK_CMPB) != 0)
+  if ((flags & OPTION_MASK_CMPB) != 0 && rs6000_cpu != PROCESSOR_PPCE5500 && rs6000_cpu != PROCESSOR_PPCE6500)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR6");
   if ((flags & OPTION_MASK_MFPGPR) != 0)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR6X");
-  if ((flags & OPTION_MASK_POPCNTD) != 0)
+  if ((flags & OPTION_MASK_POPCNTD) != 0 && rs6000_cpu != PROCESSOR_PPCE5500 && rs6000_cpu != PROCESSOR_PPCE6500)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR7");
   if ((flags & OPTION_MASK_DIRECT_MOVE) != 0)
     rs6000_define_or_undefine_macro (define_p, "_ARCH_PWR8");
@@ -350,6 +350,8 @@
       if (!flag_iso)
 	rs6000_define_or_undefine_macro (define_p, "__APPLE_ALTIVEC__");
     }
+  if ((flags & OPTION_MASK_ALTIVEC2) != 0)
+    rs6000_define_or_undefine_macro (define_p, "__ALTIVEC2__");
   if ((flags & OPTION_MASK_VSX) != 0)
     rs6000_define_or_undefine_macro (define_p, "__VSX__");
   if ((flags & OPTION_MASK_HTM) != 0)
@@ -671,6 +673,24 @@
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V16QI, 0, 0 },
 
   /* Binary AltiVec/VSX builtins.  */
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUB,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUH,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ABSD, ALTIVEC_BUILTIN_VABSDUW,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_ADD, ALTIVEC_BUILTIN_VADDUBM,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_ADD, ALTIVEC_BUILTIN_VADDUBM,
@@ -1215,6 +1235,24 @@
     RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_LVEBX, ALTIVEC_BUILTIN_LVEBX,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXWX, ALTIVEC_BUILTIN_LVEXWX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXWX, ALTIVEC_BUILTIN_LVEXWX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXWX, ALTIVEC_BUILTIN_LVEXWX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXWX, ALTIVEC_BUILTIN_LVEXWX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXWX, ALTIVEC_BUILTIN_LVEXWX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXHX, ALTIVEC_BUILTIN_LVEXHX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXHX, ALTIVEC_BUILTIN_LVEXHX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXBX, ALTIVEC_BUILTIN_LVEXBX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVEXBX, ALTIVEC_BUILTIN_LVEXBX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL_V4SF,
@@ -1467,6 +1505,258 @@
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_LVRXL, ALTIVEC_BUILTIN_LVRXL,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLX, ALTIVEC_BUILTIN_LVTLX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTLXL, ALTIVEC_BUILTIN_LVTLXL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRX, ALTIVEC_BUILTIN_LVTRX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVTRXL, ALTIVEC_BUILTIN_LVTRXL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWX, ALTIVEC_BUILTIN_LVSWX,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSWXL, ALTIVEC_BUILTIN_LVSWXL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSM, ALTIVEC_BUILTIN_LVSM,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_MAX, ALTIVEC_BUILTIN_VMAXUB,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_MAX, ALTIVEC_BUILTIN_VMAXUB,
@@ -3012,6 +3302,46 @@
     RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
   { ALTIVEC_BUILTIN_VEC_STVEBX, ALTIVEC_BUILTIN_STVEBX,
     RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXWX, ALTIVEC_BUILTIN_STVEXWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXHX, ALTIVEC_BUILTIN_STVEXHX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVEXHX, ALTIVEC_BUILTIN_STVEXHX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVEXHX, ALTIVEC_BUILTIN_STVEXHX,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVEXHX, ALTIVEC_BUILTIN_STVEXHX,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVEXHX, ALTIVEC_BUILTIN_STVEXHX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXHX, ALTIVEC_BUILTIN_STVEXHX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXBX, ALTIVEC_BUILTIN_STVEXBX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVEXBX, ALTIVEC_BUILTIN_STVEXBX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVEXBX, ALTIVEC_BUILTIN_STVEXBX,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVEXBX, ALTIVEC_BUILTIN_STVEXBX,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVEXBX, ALTIVEC_BUILTIN_STVEXBX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
+  { ALTIVEC_BUILTIN_VEC_STVEXBX, ALTIVEC_BUILTIN_STVEXBX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_void },
   { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL_V4SF,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL_V4SF,
@@ -3216,6 +3546,222 @@
     RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_STVRXL, ALTIVEC_BUILTIN_STVRXL,
     RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFLX, ALTIVEC_BUILTIN_STVFLX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFLXL, ALTIVEC_BUILTIN_STVFLXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFRX, ALTIVEC_BUILTIN_STVFRX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVFRXL, ALTIVEC_BUILTIN_STVFRXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVSWX, ALTIVEC_BUILTIN_STVSWX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V4SI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_STVSWXL, ALTIVEC_BUILTIN_STVSWXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },
   { VSX_BUILTIN_VEC_XXSLDWI, VSX_BUILTIN_XXSLDWI_16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_NOT_OPAQUE },
   { VSX_BUILTIN_VEC_XXSLDWI, VSX_BUILTIN_XXSLDWI_16QI,
@@ -4168,7 +4714,7 @@
 /* Implementation of the resolve_overloaded_builtin target hook, to
    support Altivec's overloaded builtins.  */
 
-tree
+static tree
 altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
 				    void *passed_arglist)
 {
@@ -4570,3 +5116,147 @@
   error ("invalid parameter combination for AltiVec intrinsic");
   return error_mark_node;
 }
+
+/* Return true if the pair of arguments in ARGS is acceptable according
+   to DECLTYPES and FLAGS.  CMPP determines whether this is for the
+   comparison arguments.  */
+
+static bool
+isel_arguments_valid (tree *args, tree *decltypes, int flags, bool cmpp)
+{
+  tree type0 = TREE_TYPE (args[0]);
+  tree type1 = TREE_TYPE (args[1]);
+  tree decltype0 = decltypes[0];
+  tree decltype1 = decltypes[1];
+
+  switch (flags & (cmpp ? ISEL_FLAG_CMP_MASK : ISEL_FLAG_SEL_MASK))
+    {
+      /* For pointer arguments and results, we just need to make sure
+        we're receiving pointers, and they can be freely converted to
+        and from void *.  For pointer results, we also need to ensure
+        that the types of the passed arguments are compatible: this is
+        similar to what the ?: construct would need to ensure.  */
+    case ISEL_FLAG_CMP_PTR:
+    case ISEL_FLAG_SEL_PTR:
+      {
+       /* Results compatible with each other?  */
+       if (!lang_hooks.types_compatible_p (type0, type1))
+         return false;
+
+       return (POINTER_TYPE_P (type0)
+               && POINTER_TYPE_P (type1));
+      }
+      break;
+      /* For signed and unsigned arguments and results, we just need to
+        make sure that the argument types are compatible with the
+        declared types; we can insert conversions to make everything
+        match up.  */
+    case ISEL_FLAG_CMP_SIGNED:
+    case ISEL_FLAG_SEL_SIGNED:
+    case ISEL_FLAG_CMP_UNSIGNED:
+    case ISEL_FLAG_SEL_UNSIGNED:
+      return (lang_hooks.types_compatible_p (type0, decltype0)
+             && lang_hooks.types_compatible_p (type1, decltype1));
+    default:
+      ;
+    }
+
+  gcc_unreachable ();
+}
+
+/* Determine if FNDECL is a generic isel intrinsic and if it can be
+   resolved to a non-generic version with a proper type using the
+   descriptions found in DESC.  Return a call to the non-generic builtin
+   if so.  */
+
+static tree
+rs6000_resolve_isel_builtin (location_t loc, tree fndecl,
+                            void *passed_arglist,
+                            const struct isel_builtin_desc *desc,
+                            int n_descs)
+{
+  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);
+  unsigned int nargs = vec_safe_length (arglist);
+  int i;
+  enum rs6000_builtins fcode
+    = (enum rs6000_builtins)DECL_FUNCTION_CODE (fndecl);
+  const struct isel_builtin_desc *generic = NULL;
+
+  /* Is this even a builtin we care about?  */
+  if (!rs6000_overloaded_builtin_p (fcode))
+    return NULL_TREE;
+
+  if (nargs != 4)
+    {
+      return NULL_TREE;
+    }
+
+  /* Find the generic builtin we're resolving.  */
+  for (i = 0; i < n_descs; i++)
+    if (desc[i].code == fcode)
+      {
+       generic = &desc[i];
+       break;
+      }
+
+  /* Happens if we're looking for a 64-bit builtin in the 32-bit
+     descriptors.  */
+  if (generic == NULL)
+    return NULL_TREE;
+
+  /* Try all the builtins whose comparison matches the generic one.  */
+  for (i = 0; i < n_descs; i++)
+    {
+      const struct isel_builtin_desc *d = &desc[i];
+      int j;
+      tree *argp = vec_safe_address (arglist);
+      tree impl_fndecl;
+      tree decltypes[4], t;
+      tree converted_args[4];
+
+      if (d == generic || d->cmp_code != generic->cmp_code)
+       continue;
+
+      impl_fndecl = rs6000_builtin_decls[d->code];
+      t = TYPE_ARG_TYPES (TREE_TYPE (impl_fndecl));
+      for (j = 0 ; t != void_list_node; j++, t = TREE_CHAIN (t))
+       decltypes[j] = TREE_VALUE (t);
+
+      if (!isel_arguments_valid (argp, decltypes, d->arg_flags, true)
+         || !isel_arguments_valid (argp+2, decltypes+2, d->arg_flags, false))
+       continue;
+
+      /* We got here, we're ok.  Build a new, resolved CALL_EXPR.  */
+      for (j = 0; j < 4; j++)
+       converted_args[j] = fold_convert (decltypes[j], argp[j]);
+
+      return build_call_expr_loc (loc, impl_fndecl, 4,
+                                 converted_args[0], converted_args[1],
+                                 converted_args[2], converted_args[3]);
+    }
+
+  error ("invalid parameter combination for isel intrinsic");
+  return error_mark_node;
+}
+
+tree
+rs6000_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)
+{
+  tree t;
+
+  t = rs6000_resolve_isel_builtin (loc, fndecl, arglist,
+                                  builtin_iselw, ARRAY_SIZE (builtin_iselw));
+  if (t)
+    return t;
+
+  t = rs6000_resolve_isel_builtin (loc, fndecl, arglist,
+                                  builtin_iseld, ARRAY_SIZE (builtin_iseld));
+  if (t)
+    return t;
+
+  t = altivec_resolve_overloaded_builtin (loc, fndecl, arglist);
+  if (t)
+    return t;
+
+  return NULL_TREE;
+}
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000-cpus.def test/gcc-4.9.2/gcc/config/rs6000/rs6000-cpus.def
--- gcc-4.9.2/gcc/config/rs6000/rs6000-cpus.def	2014-01-24 09:56:48.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000-cpus.def	2018-04-02 14:15:30.000000000 +0800
@@ -95,6 +95,7 @@
 				 | OPTION_MASK_SOFT_FLOAT		\
 				 | OPTION_MASK_STRICT_ALIGN_OPTIONAL	\
 				 | OPTION_MASK_VSX			\
+				 | OPTION_MASK_ALTIVEC2			\
 				 | OPTION_MASK_VSX_TIMODE)
 
 #endif
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000.h test/gcc-4.9.2/gcc/config/rs6000/rs6000.h
--- gcc-4.9.2/gcc/config/rs6000/rs6000.h	2014-08-12 23:28:41.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000.h	2018-04-02 14:15:37.000000000 +0800
@@ -523,13 +523,15 @@
 
 #define TARGET_FCTIDZ	TARGET_FCFID
 #define TARGET_STFIWX	TARGET_PPC_GFXOPT
-#define TARGET_LFIWAX	TARGET_CMPB
-#define TARGET_LFIWZX	TARGET_POPCNTD
-#define TARGET_FCFIDS	TARGET_POPCNTD
-#define TARGET_FCFIDU	TARGET_POPCNTD
-#define TARGET_FCFIDUS	TARGET_POPCNTD
-#define TARGET_FCTIDUZ	TARGET_POPCNTD
-#define TARGET_FCTIWUZ	TARGET_POPCNTD
+#define TARGET_LFIWAX	(TARGET_CMPB && rs6000_cpu != PROCESSOR_PPCE5500 \
+			 && rs6000_cpu != PROCESSOR_PPCE6500)
+#define TARGET_LFIWZX	(TARGET_POPCNTD && rs6000_cpu != PROCESSOR_PPCE5500 \
+			 && rs6000_cpu != PROCESSOR_PPCE6500)
+#define TARGET_FCFIDS	TARGET_LFIWZX
+#define TARGET_FCFIDU	TARGET_LFIWZX
+#define TARGET_FCFIDUS	TARGET_LFIWZX
+#define TARGET_FCTIDUZ	TARGET_LFIWZX
+#define TARGET_FCTIWUZ	TARGET_LFIWZX
 
 #define TARGET_XSCVDPSPN	(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)
 #define TARGET_XSCVSPDPN	(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)
@@ -657,10 +659,14 @@
 
 #define TARGET_FRE	(TARGET_HARD_FLOAT && TARGET_FPRS \
 			 && TARGET_DOUBLE_FLOAT \
-			 && (TARGET_POPCNTB || VECTOR_UNIT_VSX_P (DFmode)))
+			 && (TARGET_POPCNTB || VECTOR_UNIT_VSX_P (DFmode)) \
+			 && rs6000_cpu != PROCESSOR_PPCE5500 \
+			 && rs6000_cpu != PROCESSOR_PPCE6500)
 
 #define TARGET_FRSQRTES	(TARGET_HARD_FLOAT && TARGET_POPCNTB \
-			 && TARGET_FPRS && TARGET_SINGLE_FLOAT)
+			 && TARGET_FPRS && TARGET_SINGLE_FLOAT \
+			 && rs6000_cpu != PROCESSOR_PPCE5500 \
+			 && rs6000_cpu != PROCESSOR_PPCE6500)
 
 #define TARGET_FRSQRTE	(TARGET_HARD_FLOAT && TARGET_FPRS \
 			 && TARGET_DOUBLE_FLOAT \
@@ -695,7 +701,7 @@
 #define REGISTER_TARGET_PRAGMAS() do {				\
   c_register_pragma (0, "longcall", rs6000_pragma_longcall);	\
   targetm.target_option.pragma_parse = rs6000_pragma_target_parse; \
-  targetm.resolve_overloaded_builtin = altivec_resolve_overloaded_builtin; \
+  targetm.resolve_overloaded_builtin = rs6000_resolve_overloaded_builtin; \
   rs6000_target_modify_macros_ptr = rs6000_target_modify_macros; \
 } while (0)
 
@@ -873,7 +879,8 @@
    && (STRICT_ALIGNMENT || !optimize_size)                       \
    && (ALIGN) < BITS_PER_WORD                                    \
    ? BITS_PER_WORD                                               \
-   : (ALIGN))
+   : ((TARGET_ALTIVEC && (TREE_CODE (EXP) == VECTOR_CST)       \
+     && ((ALIGN) < 128)) ? 128 : (ALIGN)))
 
 /* Make arrays of chars word-aligned for the same reasons.  */
 #define DATA_ALIGNMENT(TYPE, ALIGN) \
@@ -2601,6 +2608,7 @@
    aren't in target_flags.  */
 #define RS6000_BTM_ALWAYS	0		/* Always enabled.  */
 #define RS6000_BTM_ALTIVEC	MASK_ALTIVEC	/* VMX/altivec vectors.  */
+#define RS6000_BTM_ALTIVEC2	OPTION_MASK_ALTIVEC2 /* ISA 2.07 altivec vectors.  */
 #define RS6000_BTM_VSX		MASK_VSX	/* VSX (vector/scalar).  */
 #define RS6000_BTM_P8_VECTOR	MASK_P8_VECTOR	/* ISA 2.07 vector.  */
 #define RS6000_BTM_CRYPTO	MASK_CRYPTO	/* crypto funcs.  */
@@ -2616,8 +2624,10 @@
 #define RS6000_BTM_DFP		MASK_DFP	/* Decimal floating point.  */
 #define RS6000_BTM_HARD_FLOAT	MASK_SOFT_FLOAT	/* Hardware floating point.  */
 #define RS6000_BTM_LDBL128	MASK_MULTIPLE	/* 128-bit long double.  */
+#define RS6000_BTM_ISEL		MASK_ISEL	/* Target supports isel instruction */
 
 #define RS6000_BTM_COMMON	(RS6000_BTM_ALTIVEC			\
+				 | RS6000_BTM_ALTIVEC2			\
 				 | RS6000_BTM_VSX			\
 				 | RS6000_BTM_P8_VECTOR			\
 				 | RS6000_BTM_CRYPTO			\
@@ -2630,7 +2640,8 @@
 				 | RS6000_BTM_CELL			\
 				 | RS6000_BTM_DFP			\
 				 | RS6000_BTM_HARD_FLOAT		\
-				 | RS6000_BTM_LDBL128)
+				 | RS6000_BTM_LDBL128			\
+				 | RS6000_BTM_ISEL)
 
 /* Define builtin enum index.  */
 
@@ -2787,3 +2798,41 @@
 extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];
 extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];
 
+/* Values for struct isel_builtin_desc.arg_flags.  */
+enum {
+  ISEL_FLAG_CMP_PTR = 0x1,
+  ISEL_FLAG_CMP_SIGNED = 0x2,
+  ISEL_FLAG_CMP_UNSIGNED = 0x4,
+  ISEL_FLAG_CMP_MASK = 0x7,
+  ISEL_FLAG_SEL_PTR = 0x10,
+  ISEL_FLAG_SEL_SIGNED = 0x20,
+  ISEL_FLAG_SEL_UNSIGNED = 0x40,
+  ISEL_FLAG_SEL_MASK = 0x70
+};
+
+struct isel_builtin_desc {
+  /* Name of this builtin.  NULL if we should construct it.  */
+  const char *name;
+
+  /* Flags for argument combinations accepted by the builtin.
+     Zero if this builtin is a generic builtin, to be resolved later.  */
+  int arg_flags;
+
+  /* The code of the builtin.  */
+  enum rs6000_builtins code;
+
+  /* rtx_code and machine_mode are not available here; use ints instead.  */
+  /* The comparison code the builtin uses.  */
+  int cmp_code;
+
+  /* The mode the builtin does comparisons in.  */
+  int cmp_mode;
+
+  /* The mode the builtin's selected arguments are in.
+     Also happens to be its result mode.  */
+  int sel_mode;
+};
+
+/* Arrays describing isel builtins.  */
+extern const struct isel_builtin_desc builtin_iselw[32];
+extern const struct isel_builtin_desc builtin_iseld[32];
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000.md test/gcc-4.9.2/gcc/config/rs6000/rs6000.md
--- gcc-4.9.2/gcc/config/rs6000/rs6000.md	2014-09-24 01:24:37.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000.md	2018-04-02 14:15:39.000000000 +0800
@@ -264,6 +264,8 @@
 ; PTImode is GPR only)
 (define_mode_iterator TI2 [TI PTI])
 
+(define_mode_iterator P2 [(SI "TARGET_32BIT || TARGET_SLOW_MFOCR") (DI "TARGET_64BIT")])
+
 ; Any hardware-supported floating-point mode
 (define_mode_iterator FP [
   (SF "TARGET_HARD_FLOAT 
@@ -1861,7 +1863,10 @@
    addi %0,%1,%2
    addic %0,%1,%2
    addis %0,%1,%v2"
-  [(set_attr "length" "4,4,4,4")])
+  [(set_attr "length" "4,4,4,4")
+   (set (attr "type")
+        (if_then_else (match_test "rs6000_cpu_attr == CPU_PPCE500MC")
+                      (const_string "two") (const_string "*")))])
 
 (define_insn "addsi3_high"
   [(set (match_operand:SI 0 "gpc_reg_operand" "=b")
@@ -1980,7 +1985,10 @@
   [(set (match_operand:GPR 0 "gpc_reg_operand" "=r")
 	(not:GPR (match_operand:GPR 1 "gpc_reg_operand" "r")))]
   ""
-  "nor %0,%1,%1")
+  "nor %0,%1,%1"
+  [(set (attr "type")
+        (if_then_else (match_test "rs6000_cpu_attr == CPU_PPCE500MC")
+                      (const_string "two") (const_string "*")))])
 
 (define_insn ""
   [(set (match_operand:CC 0 "cc_reg_operand" "=x,?y")
@@ -2132,9 +2140,9 @@
 
 (define_insn ""
   [(set (match_operand:CC 0 "cc_reg_operand" "=x,?y")
-	(compare:CC (neg:P (match_operand:P 1 "gpc_reg_operand" "r,r"))
+	(compare:CC (neg:P2 (match_operand:P2 1 "gpc_reg_operand" "r,r"))
 		    (const_int 0)))
-   (clobber (match_scratch:P 2 "=r,r"))]
+   (clobber (match_scratch:P2 2 "=r,r"))]
   ""
   "@
    neg. %2,%1
@@ -2144,12 +2152,12 @@
 
 (define_split
   [(set (match_operand:CC 0 "cc_reg_not_cr0_operand" "")
-	(compare:CC (neg:P (match_operand:P 1 "gpc_reg_operand" ""))
+	(compare:CC (neg:P2 (match_operand:P2 1 "gpc_reg_operand" ""))
 		    (const_int 0)))
-   (clobber (match_scratch:P 2 ""))]
+   (clobber (match_scratch:P2 2 ""))]
   "reload_completed"
   [(set (match_dup 2)
-	(neg:P (match_dup 1)))
+	(neg:P2 (match_dup 1)))
    (set (match_dup 0)
 	(compare:CC (match_dup 2)
 		    (const_int 0)))]
@@ -2157,10 +2165,10 @@
 
 (define_insn ""
   [(set (match_operand:CC 2 "cc_reg_operand" "=x,?y")
-	(compare:CC (neg:P (match_operand:P 1 "gpc_reg_operand" "r,r"))
+	(compare:CC (neg:P2 (match_operand:P2 1 "gpc_reg_operand" "r,r"))
 		    (const_int 0)))
-   (set (match_operand:P 0 "gpc_reg_operand" "=r,r")
-	(neg:P (match_dup 1)))]
+   (set (match_operand:P2 0 "gpc_reg_operand" "=r,r")
+	(neg:P2 (match_dup 1)))]
   ""
   "@
    neg. %0,%1
@@ -2170,13 +2178,13 @@
 
 (define_split
   [(set (match_operand:CC 2 "cc_reg_not_cr0_operand" "")
-	(compare:CC (neg:P (match_operand:P 1 "gpc_reg_operand" ""))
+	(compare:CC (neg:P2 (match_operand:P2 1 "gpc_reg_operand" ""))
 		    (const_int 0)))
-   (set (match_operand:P 0 "gpc_reg_operand" "")
-	(neg:P (match_dup 1)))]
+   (set (match_operand:P2 0 "gpc_reg_operand" "")
+	(neg:P2 (match_dup 1)))]
   "reload_completed"
   [(set (match_dup 0)
-	(neg:P (match_dup 1)))
+	(neg:P2 (match_dup 1)))
    (set (match_dup 2)
 	(compare:CC (match_dup 0)
 		    (const_int 0)))]
@@ -5362,10 +5370,10 @@
    && ((TARGET_PPC_GFXOPT
         && !HONOR_NANS (<MODE>mode)
         && !HONOR_SIGNED_ZEROS (<MODE>mode))
-       || TARGET_CMPB
+       || TARGET_LFIWAX
        || VECTOR_UNIT_VSX_P (<MODE>mode))"
 {
-  if (TARGET_CMPB || VECTOR_UNIT_VSX_P (<MODE>mode))
+  if (TARGET_LFIWAX || VECTOR_UNIT_VSX_P (<MODE>mode))
     {
       emit_insn (gen_copysign<mode>3_fcpsgn (operands[0], operands[1],
 					     operands[2]));
@@ -5384,7 +5392,7 @@
 	(unspec:SFDF [(match_operand:SFDF 1 "gpc_reg_operand" "<Ff>,<Fv>")
 		      (match_operand:SFDF 2 "gpc_reg_operand" "<Ff>,<Fv>")]
 		     UNSPEC_COPYSIGN))]
-  "TARGET_<MODE>_FPR && TARGET_CMPB"
+  "TARGET_<MODE>_FPR && TARGET_LFIWAX"
   "@
    fcpsgn %0,%2,%1
    xscpsgn<Fvsx> %x0,%x2,%x1"
@@ -14521,31 +14529,31 @@
   "")
 
 (define_insn_and_split "*gtu<mode>"
-  [(set (match_operand:P 0 "gpc_reg_operand" "=r")
-	(gtu:P (match_operand:P 1 "gpc_reg_operand" "r")
-	       (match_operand:P 2 "reg_or_short_operand" "rI")))]
+  [(set (match_operand:P2 0 "gpc_reg_operand" "=r")
+	(gtu:P2 (match_operand:P2 1 "gpc_reg_operand" "r")
+	        (match_operand:P2 2 "reg_or_short_operand" "rI")))]
   ""
   "#"
   ""
-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))
-   (set (match_dup 0) (neg:P (match_dup 0)))]
+  [(set (match_dup 0) (neg:P2 (gtu:P2 (match_dup 1) (match_dup 2))))
+   (set (match_dup 0) (neg:P2 (match_dup 0)))]
   "")
 
 (define_insn_and_split "*gtu<mode>_compare"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x,?y")
 	(compare:CC
-	 (gtu:P (match_operand:P 1 "gpc_reg_operand" "r,r")
-		 (match_operand:P 2 "reg_or_short_operand" "rI,rI"))
+	 (gtu:P2 (match_operand:P2 1 "gpc_reg_operand" "r,r")
+		 (match_operand:P2 2 "reg_or_short_operand" "rI,rI"))
 	 (const_int 0)))
-   (set (match_operand:P 0 "gpc_reg_operand" "=r,r")
-	(gtu:P (match_dup 1) (match_dup 2)))]
+   (set (match_operand:P2 0 "gpc_reg_operand" "=r,r")
+	(gtu:P2 (match_dup 1) (match_dup 2)))]
   ""
   "#"
   ""
-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))
+  [(set (match_dup 0) (neg:P2 (gtu:P2 (match_dup 1) (match_dup 2))))
    (parallel [(set (match_dup 3)
-		   (compare:CC (neg:P (match_dup 0)) (const_int 0)))
-	      (set (match_dup 0) (neg:P (match_dup 0)))])]
+		   (compare:CC (neg:P2 (match_dup 0)) (const_int 0)))
+	      (set (match_dup 0) (neg:P2 (match_dup 0)))])]
   "")
 
 (define_insn_and_split "*plus_gtu<mode>"
@@ -14580,9 +14588,9 @@
   "")
 
 (define_insn "*neg_gtu<mode>"
-  [(set (match_operand:P 0 "gpc_reg_operand" "=r")
-	(neg:P (gtu:P (match_operand:P 1 "gpc_reg_operand" "r")
-		      (match_operand:P 2 "reg_or_short_operand" "rI"))))]
+  [(set (match_operand:P2 0 "gpc_reg_operand" "=r")
+	(neg:P2 (gtu:P2 (match_operand:P2 1 "gpc_reg_operand" "r")
+		      	(match_operand:P2 2 "reg_or_short_operand" "rI"))))]
   ""
   "subf%I2c %0,%1,%2\;subfe %0,%0,%0"
   [(set_attr "type" "two")
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000.opt test/gcc-4.9.2/gcc/config/rs6000/rs6000.opt
--- gcc-4.9.2/gcc/config/rs6000/rs6000.opt	2014-01-24 09:56:48.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000.opt	2018-04-02 14:15:37.000000000 +0800
@@ -148,6 +148,10 @@
 Target Report RejectNegative Var(rs6000_altivec_element_order, 2)
 Generate Altivec instructions using big-endian element order
 
+maltivec2
+Target Report Mask(ALTIVEC2) Var(rs6000_isa_flags)
+Use AltiVec PowerPC V2.07 instructions
+
 mhard-dfp
 Target Report Mask(DFP) Var(rs6000_isa_flags)
 Use decimal floating point instructions
@@ -164,6 +168,14 @@
 Target Report Mask(MULTIPLE) Var(rs6000_isa_flags)
 Generate load/store multiple instructions
 
+mmax_block_clear=
+Target RejectNegative Joined UInteger Var(rs6000_max_block_clear) Init(0)
+Maximum size in bytes above which generate string instructions for block clear
+
+mopt-memset
+Target Report Var(TARGET_OPT_MEMSET_STORE) Save
+If optimal emit sequence of stores for memset
+
 mstring
 Target Report Mask(STRING) Var(rs6000_isa_flags)
 Generate string instructions for block moves
@@ -341,10 +353,18 @@
 Target RejectNegative Alias(misel)
 Deprecated option.  Use -misel instead
 
+mcopy-unaligned
+Target Report Var(TARGET_COPY_UNALIGNED)
+Generate unaligned word load and stores to move 3 bytes
+
 mspe
 Target Var(rs6000_spe) Save
 Generate SPE SIMD instructions on E500
 
+mslow-mfocr
+Target Report Var(TARGET_SLOW_MFOCR)
+Generate slow mfocr instructions
+
 mpaired
 Target Var(rs6000_paired_float) Save
 Generate PPC750CL paired-single instructions
@@ -361,6 +381,10 @@
 Target RejectNegative Joined
 -mdebug=	Enable debug output
 
+mmap_dwarf_vecreg
+Target RejectNegative Var(rs6000_map_dwarf_vec_reg, 0) Save
+Generate expected DWARF Register Number Mapping for Vector Registers 
+
 mabi=altivec
 Target RejectNegative Var(rs6000_altivec_abi) Save
 Use the AltiVec ABI extensions
diff -rNu gcc-4.9.2/gcc/config/rs6000/rs6000-protos.h test/gcc-4.9.2/gcc/config/rs6000/rs6000-protos.h
--- gcc-4.9.2/gcc/config/rs6000/rs6000-protos.h	2014-09-20 04:59:51.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/rs6000-protos.h	2018-04-02 14:15:37.000000000 +0800
@@ -160,7 +160,7 @@
 						     unsigned int);
 extern unsigned int darwin_rs6000_special_round_type_align (tree, unsigned int,
 							    unsigned int);
-extern tree altivec_resolve_overloaded_builtin (location_t, tree, void *);
+extern tree rs6000_resolve_overloaded_builtin (location_t, tree, void *);
 extern rtx rs6000_libcall_value (enum machine_mode);
 extern rtx rs6000_va_arg (tree, tree);
 extern int function_ok_for_sibcall (tree);
@@ -186,6 +186,7 @@
 extern void rs6000_emit_prologue (void);
 extern void rs6000_emit_load_toc_table (int);
 extern unsigned int rs6000_dbx_register_number (unsigned int);
+extern unsigned int rs6000_fsl_dbx_register_number (unsigned int);
 extern void rs6000_emit_epilogue (int);
 extern void rs6000_emit_eh_reg_restore (rtx, rtx);
 extern const char * output_isel (rtx *);
@@ -196,6 +197,8 @@
 extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);
 extern HOST_WIDE_INT rs6000_builtin_mask_calculate (void);
 
+extern bool rs6000_bypass_load_on_store_collision_p (rtx out_insn, rtx in_insn);
+
 /* Declare functions in rs6000-c.c */
 
 extern void rs6000_pragma_longcall (struct cpp_reader *);
diff -rNu gcc-4.9.2/gcc/config/rs6000/sysv4.h test/gcc-4.9.2/gcc/config/rs6000/sysv4.h
--- gcc-4.9.2/gcc/config/rs6000/sysv4.h	2014-07-25 01:25:19.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/sysv4.h	2018-04-02 14:15:40.000000000 +0800
@@ -538,6 +538,9 @@
 #define CC1_SECURE_PLT_DEFAULT_SPEC ""
 #endif
 
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC ""
+
 /* Pass -G xxx to the compiler.  */
 #define	CC1_SPEC "%{G*} %(cc1_cpu)" \
 "%{meabi: %{!mcall-*: -mcall-sysv }} \
@@ -551,7 +554,7 @@
 %{msdata: -msdata=default} \
 %{mno-sdata: -msdata=none} \
 %{!mbss-plt: %{!msecure-plt: %(cc1_secure_plt_default)}} \
-%{profile: -p}"
+%{profile: -p}" CC1_EXTRA_SPEC
 
 /* Default starting address if specified.  */
 #define LINK_START_SPEC "\
@@ -629,6 +632,7 @@
   mcall-linux  : %(startfile_linux)       ; \
   mcall-netbsd : %(startfile_netbsd)      ; \
   mcall-openbsd: %(startfile_openbsd)     ; \
+  maeabi       : %(startfile_aeabi)       ; \
                : %(startfile_default)     }"
 
 #define	STARTFILE_DEFAULT_SPEC "ecrti.o%s crtbegin.o%s"
@@ -643,6 +647,7 @@
   mcall-linux  : %(lib_linux)       ; \
   mcall-netbsd : %(lib_netbsd)      ; \
   mcall-openbsd: %(lib_openbsd)     ; \
+  maeabi       : %(lib_aeabi)       ; \
                : %(lib_default)     }"
 
 #define LIB_DEFAULT_SPEC "-lc"
@@ -657,6 +662,7 @@
   mcall-linux  : %(endfile_linux)       ; \
   mcall-netbsd : %(endfile_netbsd)      ; \
   mcall-openbsd: %(endfile_openbsd)     ; \
+  maeabi       : %(endfile_aeabi)       ; \
                : %(crtsavres_default) %(endfile_default)     }"
 
 #define CRTSAVRES_DEFAULT_SPEC ""
@@ -948,7 +954,8 @@
 /* This target uses the sysv4.opt file.  */
 #define TARGET_USES_SYSV4_OPT 1
 
-#undef DBX_REGISTER_NUMBER
+/* Use standard DWARF numbering for DWARF debugging information.  */
+#define DBX_REGISTER_NUMBER(REGNO) rs6000_fsl_dbx_register_number (REGNO)
 
 /* Link -lasan early on the command line.  For -static-libasan, don't link
    it for -shared link, the executable should be compiled with -static-libasan
diff -rNu gcc-4.9.2/gcc/config/rs6000/sysv4.opt test/gcc-4.9.2/gcc/config/rs6000/sysv4.opt
--- gcc-4.9.2/gcc/config/rs6000/sysv4.opt	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/sysv4.opt	2018-04-02 14:15:40.000000000 +0800
@@ -116,6 +116,10 @@
 Target RejectNegative
 Link with libsim.a, libc.a and sim-crt0.o
 
+maeabi
+Target RejectNegative
+Link with libaeabi.a, crtaeabi0.o and crtaeabi9.o
+
 mads
 Target RejectNegative
 Link with libads.a, libc.a and crt0.o
diff -rNu gcc-4.9.2/gcc/config/rs6000/t-linux64 test/gcc-4.9.2/gcc/config/rs6000/t-linux64
--- gcc-4.9.2/gcc/config/rs6000/t-linux64	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/t-linux64	2018-04-02 14:15:39.000000000 +0800
@@ -25,11 +25,14 @@
 # it doesn't tell anything about the 32bit libraries on those systems.  Set
 # MULTILIB_OSDIRNAMES according to what is found on the target.
 
-MULTILIB_OPTIONS    := m64/m32
-MULTILIB_DIRNAMES   := 64 32
-MULTILIB_EXTRA_OPTS := 
-MULTILIB_OSDIRNAMES := m64=../lib64$(call if_multiarch,:powerpc64-linux-gnu)
-MULTILIB_OSDIRNAMES += m32=$(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:powerpc-linux-gnu)
+MULTILIB_OPTIONS        = m64/m32 msoft-float
+MULTILIB_DIRNAMES       = 64 32 nof
+MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
+MULTILIB_EXCEPTIONS     = m64/msoft-float
+MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
+MULTILIB_OSDIRNAMES     = ../lib64$(call if_multiarch,:powerpc64-linux-gnu)
+MULTILIB_OSDIRNAMES    += $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:powerpc-linux-gnu) nof$(call if_multiarch,:powerpc-linux-gnu)
+MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
 
 rs6000-linux.o: $(srcdir)/config/rs6000/rs6000-linux.c
 	$(COMPILE) $<
diff -rNu gcc-4.9.2/gcc/config/rs6000/t-ppc-e500mc test/gcc-4.9.2/gcc/config/rs6000/t-ppc-e500mc
--- gcc-4.9.2/gcc/config/rs6000/t-ppc-e500mc	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/t-ppc-e500mc	2018-04-02 14:15:40.000000000 +0800
@@ -0,0 +1,20 @@
+# Multilibs for powerpc embedded ELF targets.
+MULTILIB_OPTIONS	= msoft-float \
+			  mlittle \
+			  fleading-underscore \
+			  m64
+
+MULTILIB_DIRNAMES	= nof \
+			  le \
+			  und \
+			  64
+
+MULTILIB_EXCLUSIONS     = m64/msoft-float m64/mlittle m64/fleading-underscore
+
+MULTILIB_EXTRA_OPTS	= mno-eabi mstrict-align
+
+MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT} \
+			  ${MULTILIB_MATCHES_ENDIAN}
+
+softfp_wrap_start := '\#ifndef __powerpc64__'
+softfp_wrap_end := '\#endif'
diff -rNu gcc-4.9.2/gcc/config/rs6000/t-rs6000 test/gcc-4.9.2/gcc/config/rs6000/t-rs6000
--- gcc-4.9.2/gcc/config/rs6000/t-rs6000	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/rs6000/t-rs6000	2018-04-02 14:15:31.000000000 +0800
@@ -24,6 +24,10 @@
 	$(COMPILE) $<
 	$(POSTCOMPILE)
 
+extelim.o: $(srcdir)/config/rs6000/extelim.c 
+	$(COMPILE) $<
+	$(POSTCOMPILE)
+
 $(srcdir)/config/rs6000/rs6000-tables.opt: $(srcdir)/config/rs6000/genopt.sh \
   $(srcdir)/config/rs6000/rs6000-cpus.def
 	$(SHELL) $(srcdir)/config/rs6000/genopt.sh $(srcdir)/config/rs6000 > \
diff -rNu gcc-4.9.2/gcc/config/sh/linux.h test/gcc-4.9.2/gcc/config/sh/linux.h
--- gcc-4.9.2/gcc/config/sh/linux.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/sh/linux.h	2018-04-02 14:15:42.000000000 +0800
@@ -43,7 +43,7 @@
 
 #define TARGET_ASM_FILE_END file_end_indicate_exec_stack
 
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER SYSTEMLIBS_DIR "ld-linux.so.2"
 
 #undef SUBTARGET_LINK_EMUL_SUFFIX
 #define SUBTARGET_LINK_EMUL_SUFFIX "_linux"
diff -rNu gcc-4.9.2/gcc/config/sparc/linux64.h test/gcc-4.9.2/gcc/config/sparc/linux64.h
--- gcc-4.9.2/gcc/config/sparc/linux64.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/sparc/linux64.h	2018-04-02 14:15:42.000000000 +0800
@@ -92,8 +92,8 @@
    When the -shared link option is used a final link is not being
    done.  */
 
-#define GLIBC_DYNAMIC_LINKER32 "/lib/ld-linux.so.2"
-#define GLIBC_DYNAMIC_LINKER64 "/lib64/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER32 SYSTEMLIBS_DIR "ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER64 SYSTEMLIBS_DIR "ld-linux.so.2"
 
 #ifdef SPARC_BI_ARCH
 
diff -rNu gcc-4.9.2/gcc/config/sparc/linux.h test/gcc-4.9.2/gcc/config/sparc/linux.h
--- gcc-4.9.2/gcc/config/sparc/linux.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/config/sparc/linux.h	2018-04-02 14:15:42.000000000 +0800
@@ -83,7 +83,7 @@
    When the -shared link option is used a final link is not being
    done.  */
 
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER SYSTEMLIBS_DIR "ld-linux.so.2"
 
 #undef  LINK_SPEC
 #define LINK_SPEC "-m elf32_sparc %{shared:-shared} \
diff -rNu gcc-4.9.2/gcc/config.gcc test/gcc-4.9.2/gcc/config.gcc
--- gcc-4.9.2/gcc/config.gcc	2014-09-17 22:16:02.000000000 +0800
+++ test/gcc-4.9.2/gcc/config.gcc	2018-04-02 14:15:43.000000000 +0800
@@ -441,10 +441,12 @@
 	extra_headers="ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h"
 	need_64bit_hwint=yes
 	case x$with_cpu in
-	    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[345678]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|Xe6500)
+	    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[345678]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|xe6500)
 		cpu_is_64bit=yes
 		;;
 	esac
+	tm_defines="${tm_defines} ENABLE_EXTELIM"
+	extra_objs="extelim.o"
 	extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
 	;;
 rs6000*-*-*)
@@ -2247,6 +2249,23 @@
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
 	;;
+powerpc-*-aeabi)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	case ${enable_targets}:${cpu_is_64bit} in
+	  *powerpc64* | all:* | *:yes)
+	  if test x$cpu_is_64bit = xyes; then
+	    tm_file="${tm_file} rs6000/default64.h"
+	  fi
+	  tm_file="rs6000/biarch64.h ${tm_file}"
+	  ;;
+	esac
+	if test x$enable_powerpc_e500mc_aeabi = xyes; then
+	  tm_file="${tm_file} rs6000/e500mc.h"
+	  tmake_file="${tmake_file} rs6000/t-ppc-e500mc"
+	fi
+	;;
 powerpc-*-eabialtivec*)
 	tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabialtivec.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
@@ -2271,7 +2290,12 @@
 	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-rtems rs6000/t-ppccomm"
 	;;
 powerpc*-*-linux*)
-	tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h rs6000/sysv4.h"
+	case ${target} in
+           powerpc*-*-linux*spe* | powerpc*-*-linux*altivec*)
+               tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h rs6000/sysv4.h" ;;
+           *)
+               tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h rs6000/sysv4.h rs6000/linuxaltivec.h rs6000/linuxspe.h rs6000/e500.h" ;;
+        esac
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
 	extra_objs="$extra_objs rs6000-linux.o"
diff -rNu gcc-4.9.2/gcc/configure test/gcc-4.9.2/gcc/configure
--- gcc-4.9.2/gcc/configure	2014-10-10 20:51:28.000000000 +0800
+++ test/gcc-4.9.2/gcc/configure	2018-04-02 14:15:44.000000000 +0800
@@ -3352,7 +3352,9 @@
 if test "${with_sysroot+set}" = set; then
   gcc_gxx_without_sysroot=`expr "${gcc_gxx_include_dir}" : "${with_sysroot}"'\(.*\)'`
   if test "${gcc_gxx_without_sysroot}"; then
-    gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    if test x${with_sysroot} != x/; then
+      gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    fi
     gcc_gxx_include_dir_add_sysroot=1
   fi
 fi
@@ -7758,7 +7760,7 @@
 *** Info documentation will not be built." >&2;}
   BUILD_INFO=
 else
-  BUILD_INFO=info
+  BUILD_INFO=
 fi
 
 
@@ -11306,8 +11308,8 @@
 	CC="${CC_FOR_BUILD}" CFLAGS="${CFLAGS_FOR_BUILD}" \
 	CXX="${CXX_FOR_BUILD}" CXXFLAGS="${CXXFLAGS_FOR_BUILD}" \
 	LD="${LD_FOR_BUILD}" LDFLAGS="${LDFLAGS_FOR_BUILD}" \
-	GMPINC="" CPPFLAGS="${CPPFLAGS} -DGENERATOR_FILE" \
-	${realsrcdir}/configure \
+	GMPINC="" CPPFLAGS="${CPPFLAGS_FOR_BUILD} -DGENERATOR_FILE" \
+	${realsrcdir}/configure --with-gnu-ld --with-gnu-as --enable-targets=all \
 		--enable-languages=${enable_languages-all} \
 		--target=$target_alias --host=$build_alias --build=$build_alias
 
@@ -11617,10 +11619,20 @@
 tmake_file_=
 for f in ${tmake_file}
 do
-	if test -f ${srcdir}/config/$f
-	then
-		tmake_file_="${tmake_file_} \$(srcdir)/config/$f"
-	fi
+  case $f in
+    */t-linux64 )
+       if test -f ./config/$f
+       then
+         tmake_file_="${tmake_file_} ./config/$f"
+       fi
+       ;;
+    * )
+       if test -f ${srcdir}/config/$f
+       then
+         tmake_file_="${tmake_file_} \$(srcdir)/config/$f"
+       fi
+       ;;
+  esac
 done
 tmake_file="${tmake_file_}"
 
@@ -11631,14 +11643,18 @@
 tm_include_list="options.h insn-constants.h"
 for f in $tm_file; do
   case $f in
+    */linux64.h )
+       tm_file_list="${tm_file_list} ./config/$f"
+       tm_include_list="${tm_include_list} ./config/$f"
+       ;;
     ./* )
        f=`echo $f | sed 's/^..//'`
        tm_file_list="${tm_file_list} $f"
        tm_include_list="${tm_include_list} $f"
        ;;
     defaults.h )
-       tm_file_list="${tm_file_list} \$(srcdir)/$f"
-       tm_include_list="${tm_include_list} $f"
+       tm_file_list="${tm_file_list} ./$f"
+       tm_include_list="${tm_include_list} ./$f"
        ;;
     * )
        tm_file_list="${tm_file_list} \$(srcdir)/config/$f"
diff -rNu gcc-4.9.2/gcc/configure.ac test/gcc-4.9.2/gcc/configure.ac
--- gcc-4.9.2/gcc/configure.ac	2014-10-10 20:51:28.000000000 +0800
+++ test/gcc-4.9.2/gcc/configure.ac	2018-04-02 14:15:43.000000000 +0800
@@ -148,7 +148,9 @@
 if test "${with_sysroot+set}" = set; then
   gcc_gxx_without_sysroot=`expr "${gcc_gxx_include_dir}" : "${with_sysroot}"'\(.*\)'`
   if test "${gcc_gxx_without_sysroot}"; then
-    gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    if test x${with_sysroot} != x/; then
+      gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    fi
     gcc_gxx_include_dir_add_sysroot=1
   fi
 fi
@@ -1539,7 +1541,7 @@
 	CC="${CC_FOR_BUILD}" CFLAGS="${CFLAGS_FOR_BUILD}" \
 	CXX="${CXX_FOR_BUILD}" CXXFLAGS="${CXXFLAGS_FOR_BUILD}" \
 	LD="${LD_FOR_BUILD}" LDFLAGS="${LDFLAGS_FOR_BUILD}" \
-	GMPINC="" CPPFLAGS="${CPPFLAGS} -DGENERATOR_FILE" \
+	GMPINC="" CPPFLAGS="${CPPFLAGS_FOR_BUILD} -DGENERATOR_FILE" \
 	${realsrcdir}/configure \
 		--enable-languages=${enable_languages-all} \
 		--target=$target_alias --host=$build_alias --build=$build_alias
@@ -1720,10 +1722,20 @@
 tmake_file_=
 for f in ${tmake_file}
 do
-	if test -f ${srcdir}/config/$f
-	then
-		tmake_file_="${tmake_file_} \$(srcdir)/config/$f"
-	fi
+  case $f in
+    */t-linux64 )
+       if test -f ./config/$f
+       then
+         tmake_file_="${tmake_file_} ./config/$f"
+       fi
+       ;;
+    * )
+       if test -f ${srcdir}/config/$f
+       then
+         tmake_file_="${tmake_file_} \$(srcdir)/config/$f"
+       fi
+       ;;
+  esac
 done
 tmake_file="${tmake_file_}"
 
@@ -1734,14 +1746,18 @@
 tm_include_list="options.h insn-constants.h"
 for f in $tm_file; do
   case $f in
+    */linux64.h )
+       tm_file_list="${tm_file_list} ./config/$f"
+       tm_include_list="${tm_include_list} ./config/$f"
+       ;;
     ./* )
        f=`echo $f | sed 's/^..//'`
        tm_file_list="${tm_file_list} $f"
        tm_include_list="${tm_include_list} $f"
        ;;
     defaults.h )
-       tm_file_list="${tm_file_list} \$(srcdir)/$f"
-       tm_include_list="${tm_include_list} $f"
+       tm_file_list="${tm_file_list} ./$f"
+       tm_include_list="${tm_include_list} ./$f"
        ;;
     * )
        tm_file_list="${tm_file_list} \$(srcdir)/config/$f"
diff -rNu gcc-4.9.2/gcc/context.c test/gcc-4.9.2/gcc/context.c
--- gcc-4.9.2/gcc/context.c	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/context.c	2018-04-02 14:15:31.000000000 +0800
@@ -20,6 +20,7 @@
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "tm.h"
 #include "ggc.h"
 #include "context.h"
 #include "pass_manager.h"
diff -rNu gcc-4.9.2/gcc/cp/g++spec.c test/gcc-4.9.2/gcc/cp/g++spec.c
--- gcc-4.9.2/gcc/cp/g++spec.c	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/cp/g++spec.c	2018-04-02 14:15:41.000000000 +0800
@@ -138,6 +138,7 @@
       switch (decoded_options[i].opt_index)
 	{
 	case OPT_nostdlib:
+	case OPT_nostdlib__:
 	case OPT_nodefaultlibs:
 	  library = -1;
 	  break;
diff -rNu gcc-4.9.2/gcc/defaults.h test/gcc-4.9.2/gcc/defaults.h
--- gcc-4.9.2/gcc/defaults.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/defaults.h	2018-04-02 14:15:36.000000000 +0800
@@ -438,6 +438,11 @@
 #define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)
 #endif
 
+/* The mapping from dwarf CFA reg number to internal dwarf reg numbers.  */
+#ifndef DWARF_REG_TO_UNWIND_COLUMN
+#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)
+#endif
+
 /* Map register numbers held in the call frame info that gcc has
    collected using DWARF_FRAME_REGNUM to those that should be output in
    .debug_frame and .eh_frame.  */
diff -rNu gcc-4.9.2/gcc/doc/extend.texi test/gcc-4.9.2/gcc/doc/extend.texi
--- gcc-4.9.2/gcc/doc/extend.texi	2014-06-14 05:56:16.000000000 +0800
+++ test/gcc-4.9.2/gcc/doc/extend.texi	2018-04-02 14:15:35.000000000 +0800
@@ -15534,6 +15534,106 @@
   @}
 @end smallexample
 
+GCC also provides a family of builtins on PowerPC to explicitly use
+the @code{isel} instruction.  While GCC can and does generate
+@code{isel} instructions normally, the builtins enable you to
+explicitly force generation of these instructions.  The builtins are
+only available when compiling for processors that support the
+@code{isel} instruction; they compile to a code sequence of
+@code{cmpw} followed by @code{isel}.
+
+@table @code
+@item int __builtin_iseleq (int @var{x}, int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iseleq (unsigned int @var{x}, unsigned int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iseleq (void *@var{x}, void *@var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iseleq (int @var{x}, int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iseleq (unsigned int @var{x}, unsigned int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iseleq (void *@var{x}, void *@var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iseleq (int @var{x}, int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iseleq (unsigned int @var{x}, unsigned int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iseleq (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} and @var{y} are equal, otherwise return @var{b}.
+
+@item int __builtin_isellt (int @var{x}, int @var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_isellt (int @var{x}, int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_isellt (int @var{x}, int @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item int __builtin_iselgt (int @var{x}, int @var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iselgt (int @var{x}, int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iselgt (int @var{x}, int @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item int __builtin_iselltu (unsigned int @var{x}, unsigned int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iselltu (void *@var{x}, void *@var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iselltu (unsigned int @var{x}, unsigned int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iselltu (void *@var{x}, void *@var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iselltu (unsigned int @var{x}, unsigned int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iselltu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_isellt}, this uses unsigned comparison.
+
+@item int __builtin_iselgtu (unsigned int @var{x}, unsigned int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iselgtu (void *@var{x}, void *@var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iselgtu (unsigned int @var{x}, unsigned int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iselgtu (void *@var{x}, void *@var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iselgtu (unsigned int @var{x}, unsigned int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iselgtu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_iselgt}, this uses unsigned comparison.
+
+@end table
+
+Builtins that do 64-bit comparisons (i.e. using @code{cmpd} instead of
+@code{cmpw}) are also available on 64-bit processors supporting
+@code{isel}.
+
+@table @code
+@item long __builtin_isel64eq (long @var{x}, long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64eq (unsigned long @var{x}, unsigned long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64eq (void *@var{x}, void *@var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64eq (long @var{x}, long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64eq (unsigned long @var{x}, unsigned long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64eq (void *@var{x}, void *@var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64eq (long @var{x}, long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64eq (unsigned long @var{x}, unsigned long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64eq (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} and @var{y} are equal, otherwise return @var{b}.
+
+@item long __builtin_isel64lt (long @var{x}, long @var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64lt (long @var{x}, long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64lt (long @var{x}, long @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item long __builtin_isel64gt (long @var{x}, long @var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64gt (long @var{x}, long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64gt (long @var{x}, long @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item long __builtin_isel64ltu (unsigned long @var{x}, unsigned long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64ltu (void *@var{x}, void *@var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64ltu (unsigned long @var{x}, unsigned long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64ltu (void *@var{x}, void *@var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64ltu (unsigned long @var{x}, unsigned long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64ltu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_isel64lt}, this uses unsigned comparison.
+
+@item long __builtin_isel64gtu (unsigned long @var{x}, unsigned long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64gtu (void *@var{x}, void *@var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64gtu (unsigned long @var{x}, unsigned long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64gtu (void *@var{x}, void *@var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64gtu (unsigned long @var{x}, unsigned long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64gtu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_isel64gt}, this uses unsigned comparison.
+
+@end table
+
 @node RX Built-in Functions
 @subsection RX Built-in Functions
 GCC supports some of the RX instructions which cannot be expressed in
diff -rNu gcc-4.9.2/gcc/doc/invoke.texi test/gcc-4.9.2/gcc/doc/invoke.texi
--- gcc-4.9.2/gcc/doc/invoke.texi	2014-10-16 21:51:45.000000000 +0800
+++ test/gcc-4.9.2/gcc/doc/invoke.texi	2018-04-02 14:15:41.000000000 +0800
@@ -193,6 +193,7 @@
 -fvisibility-inlines-hidden @gol
 -fvtable-verify=@var{std|preinit|none} @gol
 -fvtv-counts -fvtv-debug @gol
+-nostdlib++ @gol
 -fvisibility-ms-compat @gol
 -fext-numeric-literals @gol
 -Wabi  -Wconversion-null  -Wctor-dtor-privacy @gol
@@ -456,7 +457,7 @@
 -nostartfiles  -nodefaultlibs  -nostdlib -pie -rdynamic @gol
 -s  -static -static-libgcc -static-libstdc++ @gol
 -static-libasan -static-libtsan -static-liblsan -static-libubsan @gol
--shared -shared-libgcc  -symbolic @gol
+-shared -shared-libgcc  -symbolic -nostdlib++ @gol
 -T @var{script}  -Wl,@var{option}  -Xlinker @var{option} @gol
 -u @var{symbol}}
 
@@ -10321,6 +10322,11 @@
 libc.  These entry points should be supplied through some other
 mechanism when this option is specified.
 
+@item -nostdlib++
+@opindex nostdlib++
+Do not use the standard system C++ runtime libraries when linking.
+Only the libraries you specify will be passed to the linker.
+
 @cindex @option{-lgcc}, use with @option{-nostdlib}
 @cindex @option{-nostdlib} and unresolved references
 @cindex unresolved references and @option{-nostdlib}
diff -rNu gcc-4.9.2/gcc/dwarf2cfi.c test/gcc-4.9.2/gcc/dwarf2cfi.c
--- gcc-4.9.2/gcc/dwarf2cfi.c	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/dwarf2cfi.c	2018-04-02 14:15:36.000000000 +0800
@@ -252,7 +252,60 @@
 		  gen_int_mode (size, mode));
 }
 
-/* Generate code to initialize the register size table.  */
+/* Datastructure used by expand_builtin_init_dwarf_reg_sizes and
+   init_one_dwarf_reg_size to communicate on what has been done by the
+   latter.  */
+
+typedef struct
+{
+  /* Whether the dwarf return column was initialized.  */
+  bool wrote_return_column;
+
+  /* For each hard register REGNO, whether init_one_dwarf_reg_size
+     was given REGNO to process already.  */
+  bool processed_regno [FIRST_PSEUDO_REGISTER];
+
+} init_one_dwarf_reg_state;
+
+/* Helper for expand_builtin_init_dwarf_reg_sizes.  Generate code to
+   initialize the dwarf register size table entry corresponding to register
+   REGNO in REGMODE.  TABLE is the table base address, SLOTMODE is the mode to
+   use for the size entry to initialize, and INIT_STATE is the communication
+   datastructure conveying what we're doing to our caller.  */
+
+static
+void init_one_dwarf_reg_size (int regno, machine_mode regmode,
+                             rtx table, machine_mode slotmode,
+                             init_one_dwarf_reg_state *init_state)
+{
+  const unsigned int dnum = DWARF_FRAME_REGNUM (regno);
+  const unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);
+  const unsigned int dcol = DWARF_REG_TO_UNWIND_COLUMN (rnum);
+
+  const HOST_WIDE_INT slotoffset = dcol * GET_MODE_SIZE (slotmode);
+  const HOST_WIDE_INT regsize = GET_MODE_SIZE (regmode);
+
+  init_state->processed_regno[regno] = true;
+
+  if (rnum >= DWARF_FRAME_REGISTERS)
+    return;
+
+  if (dnum == DWARF_FRAME_RETURN_COLUMN)
+    {
+      if (regmode == VOIDmode)
+       return;
+      init_state->wrote_return_column = true;
+    }
+
+  if (slotoffset < 0)
+    return;
+
+  emit_move_insn (adjust_address (table, slotmode, slotoffset),
+                 gen_int_mode (regsize, slotmode));
+}
+
+/* Generate code to initialize the dwarf register size table located
+   at the provided ADDRESS.  */
 
 void
 expand_builtin_init_dwarf_reg_sizes (tree address)
@@ -261,37 +314,41 @@
   enum machine_mode mode = TYPE_MODE (char_type_node);
   rtx addr = expand_normal (address);
   rtx mem = gen_rtx_MEM (BLKmode, addr);
-  bool wrote_return_column = false;
+
+  init_one_dwarf_reg_state init_state;
+  memset ((char *)&init_state, 0, sizeof (init_state));
 
   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
     {
-      unsigned int dnum = DWARF_FRAME_REGNUM (i);
-      unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);
+      machine_mode save_mode;
+      rtx span;
 
-      if (rnum < DWARF_FRAME_REGISTERS)
-	{
-	  HOST_WIDE_INT offset = rnum * GET_MODE_SIZE (mode);
-	  enum machine_mode save_mode = reg_raw_mode[i];
-	  HOST_WIDE_INT size;
-
-	  if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))
-	    save_mode = choose_hard_reg_mode (i, 1, true);
-	  if (dnum == DWARF_FRAME_RETURN_COLUMN)
+      /* No point in processing a register multiple times.  This could happen
+         with register spans, e.g. when a reg is first processed as a piece of
+         a span, then as a register on its own later on.  */
+
+      if (init_state.processed_regno[i])
+        continue;
+
+      save_mode = reg_raw_mode[i];
+      if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))
+        save_mode = choose_hard_reg_mode (i, 1, true);
+
+      span = targetm.dwarf_register_span (gen_rtx_REG (save_mode, i));
+      if (!span)
+        init_one_dwarf_reg_size (i, save_mode, mem, mode, &init_state);
+      else
+        {
+           for (int si = 0; si < XVECLEN (span, 0); si++)
 	    {
-	      if (save_mode == VOIDmode)
-		continue;
-	      wrote_return_column = true;
-	    }
-	  size = GET_MODE_SIZE (save_mode);
-	  if (offset < 0)
-	    continue;
-
-	  emit_move_insn (adjust_address (mem, mode, offset),
-			  gen_int_mode (size, mode));
+               rtx reg = XVECEXP (span, 0, si);
+               init_one_dwarf_reg_size
+                 (REGNO (reg), GET_MODE (reg), mem, mode, &init_state);
+            }
 	}
     }
 
-  if (!wrote_return_column)
+  if (!init_state.wrote_return_column)
     init_return_column_size (mode, mem, DWARF_FRAME_RETURN_COLUMN);
 
 #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
diff -rNu gcc-4.9.2/gcc/dwarf2out.c test/gcc-4.9.2/gcc/dwarf2out.c
--- gcc-4.9.2/gcc/dwarf2out.c	2014-10-02 04:57:44.000000000 +0800
+++ test/gcc-4.9.2/gcc/dwarf2out.c	2018-04-02 14:15:39.000000000 +0800
@@ -22213,10 +22213,17 @@
 dwarf2out_assembly_start (void)
 {
   if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE
-      && dwarf2out_do_cfi_asm ()
-      && (!(flag_unwind_tables || flag_exceptions)
-	  || targetm_common.except_unwind_info (&global_options) != UI_DWARF2))
-    fprintf (asm_out_file, "\t.cfi_sections\t.debug_frame\n");
+      && dwarf2out_do_cfi_asm ())
+    {
+      if (!(flag_unwind_tables || flag_exceptions)
+	  || targetm_common.except_unwind_info (&global_options) != UI_DWARF2)
+        fprintf (asm_out_file, "\t.cfi_sections\t.debug_frame\n");
+
+      if (flag_debug_unwind_tables
+          && (flag_unwind_tables || flag_exceptions)
+          && targetm_common.except_unwind_info (&global_options) == UI_DWARF2)
+        fprintf (asm_out_file, "\t.cfi_sections\t.eh_frame, .debug_frame\n");
+    }
 }
 
 /* A helper function for dwarf2out_finish called through
diff -rNu gcc-4.9.2/gcc/expr.c test/gcc-4.9.2/gcc/expr.c
--- gcc-4.9.2/gcc/expr.c	2014-09-01 18:14:22.000000000 +0800
+++ test/gcc-4.9.2/gcc/expr.c	2018-04-02 14:15:31.000000000 +0800
@@ -67,6 +67,7 @@
 #include "params.h"
 #include "tree-ssa-address.h"
 #include "cfgexpand.h"
+#include "tree-ssa.h"
 
 /* Decide whether a function's arguments should be processed
    from first to last or from last to first.
@@ -344,7 +345,7 @@
   if (GET_CODE (from) == SUBREG && SUBREG_PROMOTED_VAR_P (from)
       && (GET_MODE_PRECISION (GET_MODE (SUBREG_REG (from)))
 	  >= GET_MODE_PRECISION (to_mode))
-      && SUBREG_PROMOTED_UNSIGNED_P (from) == unsignedp)
+      && SUBREG_CHECK_PROMOTED_SIGN (from, unsignedp))
     from = gen_lowpart (to_mode, from), from_mode = to_mode;
 
   gcc_assert (GET_CODE (to) != SUBREG || !SUBREG_PROMOTED_VAR_P (to));
@@ -718,7 +719,7 @@
 
   if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)
       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) >= GET_MODE_SIZE (mode)
-      && SUBREG_PROMOTED_UNSIGNED_P (x) == unsignedp)
+      && SUBREG_CHECK_PROMOTED_SIGN (x, unsignedp))
     x = gen_lowpart (mode, SUBREG_REG (x));
 
   if (GET_MODE (x) != VOIDmode)
@@ -5226,25 +5227,25 @@
 	  && GET_MODE_PRECISION (GET_MODE (target))
 	     == TYPE_PRECISION (TREE_TYPE (exp)))
 	{
-	  if (TYPE_UNSIGNED (TREE_TYPE (exp))
-	      != SUBREG_PROMOTED_UNSIGNED_P (target))
+	  if (!SUBREG_CHECK_PROMOTED_SIGN (target,
+					  TYPE_UNSIGNED (TREE_TYPE (exp))))
 	    {
 	      /* Some types, e.g. Fortran's logical*4, won't have a signed
 		 version, so use the mode instead.  */
 	      tree ntype
 		= (signed_or_unsigned_type_for
-		   (SUBREG_PROMOTED_UNSIGNED_P (target), TREE_TYPE (exp)));
+		   (SUBREG_PROMOTED_SIGN (target), TREE_TYPE (exp)));
 	      if (ntype == NULL)
 		ntype = lang_hooks.types.type_for_mode
 		  (TYPE_MODE (TREE_TYPE (exp)),
-		   SUBREG_PROMOTED_UNSIGNED_P (target));
+		   SUBREG_PROMOTED_SIGN (target));
 
 	      exp = fold_convert_loc (loc, ntype, exp);
 	    }
 
 	  exp = fold_convert_loc (loc, lang_hooks.types.type_for_mode
 				  (GET_MODE (SUBREG_REG (target)),
-				   SUBREG_PROMOTED_UNSIGNED_P (target)),
+				   SUBREG_PROMOTED_SIGN (target)),
 				  exp);
 
 	  inner_target = SUBREG_REG (target);
@@ -5258,14 +5259,14 @@
       if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)
 	{
 	  temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),
-				temp, SUBREG_PROMOTED_UNSIGNED_P (target));
+				temp, SUBREG_PROMOTED_SIGN (target));
 	  temp = convert_modes (GET_MODE (SUBREG_REG (target)),
 			        GET_MODE (target), temp,
-			        SUBREG_PROMOTED_UNSIGNED_P (target));
+				SUBREG_PROMOTED_SIGN (target));
 	}
 
       convert_move (SUBREG_REG (target), temp,
-		    SUBREG_PROMOTED_UNSIGNED_P (target));
+		    SUBREG_PROMOTED_SIGN (target));
 
       return NULL_RTX;
     }
@@ -7972,6 +7973,7 @@
   int unsignedp = TYPE_UNSIGNED (type);
   enum machine_mode mode = TYPE_MODE (type);
   enum machine_mode orig_mode = mode;
+  bool promoted = false;
 
   /* If we cannot do a conditional move on the mode, try doing it
      with the promoted mode. */
@@ -8018,6 +8020,12 @@
       comparison_mode = TYPE_MODE (TREE_TYPE (treeop0));
     }
 
+  if (GET_MODE (op1) == GET_MODE (op2)
+      && (GET_MODE_SIZE (mode) > GET_MODE_SIZE (orig_mode))
+      && SUBREG_PROMOTED_VAR_P (op1)
+      && SUBREG_PROMOTED_VAR_P (op2))
+    promoted = true;
+  
   if (GET_MODE (op1) != mode)
     op1 = gen_lowpart (mode, op1);
 
@@ -8034,10 +8042,14 @@
      and return.  */
   if (insn)
     {
+      rtx target;
       rtx seq = get_insns ();
       end_sequence ();
       emit_insn (seq);
-      return convert_modes (orig_mode, mode, temp, 0);
+      target = convert_modes (orig_mode, mode, temp, 0);
+      if (promoted)
+        SUBREG_PROMOTED_VAR_P (target) = 1;
+      return target;
     }
 
   /* Otherwise discard the sequence and fall back to code with
@@ -9232,6 +9244,35 @@
 }
 #undef REDUCE_BIT_FIELD
 
+/* Return TRUE if value in SSA is zero and sign extended for wider mode MODE
+   using value range information stored.  Return FALSE otherwise.
+
+   This is used to check if SUBREG is zero and sign extended and to set
+   promoted mode SRP_SIGNED_AND_UNSIGNED to SUBREG.  */
+
+bool
+promoted_for_signed_and_unsigned_p (tree ssa, enum machine_mode mode)
+{
+  double_int min, max;
+
+  if (ssa == NULL_TREE
+      || TREE_CODE (ssa) != SSA_NAME
+      || !INTEGRAL_TYPE_P (TREE_TYPE (ssa))
+      || (TYPE_PRECISION (TREE_TYPE (ssa)) != GET_MODE_PRECISION (mode)))
+    return false;
+
+  /* Return FALSE if value_range is not recorded for SSA.  */
+  if (get_range_info (ssa, &min, &max) != VR_RANGE)
+    return false;
+
+  /* Return true (to set SRP_SIGNED_AND_UNSIGNED to SUBREG) if MSB of the
+     smaller mode is not set (i.e.  MSB of ssa is not set).  */
+  if (!min.is_negative () && !max.is_negative ())
+    return true;
+  else
+    return false;
+
+}
 
 /* Return TRUE if expression STMT is suitable for replacement.  
    Never consider memory loads as replaceable, because those don't ever lead 
@@ -9514,7 +9555,10 @@
 
 	  temp = gen_lowpart_SUBREG (mode, decl_rtl);
 	  SUBREG_PROMOTED_VAR_P (temp) = 1;
-	  SUBREG_PROMOTED_UNSIGNED_SET (temp, unsignedp);
+	  if (promoted_for_signed_and_unsigned_p (ssa_name, mode))
+	    SUBREG_PROMOTED_SET (temp, SRP_SIGNED_AND_UNSIGNED);
+	  else
+	    SUBREG_PROMOTED_SET (temp, unsignedp);
 	  return temp;
 	}
 
diff -rNu gcc-4.9.2/gcc/expr.h test/gcc-4.9.2/gcc/expr.h
--- gcc-4.9.2/gcc/expr.h	2014-03-25 01:38:09.000000000 +0800
+++ test/gcc-4.9.2/gcc/expr.h	2018-04-02 14:15:31.000000000 +0800
@@ -446,6 +446,7 @@
 			       enum expand_modifier, rtx *, bool);
 extern rtx expand_expr_real_2 (sepops, rtx, enum machine_mode,
 			       enum expand_modifier);
+extern bool promoted_for_signed_and_unsigned_p (tree, enum machine_mode);
 
 /* Generate code for computing expression EXP.
    An rtx for the computed value is returned.  The value is never null.
diff -rNu gcc-4.9.2/gcc/function.c test/gcc-4.9.2/gcc/function.c
--- gcc-4.9.2/gcc/function.c	2014-07-10 18:41:15.000000000 +0800
+++ test/gcc-4.9.2/gcc/function.c	2018-04-02 14:15:31.000000000 +0800
@@ -3085,7 +3085,7 @@
 	  /* The argument is already sign/zero extended, so note it
 	     into the subreg.  */
 	  SUBREG_PROMOTED_VAR_P (tempreg) = 1;
-	  SUBREG_PROMOTED_UNSIGNED_SET (tempreg, unsignedp);
+	  SUBREG_PROMOTED_SET (tempreg, unsignedp);
 	}
 
       /* TREE_USED gets set erroneously during expand_assignment.  */
diff -rNu gcc-4.9.2/gcc/gcc.c test/gcc-4.9.2/gcc/gcc.c
--- gcc-4.9.2/gcc/gcc.c	2014-10-23 05:42:48.000000000 +0800
+++ test/gcc-4.9.2/gcc/gcc.c	2018-04-02 14:15:42.000000000 +0800
@@ -777,6 +777,7 @@
     %(mflib) " STACK_SPLIT_SPEC "\
     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} " SANITIZER_SPEC " \
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
+    %{!nostdlib++:}\
     %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
 #endif
 
diff -rNu gcc-4.9.2/gcc/gengtype-lex.c test/gcc-4.9.2/gcc/gengtype-lex.c
--- gcc-4.9.2/gcc/gengtype-lex.c	2014-10-30 16:31:06.000000000 +0800
+++ test/gcc-4.9.2/gcc/gengtype-lex.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,2897 +0,0 @@
-#include "bconfig.h"
-#line 2 "gengtype-lex.c"
-
-#line 4 "gengtype-lex.c"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 37
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-/* C99 requires __STDC__ to be defined as 1. */
-#if defined (__STDC__)
-
-#define YY_USE_CONST
-
-#endif	/* defined (__STDC__) */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#define YY_BUF_SIZE 16384
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern yy_size_t yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-    #define YY_LESS_LINENO(n)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	yy_size_t yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
-yy_size_t yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
-
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-
-#define yywrap() 1
-#define YY_SKIP_YYWRAP
-
-typedef unsigned char YY_CHAR;
-
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-
-#define YY_NUM_RULES 53
-#define YY_END_OF_BUFFER 54
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_accept[558] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,   54,   41,
-       38,   50,   41,   50,   39,   41,   41,   39,   39,   39,
-       39,   39,   35,    9,    9,   33,   35,   14,   35,   33,
-       35,   24,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   13,    9,   35,   46,   44,   51,   51,
-        0,   42,    0,    0,    0,   43,   36,   43,    0,   39,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       39,   39,   39,   39,   39,    9,    0,   29,    0,    0,
-        0,    0,    7,    0,   24,   28,   28,    0,   28,    0,
-
-        0,    0,    0,    0,    0,    0,   30,   10,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        9,    0,    0,    0,    0,   47,   49,   48,   40,    0,
-       37,    0,    0,    0,    0,    0,    0,    0,   39,   39,
-       39,   39,   39,   39,   31,   32,    0,    8,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   34,    0,    0,    0,   39,
-
-        0,    0,    0,    0,    0,    0,    0,   39,   39,   39,
-       39,   39,   39,    0,    0,    0,    0,    0,   15,   15,
-       15,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       26,   26,   26,   26,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   39,    0,    0,    0,    0,    0,    0,    0,   39,
-       39,   39,   39,   39,   39,    0,    0,    0,    0,    0,
-        0,    0,    0,   20,   20,   20,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,   23,   23,   23,    0,    0,    0,    0,
-        0,    0,    0,    0,    4,    4,    4,   39,   39,   39,
-       39,    3,    3,    3,    0,    0,    0,    0,    0,   18,
-       18,   18,   11,   11,   11,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   16,
-       16,   16,    0,    0,    0,    0,    0,    0,    5,    5,
-        5,    6,    6,    6,    2,    2,    2,   39,    0,    0,
-        0,    0,    0,   12,   12,   12,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,   28,   17,   17,   17,
-        0,    0,    0,    0,    0,    1,    1,    1,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   26,
-       26,    0,    0,    0,    0,    0,    0,    0,    0,   12,
-       12,   19,   19,   19,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   25,   25,
-       25,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,   21,   21,   21,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   22,   22,   22,    0,   52,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   28,   28,   28,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   27,
-        0,    0,    0,    0,    0,    0,   45,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0
-    } ;
-
-static yyconst flex_int32_t yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    4,    5,    6,    1,    4,    7,    8,    9,
-       10,   11,    4,    4,    4,   12,   13,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   15,    4,    4,
-        4,    4,    4,    1,   16,   17,   18,   19,   20,   21,
-       22,   23,   24,   25,   25,   26,   27,   28,   29,   30,
-       25,   31,   32,   33,   34,   25,   35,   25,   36,   25,
-       37,   38,   39,    1,   40,    1,   41,   42,   43,   44,
-
-       45,   46,   47,   48,   49,   50,   50,   51,   52,   53,
-       54,   55,   50,   56,   57,   58,   59,   60,   50,   61,
-       62,   63,    4,    4,    4,   64,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst flex_int32_t yy_meta[65] =
-    {   0,
-        1,    2,    3,    1,    1,    1,    1,    1,    1,    4,
-        5,    1,    1,    6,    7,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    9,    1,    1,   10,
-       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
-       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
-       10,   10,   10,    1
-    } ;
-
-static yyconst flex_int16_t yy_base[605] =
-    {   0,
-        0,   64,  128,   14,   14,   15,   16,   18, 1220, 2336,
-     2336,   17, 1181,   17,   21,   38,   40,   31,   30,   32,
-       46,   39, 2336,   47,   49, 2336,   19, 2336, 1177, 1202,
-       45, 1199,  192,  256,   30,   34,    2,   64, 1173, 1208,
-       56,   65,   59,   58,   69,   71,   60,   70,   57,  177,
-      179,  180,  181, 2336,  209, 1208,    0, 2336, 1196, 1195,
-      208, 2336,    0, 1199, 1203, 2336, 2336, 1202,  103,  217,
-     1189,  239,  237, 1152, 1141, 1143, 1138, 1146,  242, 1153,
-      238,  268,  272,  274,  273,  124,  209, 2336, 1194, 1188,
-     1192, 1181, 2336, 1175, 1163, 2336,  275, 1147, 1160, 1145,
-
-      187,  192,  214,  191,   88, 1134, 2336, 2336,  194,  251,
-      262,  220,  195,  243,  270,  276,  225,  275,  271,  277,
-      282,  279,  272,  283,  278,  286,  288,  289,  294,  309,
-      343, 1170, 1169,  352,    0, 2336, 2336, 2336, 2336, 1167,
-     2336, 1167, 1127, 1109,  268, 1111, 1116, 1118,  359,  337,
-      360,  358,  374,  366, 2336, 2336, 1160, 2336,  348, 1147,
-     1159,  327,  292,  330,  420,   24,  336,  319,  329,  405,
-      407,  337,  335,  338,  342,  350,  484,  408,  409,  410,
-      343,  318,  411,  412,  414,  415,  417,  416,  413,  418,
-      431,  420,  419,  421, 1157, 2336,  546,    0, 1157,  496,
-
-     1101, 1112, 1098, 1096, 1106, 1096, 1100,  498,  500,  501,
-      499,  502,  504, 1146,  609,  478,  357,  480, 2336,  510,
-     1132,  495,  497,  422,  424,  425,  673,  427,  452,  481,
-     2336,  736,  525, 1131,  499,  434,  479,  500,  507,  504,
-      505,  501,  518,  503,  522,  509,  524,  529,  532,  795,
-        0,  560, 1088, 1088, 1094, 1099, 1097, 1087, 1086,  859,
-      570,  623,  568,  625,  923,  987,  547,  551,  549,  540,
-      599, 1051, 1115, 2336,  627, 1123,  601,  604,    0,  629,
-     1108, 1106,  621, 1081, 1086, 1088, 1079, 1077,  203, 1076,
-      607,  603,  625,  606,  612,  638,  614,  624,  629,  633,
-
-      630,  627, 1179, 2336,  688, 1099,    0,    0, 1060, 1069,
-     1053, 1065,    0, 1064, 2336,  690, 1093, 1243, 1307, 1371,
-      694, 2336,  691, 1092,  670,  666,  678,  640,  684, 2336,
-      699, 1091, 2336,  702, 1090, 1435, 1075, 1073, 1071, 1069,
-     1046, 1058, 1038,  519, 1044, 1042,  653, 1038,  623,  669,
-      701,  693,  689,  690,  695,  706, 1499,  691,  697, 2336,
-      730, 1079,    0,    0,    0,    0, 1047,  725, 2336,  731,
-     1077, 2336,  745, 1076, 2336,  748, 1072, 1563,  696,  726,
-      723,  552,  738, 2336,  756, 1071, 1059, 1066, 1064, 1049,
-     1030, 1024, 1039, 1038,  759, 1030, 1020, 1022, 1029, 1024,
-
-      735,  736,  752,  753,  741,  743, 1057, 2336,  773, 1056,
-      744, 1627,    0,    0,  809, 2336,  811, 1055,  748,  762,
-      793,  787,  754, 1029, 1045, 1027, 1025,  992,  991, 2336,
-      813,  990, 1002, 1006,  998,  788, 1691,  791,  790, 2336,
-     1042, 2336,  821, 1028,    0, 1009,  707,  800,  801,  789,
-      808, 1024, 1024, 1008, 1003,  993,  978,  820, 2336,  836,
-     1020,  824, 1755,    0,  998,  821,  823,  853,  855,  825,
-      854, 1009, 1001, 1011, 1006, 1819, 2336,  840, 1014,    0,
-     1019,  851,  815,  859,  857,  852,  828,  994,  983, 1000,
-     1002, 2336,  885, 1005,    0, 2336,  860,  873,  872,  870,
-
-      874,  998,  985,  975,  994,    0,  876,  908,  880,  988,
-      986,  977,  872,    0,  910,  938,  911,  913,  889,  988,
-      985,  981,  953,  961,    0,  913,  942,  946,  956,  961,
-      963,  957,  954,  948,  936,  946,    0,  965,  967, 2336,
-      969,  941,  935,  932,  919,  888, 2336,  917,  887,  748,
-      582, 1001,  438,  355, 1003,   73, 2336, 1883, 1893, 1903,
-     1913, 1923, 1932, 1942, 1952, 1962, 1972, 1981, 1991, 2001,
-     2011, 2021, 2031, 2041, 2050, 2059, 2069, 2078, 2088, 2098,
-     2108, 2118, 2127, 2136, 2146, 2155, 2164, 2173, 2182, 2191,
-     2201, 2209, 2219, 2229, 2239, 2249, 2259, 2269, 2278, 2288,
-
-     2297, 2307, 2316, 2325
-    } ;
-
-static yyconst flex_int16_t yy_def[605] =
-    {   0,
-      558,  558,  557,    3,  559,  559,  559,  559,  557,  557,
-      557,  560,  561,  562,  563,  557,  557,  563,  563,  563,
-      563,  563,  557,  557,  557,  557,  564,  557,  565,  557,
-      557,  557,  566,  566,   34,   34,   34,   34,  567,  557,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,  557,  557,  568,  569,  557,  570,  570,
-      560,  557,  560,  557,  561,  557,  557,  571,  557,  563,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      563,  563,  563,  563,  563,  557,  564,  557,  564,  557,
-      565,  557,  557,  572,  557,  557,  557,   34,  557,   34,
-
-       34,   34,   34,   34,   34,  567,  557,  557,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-      557,  568,  568,  573,  574,  557,  557,  557,  557,  571,
-      557,  575,  557,  557,  557,  557,  557,  557,  563,  563,
-      563,  563,  563,  563,  557,  557,  572,  557,  557,  557,
-      576,   34,   34,   34,  566,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,  566,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,  573,  557,  573,  577,  575,  578,
-
-      557,  557,  557,  557,  557,  557,  557,  563,  563,  563,
-      563,  563,  563,  576,  579,   34,   34,   34,  557,  557,
-      557,   34,   34,   34,   34,   34,  566,   34,   34,   34,
-      557,  557,  232,  557,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,  566,
-      580,  578,  557,  557,  557,  557,  557,  557,  557,  563,
-      563,  563,  563,  563,  563,  579,   34,   34,   34,   34,
-       34,  566,  566,  557,  557,  557,   34,   34,  232,  232,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-
-       34,   34,  566,  557,  557,  557,  581,  582,  557,  557,
-      557,  557,  583,  557,  557,  557,  557,  563,  563,  563,
-      563,  557,  557,  557,   34,   34,   34,   34,   34,  557,
-      557,  557,  557,  557,  557,  566,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,   34,   34,
-       34,   34,   34,   34,   34,   34,  566,   34,   34,  557,
-      557,  557,  584,  585,  586,  587,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  563,   34,   34,
-       34,   34,   34,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  588,  557,  557,  557,  557,  557,
-
-       34,   34,   34,   34,   34,   34,  589,  557,  557,  557,
-       34,  566,  590,  591,  557,  557,  557,  557,   34,   34,
-       34,   34,   34,  557,  557,  557,  557,  557,  557,  557,
-      232,  557,  557,  557,  557,   34,  566,   34,   34,  557,
-      592,  557,  557,  557,  593,  557,   34,   34,   34,   34,
-       34,  557,  557,  557,  557,  557,  557,   34,  557,  557,
-      557,   34,  566,  594,  557,   34,   34,   34,   34,   34,
-       34,  557,  557,  557,  557,  566,  557,  557,  557,  595,
-      557,   34,   34,   34,   34,   34,   34,  557,  557,  557,
-      557,  557,  557,  557,  596,  557,   34,   34,   34,   34,
-
-       34,  557,  557,  557,  557,  597,   34,   34,   34,  557,
-      557,  557,  557,  598,   34,  557,  557,  599,   34,  557,
-      557,  557,  557,  557,  600,   34,  557,  557,  599,  599,
-      601,  557,  557,  557,  557,  557,  602,  557,  557,  557,
-      601,  557,  557,  557,  557,  557,  557,  603,  557,  557,
-      603,  604,  557,  557,  604,  557,    0,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-
-      557,  557,  557,  557
-    } ;
-
-static yyconst flex_int16_t yy_nxt[2401] =
-    {   0,
-       10,   10,   11,   10,   12,   10,   10,   13,   10,   10,
-       10,   10,   14,   10,   10,   55,   58,   58,   58,   56,
-       58,   62,   69,   88,   59,   59,   60,   67,   60,   68,
-       98,   69,   69,   69,  103,   71,   10,   10,   10,   72,
-       69,   79,  222,   73,   71,   71,   71,   69,   86,   86,
-       86,   86,   98,   71,   63,   93,   89,   94,   98,  101,
-       71,  102,   98,   10,   10,   16,   11,   10,   12,   17,
-       10,   13,   10,   10,   10,   10,   14,   10,   10,  104,
-       74,   81,   75,   80,   98,   98,   98,   98,   98,   83,
-       82,   85,  105,   98,   76,   77,   78,   98,   98,   98,
-
-       10,   10,   10,  113,   69,  395,   18,   84,   19,  109,
-      114,  119,  110,  117,  118,  111,   98,   71,  112,  167,
-       20,   21,   22,  116,  115,   86,   86,   10,   23,   24,
-       25,   26,   27,   23,   28,   29,   26,   26,   26,   30,
-       31,   32,   26,   33,   34,   35,   33,   36,   33,   37,
-       38,   33,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   39,   40,   23,   33,   33,   41,
-       42,   43,   44,   45,   33,   33,   46,   33,   47,   33,
-       48,   49,   50,   33,   51,   52,   53,   33,   33,   33,
-       33,   54,   96,   97,   96,   96,   96,   96,   96,   96,
-
-       96,   96,   96,   96,   96,   98,   99,   98,   98,   98,
-      131,   86,   62,   88,  132,   98,  163,  120,   69,   98,
-       98,  166,   98,   98,  127,  164,  124,  125,   96,   96,
-       96,   71,  121,  129,  122,  123,  126,  130,   79,   69,
-       72,  128,   98,   79,   73,   63,   89,  168,   98,  165,
-      346,  347,   71,   98,  172,   96,   96,   97,   96,   96,
-       96,   96,   96,   96,   96,   96,   96,   96,   96,   69,
-       99,   98,  171,   69,   69,   69,  159,  178,  149,   98,
-       80,   74,   71,   75,  100,   80,   71,   71,   71,  160,
-       98,  169,   96,   96,   96,   76,   77,   78,   98,   98,
-
-       98,  173,  170,   98,   98,   98,   98,   98,  203,  217,
-       98,   98,  151,  185,   98,  180,   98,   98,  174,   96,
-       98,  154,   98,  204,  187,  150,  175,  152,  153,  176,
-      182,  179,  181,  177,  184,  183,  186,   98,   69,  190,
-      188,  189,  192,  191,  131,   86,   98,   98,  132,  159,
-      193,   71,  216,  194,  196,   98,  218,   98,   98,   69,
-       69,   69,  160,   98,   98,   98,   98,   69,  223,  177,
-       98,   98,   71,   71,   71,   69,  226,  238,   98,  268,
-       71,  209,  228,  237,  177,   98,  227,  395,   71,  230,
-      229,  197,  197,  197,  197,  197,  197,  197,  197,  197,
-
-      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
-      197,  197,  197,  197,  197,  208,  211,  210,  212,  213,
-      219,  220,  219,  219,  219,  219,  219,  219,  219,  219,
-      219,  219,  219,   98,  221,   98,   98,   98,   98,   98,
-       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
-       98,  240,   98,   98,  177,   98,  219,  219,  219,   98,
-      244,  224,   98,  225,  241,  236,  235,  249,  239,  243,
-      242,  245,  246,  248,  292,  247,  250,  556,  272,  277,
-       98,  273,  177,  219,  231,  232,  233,  231,  231,  231,
-      231,  231,  231,  231,  231,  231,  231,   69,  234,   69,
-
-       69,   69,   69,   69,  278,   69,   98,   98,   98,   98,
-       71,  159,   71,   71,   71,   71,   71,  267,   71,  269,
-      231,  231,  231,   98,  160,   98,  280,   98,   98,   98,
-      293,   98,   98,   98,  270,   98,  271,   98,  177,  557,
-      294,  263,  299,  291,  296,  264,   98,  231,  196,  262,
-       98,  295,   98,  297,  260,  261,  265,   98,  177,  301,
-       98,   69,  298,  325,  300,  327,  326,  302,   98,   69,
-      328,   69,  394,  422,   71,   98,  395,   98,  187,   98,
-       98,  303,   71,  551,   71,  197,  197,  197,  197,  197,
-      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
-
-      197,  197,  197,  197,  197,  197,  197,  197,  197,   96,
-       97,   96,   96,   96,   96,   96,   96,   96,   96,   96,
-       96,   96,  318,   99,   69,  320,   69,   98,  159,   98,
-      280,   98,   98,  329,   98,   98,  339,   71,  351,   71,
-       98,  160,   98,  557,  336,   96,   96,   96,  336,  340,
-      349,   98,   98,   98,  354,   98,  356,   98,   98,  382,
-      350,   98,  401,  353,  352,  319,   98,  177,   98,  321,
-      358,  359,   96,  274,  275,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  177,  276,  355,  159,
-      357,   69,   69,  379,   98,   69,  380,   98,   98,  398,
-
-      159,  381,  160,  159,   71,   71,   98,  383,   71,  274,
-      274,  274,   98,  160,  351,  399,  160,   98,   98,   98,
-      407,   98,  402,   98,   98,   98,  415,  415,  419,   98,
-      466,  159,   69,  404,   98,   98,  274,  279,  280,  378,
-      352,  403,  412,  406,  160,   71,   69,  405,  411,   69,
-      160,   98,  281,  282,   98,  421,  423,  159,  283,   71,
-      431,  431,   71,   98,   98,  420,   98,  407,  447,   98,
-      160,   98,   98,  451,  159,  554,   98,  284,  285,  286,
-       98,   98,   98,  439,  287,  438,  288,  160,  336,  436,
-       98,  336,  289,  448,  290,  304,  305,  304,  304,  304,
-
-      304,  304,  304,  304,  304,  304,  304,  304,  437,  306,
-      415,  415,   69,  449,  280,   98,   98,   98,   98,   98,
-      469,   98,  159,  467,  468,   71,  450,  557,   98,   98,
-      446,  304,  304,  304,  462,  160,   98,  159,  407,  470,
-      482,  159,  498,   98,  483,  458,  463,  471,   98,   98,
-      160,   98,   98,   98,  160,  501,   98,  486,  304,  315,
-      316,  315,  315,  315,  315,  315,  315,  315,  315,  315,
-      315,  315,  484,  317,  485,  476,  497,  487,  177,   98,
-       98,   98,   98,   98,  499,   98,  159,   98,   98,  177,
-      508,  500,  507,  509,  515,  315,  315,  315,   98,  160,
-
-       98,   98,   98,  523,   98,  553,  177,  519,   98,  516,
-      517,  524,  528,  528,  530,  530,  518,   98,  551,  529,
-      395,  177,  315,  322,  323,  322,  322,  322,  322,  322,
-      322,  322,  322,  322,  322,  322,   98,  324,   98,  527,
-      528,   98,  550,  527,  528,  177,  529,  528,  528,  526,
-      529,  549,  160,  395,  529,  548,  160,  530,  530,  322,
-      322,  322,  530,  530,  538,  539,  538,  539,  539,  539,
-      538,  539,  540,  546,  540,  545,  540,  542,  540,  542,
-      395,  544,  543,  542,  536,  535,  322,   96,   97,   96,
-       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
-
-      534,   99,  538,  539,  538,  539,  533,  532,  522,  521,
-      540,  520,  540,  513,  512,  542,  511,  542,  510,  161,
-      505,  504,  503,   96,   96,   96,  502,  496,  161,  491,
-      490,  489,  488,  481,  161,  395,  395,  475,  474,  473,
-      472,  465,  161,  214,  398,  457,  456,  395,  395,  395,
-       96,  330,  331,  330,  330,  330,  330,  330,  330,  330,
-      330,  330,  330,  330,  455,  332,  454,  453,  452,  142,
-      161,  441,  435,  434,  433,  432,  395,  429,  428,  395,
-      395,  427,  426,  425,  424,  161,  142,  330,  330,  330,
-      142,  142,  414,  161,  400,  397,  396,  393,  392,  391,
-
-      390,  389,  388,  387,  161,  161,  142,  142,  368,  367,
-      366,  365,  364,  161,  330,  333,  334,  333,  333,  333,
-      333,  333,  333,  333,  333,  333,  333,  333,  348,  335,
-      345,  344,  343,  342,  341,  338,  337,  161,  314,  313,
-      312,  311,  310,  309,  308,  161,  161,  214,  259,  258,
-      257,  333,  333,  333,  256,  255,  254,  253,  199,  196,
-      214,  161,  158,  207,  206,  205,  202,  201,  199,  141,
-      133,  133,  107,  162,  161,   98,   95,  158,  333,  360,
-      361,  360,  360,  360,  360,  360,  360,  360,  360,  360,
-      360,  360,  156,  362,  557,  155,  557,  148,  147,  146,
-
-      145,  144,  143,  142,  141,  557,  139,  138,  137,  133,
-      108,  107,   95,   92,   91,  360,  360,  360,   65,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  360,  369,  370,  369,  369,  369,  369,  369,
-      369,  369,  369,  369,  369,  369,  557,  371,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  369,
-      369,  369,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-
-      557,  557,  557,  557,  557,  557,  369,  372,  373,  372,
-      372,  372,  372,  372,  372,  372,  372,  372,  372,  372,
-      557,  374,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  372,  372,  372,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      372,  375,  376,  375,  375,  375,  375,  375,  375,  375,
-      375,  375,  375,  375,  557,  377,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-
-      557,  557,  557,  557,  557,  557,  557,  375,  375,  375,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  375,  384,  385,  384,  384,  384,
-      384,  384,  384,  384,  384,  384,  384,  384,  557,  386,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  384,  384,  384,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  384,  408,
-
-      409,  408,  408,  408,  408,  408,  408,  408,  408,  408,
-      408,  408,  557,  410,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  408,  408,  408,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  408,  416,  417,  416,  416,  416,  416,  416,
-      416,  416,  416,  416,  416,  416,  557,  418,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  416,
-
-      416,  416,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  416,  442,  443,  442,
-      442,  442,  442,  442,  442,  442,  442,  442,  442,  442,
-      557,  444,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  442,  442,  442,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      442,  459,  460,  459,  459,  459,  459,  459,  459,  459,
-
-      459,  459,  459,  459,  557,  461,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  459,  459,  459,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  459,  477,  478,  477,  477,  477,
-      477,  477,  477,  477,  477,  477,  477,  477,  557,  479,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  477,  477,  477,  557,  557,  557,  557,  557,  557,
-
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  477,  492,
-      493,  492,  492,  492,  492,  492,  492,  492,  492,  492,
-      492,  492,  557,  494,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  492,  492,  492,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  492,   15,   15,   15,   15,   15,   15,   15,
-       15,   15,   15,   57,   57,   57,   57,   57,   57,   57,
-
-       57,   57,   57,   61,   61,   61,   61,   61,   61,   61,
-       61,   61,   61,   64,   64,   64,   64,   64,   64,   64,
-       64,   64,   64,   66,   66,   66,   66,   66,   66,   66,
-       66,   66,   66,   70,  557,  557,  557,   70,   70,   70,
-      557,   70,   87,   87,   87,   87,   87,   87,   87,   87,
-       87,   87,   90,   90,   90,   90,   90,   90,   90,   90,
-       90,   90,   98,   98,   98,   98,   98,   98,   98,   98,
-       98,   98,  106,  106,  106,  106,  106,  106,  106,  106,
-      557,  106,  134,  557,  557,  557,  557,  557,  557,  557,
-      134,  135,  135,  557,  135,  557,  135,  135,  135,  135,
-
-      135,  136,  136,  136,  136,  136,  136,  136,  136,  136,
-      136,  140,  140,  140,  140,  140,  140,  140,  140,  140,
-      140,  157,  157,  157,  157,  157,  157,  157,  157,  157,
-      157,  195,  195,  195,  195,  195,  195,  195,  195,  195,
-      195,  198,  198,  557,  198,  557,  198,  198,  198,  198,
-      198,  200,  557,  557,  557,  557,  557,  200,  557,  200,
-      215,  557,  557,  557,  557,  557,  215,  557,  215,  251,
-      251,  557,  251,  557,  251,  251,  251,  251,  251,  252,
-      557,  557,  557,  252,  252,  252,  557,  252,  266,  266,
-      266,  266,  266,  266,  266,  266,  266,  266,  307,  307,
-
-      557,  307,  557,  307,  307,  307,  307,  307,  363,  363,
-      557,  363,  557,  363,  363,  363,  363,  363,  315,  315,
-      315,  315,  315,  557,  315,  557,  315,  322,  322,  322,
-      322,  322,  557,  322,  557,  322,  413,  413,  557,  413,
-      557,  413,  413,  413,  413,  413,  369,  369,  369,  369,
-      369,  557,  369,  557,  369,  372,  372,  372,  372,  372,
-      557,  372,  557,  372,  375,  375,  375,  375,  375,  557,
-      375,  557,  375,  430,  430,  430,  430,  430,  557,  430,
-      557,  430,  440,  440,  440,  440,  440,  557,  440,  557,
-      440,  445,  445,  557,  445,  557,  445,  445,  445,  445,
-
-      445,  416,  416,  416,  416,  416,  557,  416,  557,  416,
-      215,  557,  557,  557,  557,  557,  215,  557,  215,  464,
-      464,  557,  464,  557,  464,  464,  464,  464,  464,  480,
-      480,  557,  480,  557,  480,  480,  480,  480,  480,  495,
-      495,  557,  495,  557,  495,  495,  495,  495,  495,  506,
-      506,  557,  506,  557,  506,  506,  506,  506,  506,  514,
-      514,  557,  514,  557,  514,  514,  514,  514,  514,  525,
-      525,  557,  525,  557,  525,  525,  525,  525,  525,  531,
-      531,  557,  557,  557,  557,  531,  557,  531,  537,  537,
-      557,  537,  557,  537,  537,  537,  537,  537,  541,  541,
-
-      541,  557,  541,  541,  541,  557,  541,  547,  547,  557,
-      547,  557,  547,  547,  547,  547,  547,  552,  557,  557,
-      557,  557,  557,  552,  557,  552,  555,  555,  555,  557,
-      555,  555,  555,  557,  555,    9,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557
-
-    } ;
-
-static yyconst flex_int16_t yy_chk[2401] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    4,    5,    6,    7,    4,
-        8,   12,   15,   27,    5,    6,    7,   14,    8,   14,
-       37,   19,   18,   20,   37,   15,    1,    1,    1,   16,
-       22,   17,  166,   16,   19,   18,   20,   21,   24,   24,
-       25,   25,  166,   22,   12,   31,   27,   31,   35,   35,
-       21,   36,   36,    1,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,   38,
-       16,   18,   16,   17,   41,   49,   44,   43,   47,   20,
-       19,   22,   38,   42,   16,   16,   16,   45,   48,   46,
-
-        2,    2,    2,   43,   69,  556,    2,   21,    2,   41,
-       44,   49,   42,   47,   48,   42,  105,   69,   42,  105,
-        2,    2,    2,   46,   45,   86,   86,    2,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,   33,   33,   33,   33,   33,   33,   33,   33,
-
-       33,   33,   33,   33,   33,   50,   33,   51,   52,   53,
-       55,   55,   61,   87,   55,  101,  101,   50,   70,  104,
-      102,  104,  109,  113,   52,  102,   51,   51,   33,   33,
-       33,   70,   50,   53,   50,   50,   51,   53,   73,   81,
-       72,   52,  103,   79,   72,   61,   87,  109,  112,  103,
-      289,  289,   81,  117,  113,   33,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   82,
-       34,  114,  112,   83,   85,   84,   97,  117,   81,  110,
-       73,   72,   82,   72,   34,   79,   83,   85,   84,   97,
-      111,  110,   34,   34,   34,   72,   72,   72,  115,  119,
-
-      123,  114,  111,  118,  116,  120,  125,  122,  145,  163,
-      121,  124,   83,  123,  126,  119,  127,  128,  115,   34,
-      163,   85,  129,  145,  125,   82,  116,   83,   84,  116,
-      121,  118,  120,  116,  122,  121,  124,  130,  150,  127,
-      125,  126,  129,  128,  131,  131,  182,  168,  131,  159,
-      129,  150,  162,  130,  134,  162,  164,  169,  164,  152,
-      149,  151,  159,  173,  167,  172,  174,  154,  167,  168,
-      175,  181,  152,  149,  151,  153,  172,  182,  176,  217,
-      154,  150,  174,  181,  169,  217,  173,  554,  153,  176,
-      175,  134,  134,  134,  134,  134,  134,  134,  134,  134,
-
-      134,  134,  134,  134,  134,  134,  134,  134,  134,  134,
-      134,  134,  134,  134,  134,  149,  152,  151,  153,  154,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  170,  165,  171,  178,  179,  180,  183,
-      184,  189,  185,  186,  188,  187,  190,  193,  192,  194,
-      224,  184,  225,  226,  178,  228,  165,  165,  165,  191,
-      188,  170,  236,  171,  185,  180,  179,  193,  183,  187,
-      186,  189,  190,  192,  236,  191,  194,  553,  224,  228,
-      229,  225,  226,  165,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  200,  177,  208,
-
-      211,  209,  210,  212,  229,  213,  216,  237,  218,  230,
-      200,  220,  208,  211,  209,  210,  212,  216,  213,  218,
-      177,  177,  177,  222,  220,  223,  233,  235,  238,  242,
-      237,  244,  240,  241,  222,  239,  223,  246,  230,  233,
-      238,  211,  244,  235,  240,  212,  243,  177,  197,  210,
-      245,  239,  247,  241,  208,  209,  213,  248,  242,  246,
-      249,  252,  243,  267,  245,  269,  268,  247,  270,  263,
-      270,  261,  344,  382,  252,  267,  344,  269,  249,  268,
-      382,  248,  263,  551,  261,  197,  197,  197,  197,  197,
-      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
-
-      197,  197,  197,  197,  197,  197,  197,  197,  197,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  261,  215,  262,  263,  264,  271,  275,  277,
-      280,  292,  278,  271,  294,  291,  283,  262,  293,  264,
-      295,  275,  297,  280,  277,  215,  215,  215,  278,  283,
-      291,  349,  298,  293,  295,  302,  297,  299,  301,  328,
-      292,  300,  349,  294,  293,  262,  296,  298,  328,  264,
-      301,  302,  215,  227,  227,  227,  227,  227,  227,  227,
-      227,  227,  227,  227,  227,  227,  299,  227,  296,  305,
-      300,  316,  323,  325,  326,  321,  326,  350,  325,  347,
-
-      331,  327,  305,  334,  316,  323,  327,  329,  321,  227,
-      227,  227,  329,  331,  351,  347,  334,  353,  354,  358,
-      356,  352,  350,  355,  379,  359,  368,  368,  379,  351,
-      447,  361,  370,  353,  356,  447,  227,  232,  232,  321,
-      351,  352,  359,  355,  361,  370,  373,  354,  358,  376,
-      232,  381,  232,  232,  380,  381,  383,  385,  232,  373,
-      395,  395,  376,  401,  402,  380,  383,  404,  419,  405,
-      385,  406,  411,  423,  409,  550,  419,  232,  232,  232,
-      403,  404,  423,  406,  232,  405,  232,  409,  411,  401,
-      420,  402,  232,  420,  232,  250,  250,  250,  250,  250,
-
-      250,  250,  250,  250,  250,  250,  250,  250,  403,  250,
-      415,  415,  417,  421,  431,  422,  436,  450,  439,  438,
-      450,  421,  443,  448,  449,  417,  422,  431,  448,  449,
-      415,  250,  250,  250,  438,  443,  451,  460,  462,  451,
-      466,  478,  483,  483,  467,  436,  439,  451,  458,  466,
-      460,  467,  462,  470,  478,  487,  487,  470,  250,  260,
-      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
-      260,  260,  468,  260,  469,  458,  482,  471,  497,  482,
-      486,  468,  471,  469,  484,  485,  493,  484,  497,  485,
-      499,  486,  498,  500,  507,  260,  260,  260,  500,  493,
-
-      499,  498,  501,  513,  507,  549,  501,  509,  509,  508,
-      508,  513,  517,  517,  518,  518,  508,  519,  548,  517,
-      546,  519,  260,  265,  265,  265,  265,  265,  265,  265,
-      265,  265,  265,  265,  265,  265,  508,  265,  515,  516,
-      516,  526,  545,  527,  527,  526,  516,  528,  528,  515,
-      527,  544,  516,  543,  528,  542,  527,  529,  529,  265,
-      265,  265,  530,  530,  531,  531,  538,  538,  539,  539,
-      541,  541,  531,  536,  538,  535,  539,  531,  541,  538,
-      534,  533,  532,  541,  524,  523,  265,  266,  266,  266,
-      266,  266,  266,  266,  266,  266,  266,  266,  266,  266,
-
-      522,  266,  552,  552,  555,  555,  521,  520,  512,  511,
-      552,  510,  555,  505,  504,  552,  503,  555,  502,  494,
-      491,  490,  489,  266,  266,  266,  488,  481,  479,  475,
-      474,  473,  472,  465,  461,  457,  456,  455,  454,  453,
-      452,  446,  444,  441,  435,  434,  433,  432,  429,  428,
-      266,  272,  272,  272,  272,  272,  272,  272,  272,  272,
-      272,  272,  272,  272,  427,  272,  426,  425,  424,  418,
-      410,  407,  400,  399,  398,  397,  396,  394,  393,  392,
-      391,  390,  389,  388,  387,  386,  377,  272,  272,  272,
-      374,  371,  367,  362,  348,  346,  345,  343,  342,  341,
-
-      340,  339,  338,  337,  335,  332,  324,  317,  314,  312,
-      311,  310,  309,  306,  272,  273,  273,  273,  273,  273,
-      273,  273,  273,  273,  273,  273,  273,  273,  290,  273,
-      288,  287,  286,  285,  284,  282,  281,  276,  259,  258,
-      257,  256,  255,  254,  253,  234,  221,  214,  207,  206,
-      205,  273,  273,  273,  204,  203,  202,  201,  199,  195,
-      161,  160,  157,  148,  147,  146,  144,  143,  142,  140,
-      133,  132,  106,  100,   99,   98,   95,   94,  273,  303,
-      303,  303,  303,  303,  303,  303,  303,  303,  303,  303,
-      303,  303,   92,  303,   91,   90,   89,   80,   78,   77,
-
-       76,   75,   74,   71,   68,   65,   64,   60,   59,   56,
-       40,   39,   32,   30,   29,  303,  303,  303,   13,    9,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,  303,  318,  318,  318,  318,  318,  318,  318,
-      318,  318,  318,  318,  318,  318,    0,  318,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,  318,
-      318,  318,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,  318,  319,  319,  319,
-      319,  319,  319,  319,  319,  319,  319,  319,  319,  319,
-        0,  319,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,  319,  319,  319,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-      319,  320,  320,  320,  320,  320,  320,  320,  320,  320,
-      320,  320,  320,  320,    0,  320,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,  320,  320,  320,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,  320,  336,  336,  336,  336,  336,
-      336,  336,  336,  336,  336,  336,  336,  336,    0,  336,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,  336,  336,  336,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  336,  357,
-
-      357,  357,  357,  357,  357,  357,  357,  357,  357,  357,
-      357,  357,    0,  357,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,  357,  357,  357,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,  357,  378,  378,  378,  378,  378,  378,  378,
-      378,  378,  378,  378,  378,  378,    0,  378,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,  378,
-
-      378,  378,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,  378,  412,  412,  412,
-      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
-        0,  412,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,  412,  412,  412,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-      412,  437,  437,  437,  437,  437,  437,  437,  437,  437,
-
-      437,  437,  437,  437,    0,  437,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,  437,  437,  437,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,  437,  463,  463,  463,  463,  463,
-      463,  463,  463,  463,  463,  463,  463,  463,    0,  463,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,  463,  463,  463,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  463,  476,
-      476,  476,  476,  476,  476,  476,  476,  476,  476,  476,
-      476,  476,    0,  476,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,  476,  476,  476,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,  476,  558,  558,  558,  558,  558,  558,  558,
-      558,  558,  558,  559,  559,  559,  559,  559,  559,  559,
-
-      559,  559,  559,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  561,  561,  561,  561,  561,  561,  561,
-      561,  561,  561,  562,  562,  562,  562,  562,  562,  562,
-      562,  562,  562,  563,    0,    0,    0,  563,  563,  563,
-        0,  563,  564,  564,  564,  564,  564,  564,  564,  564,
-      564,  564,  565,  565,  565,  565,  565,  565,  565,  565,
-      565,  565,  566,  566,  566,  566,  566,  566,  566,  566,
-      566,  566,  567,  567,  567,  567,  567,  567,  567,  567,
-        0,  567,  568,    0,    0,    0,    0,    0,    0,    0,
-      568,  569,  569,    0,  569,    0,  569,  569,  569,  569,
-
-      569,  570,  570,  570,  570,  570,  570,  570,  570,  570,
-      570,  571,  571,  571,  571,  571,  571,  571,  571,  571,
-      571,  572,  572,  572,  572,  572,  572,  572,  572,  572,
-      572,  573,  573,  573,  573,  573,  573,  573,  573,  573,
-      573,  574,  574,    0,  574,    0,  574,  574,  574,  574,
-      574,  575,    0,    0,    0,    0,    0,  575,    0,  575,
-      576,    0,    0,    0,    0,    0,  576,    0,  576,  577,
-      577,    0,  577,    0,  577,  577,  577,  577,  577,  578,
-        0,    0,    0,  578,  578,  578,    0,  578,  579,  579,
-      579,  579,  579,  579,  579,  579,  579,  579,  580,  580,
-
-        0,  580,    0,  580,  580,  580,  580,  580,  581,  581,
-        0,  581,    0,  581,  581,  581,  581,  581,  582,  582,
-      582,  582,  582,    0,  582,    0,  582,  583,  583,  583,
-      583,  583,    0,  583,    0,  583,  584,  584,    0,  584,
-        0,  584,  584,  584,  584,  584,  585,  585,  585,  585,
-      585,    0,  585,    0,  585,  586,  586,  586,  586,  586,
-        0,  586,    0,  586,  587,  587,  587,  587,  587,    0,
-      587,    0,  587,  588,  588,  588,  588,  588,    0,  588,
-        0,  588,  589,  589,  589,  589,  589,    0,  589,    0,
-      589,  590,  590,    0,  590,    0,  590,  590,  590,  590,
-
-      590,  591,  591,  591,  591,  591,    0,  591,    0,  591,
-      592,    0,    0,    0,    0,    0,  592,    0,  592,  593,
-      593,    0,  593,    0,  593,  593,  593,  593,  593,  594,
-      594,    0,  594,    0,  594,  594,  594,  594,  594,  595,
-      595,    0,  595,    0,  595,  595,  595,  595,  595,  596,
-      596,    0,  596,    0,  596,  596,  596,  596,  596,  597,
-      597,    0,  597,    0,  597,  597,  597,  597,  597,  598,
-      598,    0,  598,    0,  598,  598,  598,  598,  598,  599,
-      599,    0,    0,    0,    0,  599,    0,  599,  600,  600,
-        0,  600,    0,  600,  600,  600,  600,  600,  601,  601,
-
-      601,    0,  601,  601,  601,    0,  601,  602,  602,    0,
-      602,    0,  602,  602,  602,  602,  602,  603,    0,    0,
-        0,    0,    0,  603,    0,  603,  604,  604,  604,    0,
-      604,  604,  604,    0,  604,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557,
-      557,  557,  557,  557,  557,  557,  557,  557,  557,  557
-
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* -*- indented-text -*- */
-/* Process source files and output type information.
-   Copyright (C) 2002-2014 Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify it under
-the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
-version.
-
-GCC is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-#define YY_NO_INPUT 1
-#line 24 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-#ifdef GENERATOR_FILE
-#include "bconfig.h"
-#else
-#include "config.h"
-#endif
-#include "system.h"
-
-#define malloc xmalloc
-#define realloc xrealloc
-
-#include "gengtype.h"
-
-#define YY_DECL int yylex (const char **yylval)
-#define yyterminate() return EOF_TOKEN
-
-struct fileloc lexer_line;
-int lexer_toplevel_done;
-
-static void 
-update_lineno (const char *l, size_t len)
-{
-  while (len-- > 0)
-    if (*l++ == '\n')
-      lexer_line.line++;
-}
-
-/* Include '::' in identifiers to capture C++ scope qualifiers.  */
-
-#line 1227 "gengtype-lex.c"
-
-#define INITIAL 0
-#define in_struct 1
-#define in_struct_comment 2
-#define in_comment 3
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals (void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy (void );
-
-int yyget_debug (void );
-
-void yyset_debug (int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra (void );
-
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in (void );
-
-void yyset_in  (FILE * in_str  );
-
-FILE *yyget_out (void );
-
-void yyset_out  (FILE * out_str  );
-
-yy_size_t yyget_leng (void );
-
-char *yyget_text (void );
-
-int yyget_lineno (void );
-
-void yyset_lineno (int line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
-#endif
-
-#ifndef YY_NO_INPUT
-
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-    
-#line 65 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-
-  /* Do this on entry to yylex():  */
-  *yylval = 0;
-  if (lexer_toplevel_done)
-    {
-      BEGIN(INITIAL);
-      lexer_toplevel_done = 0;
-    }
-
-  /* Things we look for in skipping mode: */
-#line 1424 "gengtype-lex.c"
-
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state( );
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-		yy_current_state += YY_AT_BOL();
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 558 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_current_state != 557 );
-		yy_cp = (yy_last_accepting_cpos);
-		yy_current_state = (yy_last_accepting_state);
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-/* rule 1 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 76 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return TYPEDEF;
-}
-	YY_BREAK
-case 2:
-/* rule 2 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 80 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STRUCT;
-}
-	YY_BREAK
-case 3:
-/* rule 3 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 84 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return UNION;
-}
-	YY_BREAK
-case 4:
-/* rule 4 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 88 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STRUCT;
-}
-	YY_BREAK
-case 5:
-/* rule 5 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 92 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return EXTERN;
-}
-	YY_BREAK
-case 6:
-/* rule 6 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 96 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STATIC;
-}
-	YY_BREAK
-
-/* Parsing inside a struct, union or class declaration.  */
-
-case 7:
-YY_RULE_SETUP
-#line 104 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ BEGIN(in_struct_comment); }
-	YY_BREAK
-case 8:
-/* rule 8 can match eol */
-YY_RULE_SETUP
-#line 105 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 9:
-/* rule 9 can match eol */
-YY_RULE_SETUP
-#line 107 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ update_lineno (yytext, yyleng); }
-	YY_BREAK
-case 10:
-/* rule 10 can match eol */
-YY_RULE_SETUP
-#line 108 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 11:
-/* rule 11 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 110 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* don't care */
-	YY_BREAK
-case 12:
-/* rule 12 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-#line 112 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 13:
-/* rule 13 can match eol */
-#line 113 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 14:
-/* rule 14 can match eol */
-YY_RULE_SETUP
-#line 113 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-    *yylval = XDUPVAR (const char, yytext, yyleng, yyleng + 1);
-    return IGNORABLE_CXX_KEYWORD;
-}
-	YY_BREAK
-case 15:
-/* rule 15 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 3;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 117 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return GTY_TOKEN; }
-	YY_BREAK
-case 16:
-/* rule 16 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 118 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return UNION; }
-	YY_BREAK
-case 17:
-/* rule 17 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 6;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 119 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return STRUCT; }
-	YY_BREAK
-case 18:
-/* rule 18 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 120 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return STRUCT; }
-	YY_BREAK
-case 19:
-/* rule 19 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 7;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 121 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return TYPEDEF; }
-	YY_BREAK
-case 20:
-/* rule 20 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 122 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return ENUM; }
-	YY_BREAK
-case 21:
-/* rule 21 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 9;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 123 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return PTR_ALIAS; }
-	YY_BREAK
-case 22:
-/* rule 22 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 10;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 124 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return NESTED_PTR; }
-	YY_BREAK
-case 23:
-/* rule 23 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 125 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return USER_GTY; }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 126 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return NUM; }
-	YY_BREAK
-case 25:
-/* rule 25 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 127 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);
-  return PARAM_IS;
-}
-	YY_BREAK
-case 26:
-/* rule 26 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-#line 133 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 27:
-/* rule 27 can match eol */
-YY_RULE_SETUP
-#line 133 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  size_t len;
-
-  for (len = yyleng; ISSPACE (yytext[len-1]); len--)
-    ;
-
-  *yylval = XDUPVAR (const char, yytext, len, len+1);
-  update_lineno (yytext, yyleng);
-  return SCALAR;
-}
-	YY_BREAK
-case 28:
-/* rule 28 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 144 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);
-  return ID;
-}
-	YY_BREAK
-case 29:
-/* rule 29 can match eol */
-YY_RULE_SETUP
-#line 149 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);
-  return STRING;
-}
-	YY_BREAK
-/* This "terminal" avoids having to parse integer constant expressions.  */
-case 30:
-/* rule 30 can match eol */
-YY_RULE_SETUP
-#line 154 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);
-  return ARRAY;
-}
-	YY_BREAK
-case 31:
-/* rule 31 can match eol */
-YY_RULE_SETUP
-#line 158 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng);
-  return CHAR;
-}
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 163 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return ELLIPSIS; }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 164 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ return yytext[0]; }
-	YY_BREAK
-/* ignore pp-directives */
-case 34:
-/* rule 34 can match eol */
-YY_RULE_SETUP
-#line 167 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{lexer_line.line++;}
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 169 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, "unexpected character `%s'", yytext);
-}
-	YY_BREAK
-
-case 36:
-YY_RULE_SETUP
-#line 174 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ BEGIN(in_comment); }
-	YY_BREAK
-case 37:
-/* rule 37 can match eol */
-YY_RULE_SETUP
-#line 175 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 38:
-/* rule 38 can match eol */
-YY_RULE_SETUP
-#line 176 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 39:
-#line 178 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 40:
-/* rule 40 can match eol */
-#line 179 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 41:
-/* rule 41 can match eol */
-YY_RULE_SETUP
-#line 179 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 42:
-/* rule 42 can match eol */
-YY_RULE_SETUP
-#line 180 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ update_lineno (yytext, yyleng); }
-	YY_BREAK
-case 43:
-/* rule 43 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 181 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-
-case 44:
-/* rule 44 can match eol */
-YY_RULE_SETUP
-#line 184 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 45:
-#line 186 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 46:
-YY_RULE_SETUP
-#line 186 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 47:
-/* rule 47 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 187 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-
-case 48:
-YY_RULE_SETUP
-#line 190 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ BEGIN(INITIAL); } 
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 191 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{ BEGIN(in_struct); }
-	YY_BREAK
-case 50:
-#line 194 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-case 51:
-YY_RULE_SETUP
-#line 194 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, 
-		 "unterminated comment or string; unexpected EOF");
-}
-	YY_BREAK
-case 52:
-/* rule 52 can match eol */
-YY_RULE_SETUP
-#line 199 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 201 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
-#line 1911 "gengtype-lex.c"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(in_struct):
-case YY_STATE_EOF(in_struct_comment):
-case YY_STATE_EOF(in_comment):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_last_accepting_cpos);
-				yy_current_state = (yy_last_accepting_state);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap( ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			yy_size_t num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				yy_size_t new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-    
-	yy_current_state = (yy_start);
-	yy_current_state += YY_AT_BOL();
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 558 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 558 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 557);
-
-		return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return EOF;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
-	}
-
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer(b,file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
-
-	yyfree((void *) b  );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer(b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	yy_size_t num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-		num_to_alloc = 1;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer(b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	yy_size_t i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yy_fatal_error (yyconst char* msg )
-{
-    	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-yy_size_t yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
-
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
-{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
-{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-	return (void *) malloc( size );
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-}
-
-void yyfree (void * ptr )
-{
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 201 "/d/gcc-4.9.2/gcc-4.9.2/gcc/gengtype-lex.l"
-
-
-
-void
-yybegin (const char *fname)
-{
-  yyin = fopen (fname, "r");
-  if (yyin == NULL)
-    {
-      perror (fname);
-      exit (1);
-    }
-  lexer_line.file = input_file_by_name (fname);
-  lexer_line.line = 1;
-}
-
-void
-yyend (void)
-{
-  fclose (yyin);
-}
-
diff -rNu gcc-4.9.2/gcc/gimplify.c test/gcc-4.9.2/gcc/gimplify.c
--- gcc-4.9.2/gcc/gimplify.c	2014-08-15 15:40:37.000000000 +0800
+++ test/gcc-4.9.2/gcc/gimplify.c	2018-04-02 14:15:38.000000000 +0800
@@ -2105,11 +2105,20 @@
      that as the result value and in the postqueue operation.  */
   if (postfix)
     {
+      if (flag_disable_c11_self_mod_expr && !is_gimple_min_lval (lvalue))
+        {
+	   mark_addressable (lvalue);
+	   lvalue = build_fold_addr_expr_loc (input_location, lvalue);
+	   gimplify_expr (&lvalue, pre_p, post_p, is_gimple_val, fb_rvalue);
+	   lvalue = build_fold_indirect_ref_loc (input_location, lvalue);
+        }
+
       ret = gimplify_expr (&lhs, pre_p, post_p, is_gimple_val, fb_rvalue);
       if (ret == GS_ERROR)
-	return ret;
-
-      lhs = get_initialized_tmp_var (lhs, pre_p, NULL);
+        return ret;
+	  
+      if (!flag_disable_c11_self_mod_expr)
+        lhs = get_initialized_tmp_var (lhs, pre_p, NULL);
     }
 
   /* For POINTERs increment, use POINTER_PLUS_EXPR.  */
@@ -2117,18 +2126,25 @@
     {
       rhs = convert_to_ptrofftype_loc (loc, rhs);
       if (arith_code == MINUS_EXPR)
-	rhs = fold_build1_loc (loc, NEGATE_EXPR, TREE_TYPE (rhs), rhs);
-      t1 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (*expr_p), lhs, rhs);
+        rhs = fold_build1_loc (loc, NEGATE_EXPR, TREE_TYPE (rhs), rhs);
+		
+      if (flag_disable_c11_self_mod_expr)
+        arith_code = POINTER_PLUS_EXPR;
+      else
+        t1 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (*expr_p), lhs, rhs);
     }
-  else
+  else if (!flag_disable_c11_self_mod_expr)
     t1 = fold_convert (TREE_TYPE (*expr_p),
 		       fold_build2 (arith_code, arith_type,
 				    fold_convert (arith_type, lhs),
 				    fold_convert (arith_type, rhs)));
 
+  if (flag_disable_c11_self_mod_expr)
+    t1 = build2 (arith_code, TREE_TYPE (*expr_p), lhs, rhs);
+
   if (postfix)
     {
-      gimplify_assign (lvalue, t1, pre_p);
+      gimplify_assign (lvalue, t1, ((flag_disable_c11_self_mod_expr) ? orig_post_p : pre_p));
       gimplify_seq_add_seq (orig_post_p, post);
       *expr_p = lhs;
       return GS_ALL_DONE;
diff -rNu gcc-4.9.2/gcc/ifcvt.c test/gcc-4.9.2/gcc/ifcvt.c
--- gcc-4.9.2/gcc/ifcvt.c	2014-09-30 18:33:25.000000000 +0800
+++ test/gcc-4.9.2/gcc/ifcvt.c	2018-04-02 14:15:31.000000000 +0800
@@ -1473,8 +1473,8 @@
 	  || byte_vtrue != byte_vfalse
 	  || (SUBREG_PROMOTED_VAR_P (vtrue)
 	      != SUBREG_PROMOTED_VAR_P (vfalse))
-	  || (SUBREG_PROMOTED_UNSIGNED_P (vtrue)
-	      != SUBREG_PROMOTED_UNSIGNED_P (vfalse)))
+	  || (SUBREG_PROMOTED_GET (vtrue)
+	      != SUBREG_PROMOTED_GET (vfalse)))
 	return NULL_RTX;
 
       promoted_target = gen_reg_rtx (GET_MODE (reg_vtrue));
@@ -1488,7 +1488,7 @@
 
       target = gen_rtx_SUBREG (GET_MODE (vtrue), promoted_target, byte_vtrue);
       SUBREG_PROMOTED_VAR_P (target) = SUBREG_PROMOTED_VAR_P (vtrue);
-      SUBREG_PROMOTED_UNSIGNED_SET (target, SUBREG_PROMOTED_UNSIGNED_P (vtrue));
+      SUBREG_PROMOTED_SET (target, SUBREG_PROMOTED_GET (vtrue));
       emit_move_insn (x, target);
       return x;
     }
diff -rNu gcc-4.9.2/gcc/internal-fn.c test/gcc-4.9.2/gcc/internal-fn.c
--- gcc-4.9.2/gcc/internal-fn.c	2014-10-16 21:51:45.000000000 +0800
+++ test/gcc-4.9.2/gcc/internal-fn.c	2018-04-02 14:15:31.000000000 +0800
@@ -600,12 +600,12 @@
 	  if (GET_CODE (lopart0) == SUBREG)
 	    {
 	      SUBREG_PROMOTED_VAR_P (lopart0) = 1;
-	      SUBREG_PROMOTED_UNSIGNED_SET (lopart0, 0);
+	      SUBREG_PROMOTED_SET (lopart0, 0);
 	    }
 	  if (GET_CODE (lopart1) == SUBREG)
 	    {
 	      SUBREG_PROMOTED_VAR_P (lopart1) = 1;
-	      SUBREG_PROMOTED_UNSIGNED_SET (lopart1, 0);
+	      SUBREG_PROMOTED_SET (lopart1, 0);
 	    }
 	  tree halfstype = build_nonstandard_integer_type (hprec, 0);
 	  ops.op0 = make_tree (halfstype, lopart0);
diff -rNu gcc-4.9.2/gcc/lra-assigns.c test/gcc-4.9.2/gcc/lra-assigns.c
--- gcc-4.9.2/gcc/lra-assigns.c	2014-10-15 23:51:07.000000000 +0800
+++ test/gcc-4.9.2/gcc/lra-assigns.c	2018-04-02 14:15:32.000000000 +0800
@@ -218,15 +218,15 @@
       && ! bitmap_bit_p (&non_reload_pseudos, r1)
       && ! bitmap_bit_p (&non_reload_pseudos, r2))
     return diff;
-  if ((diff = (regno_assign_info[regno_assign_info[r2].first].freq
-	       - regno_assign_info[regno_assign_info[r1].first].freq)) != 0)
-    return diff;
   /* Allocate bigger pseudos first to avoid register file
      fragmentation.  */
   if ((diff
        = (ira_reg_class_max_nregs[cl2][lra_reg_info[r2].biggest_mode]
 	  - ira_reg_class_max_nregs[cl1][lra_reg_info[r1].biggest_mode])) != 0)
     return diff;
+  if ((diff = (regno_assign_info[regno_assign_info[r2].first].freq
+	       - regno_assign_info[regno_assign_info[r1].first].freq)) != 0)
+    return diff;
   /* Put pseudos from the thread nearby.  */
   if ((diff = regno_assign_info[r1].first - regno_assign_info[r2].first) != 0)
     return diff;
diff -rNu gcc-4.9.2/gcc/Makefile.in test/gcc-4.9.2/gcc/Makefile.in
--- gcc-4.9.2/gcc/Makefile.in	2014-10-16 21:50:42.000000000 +0800
+++ test/gcc-4.9.2/gcc/Makefile.in	2018-04-02 14:15:43.000000000 +0800
@@ -483,7 +483,7 @@
 TARGET_SYSTEM_ROOT_DEFINE = @TARGET_SYSTEM_ROOT_DEFINE@
 
 xmake_file=@xmake_file@
-tmake_file=@tmake_file@
+tmake_file=@tmake_file@ ./t-oe
 TM_ENDIAN_CONFIG=@TM_ENDIAN_CONFIG@
 TM_MULTILIB_CONFIG=@TM_MULTILIB_CONFIG@
 TM_MULTILIB_EXCEPTIONS_CONFIG=@TM_MULTILIB_EXCEPTIONS_CONFIG@
@@ -762,7 +762,7 @@
 # Native linker and preprocessor flags.  For x-fragment overrides.
 BUILD_LDFLAGS=@BUILD_LDFLAGS@
 BUILD_CPPFLAGS= -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
-		-I$(srcdir)/../include @INCINTL@ $(CPPINC) $(CPPFLAGS)
+		-I$(srcdir)/../include @INCINTL@ $(CPPINC) $(CPPFLAGS_FOR_BUILD)
 
 # Actual name to use when installing a native compiler.
 GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')
@@ -1316,6 +1316,7 @@
 	modulo-sched.o \
 	omega.o \
 	omp-low.o \
+	opt-array-offset.o \
 	optabs.o \
 	options-save.o \
 	opts-global.o \
@@ -1465,6 +1466,7 @@
 	vmsdbgout.o \
 	vtable-verify.o \
 	web.o \
+	widen-types.o \
 	xcoffout.o \
 	$(out_object_file) \
 	$(EXTRA_OBJS) \
@@ -1481,13 +1483,16 @@
 	opts.o opts-common.o options.o vec.o hooks.o common/common-targhooks.o \
 	hash-table.o file-find.o
 
+# Objects compiled from one C source file gcc-ar.c
+OBJS-gcc-ar = gcc-ar.o gcc-nm.o gcc-ranlib.o
+
 # This lists all host objects for the front ends.
 ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))
 
 ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \
   $(OBJS-libcommon-target) @TREEBROWSER@ main.o c-family/cppspec.o \
   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) $(GCOV_OBJS) $(GCOV_DUMP_OBJS) \
-  lto-wrapper.o
+  lto-wrapper.o $(OBJS-gcc-ar)
 
 # This lists all host object files, whether they are included in this
 # compilation or not.
@@ -2439,6 +2444,8 @@
 CFLAGS-gengtype-parse.o += -DGENERATOR_FILE
 build/gengtype-parse.o: $(BCONFIG_H)
 
+errors.o : $(CONFIG_H)
+
 gengtype-state.o build/gengtype-state.o: gengtype-state.c $(SYSTEM_H) \
   gengtype.h errors.h double-int.h version.h $(HASHTAB_H) $(OBSTACK_H) \
   $(XREGEX_H)
diff -rNu gcc-4.9.2/gcc/mkconfig.sh test/gcc-4.9.2/gcc/mkconfig.sh
--- gcc-4.9.2/gcc/mkconfig.sh	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/mkconfig.sh	2018-04-02 14:15:42.000000000 +0800
@@ -77,7 +77,7 @@
     if [ $# -ge 1 ]; then
 	echo '#ifdef IN_GCC' >> ${output}T
 	for file in "$@"; do
-	    if test x"$file" = x"defaults.h"; then
+	    if test x"$file" = x"./defaults.h" -o x"$file" = x"defaults.h"; then
 		postpone_defaults_h="yes"
 	    else
 		echo "# include \"$file\"" >> ${output}T
@@ -106,7 +106,7 @@
 
 # If we postponed including defaults.h, add the #include now.
 if test x"$postpone_defaults_h" = x"yes"; then
-    echo "# include \"defaults.h\"" >> ${output}T
+    echo "# include \"./defaults.h\"" >> ${output}T
 fi
 
 # Add multiple inclusion protection guard, part two.
diff -rNu gcc-4.9.2/gcc/optabs.c test/gcc-4.9.2/gcc/optabs.c
--- gcc-4.9.2/gcc/optabs.c	2014-08-14 17:32:17.000000000 +0800
+++ test/gcc-4.9.2/gcc/optabs.c	2018-04-02 14:15:31.000000000 +0800
@@ -349,7 +349,7 @@
      a promoted object differs from our extension.  */
   if (! no_extend
       || (GET_CODE (op) == SUBREG && SUBREG_PROMOTED_VAR_P (op)
-	  && SUBREG_PROMOTED_UNSIGNED_P (op) == unsignedp))
+	  && SUBREG_CHECK_PROMOTED_SIGN (op, unsignedp)))
     return convert_modes (mode, oldmode, op, unsignedp);
 
   /* If MODE is no wider than a single word, we return a lowpart or paradoxical
diff -rNu gcc-4.9.2/gcc/opt-array-offset.c test/gcc-4.9.2/gcc/opt-array-offset.c
--- gcc-4.9.2/gcc/opt-array-offset.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/opt-array-offset.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,305 @@
+/* Optimizing array element access
+   Copyright (C) 2011
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* This is a GIMPLE pass over basic block which coverts the stmts:
+        
+        a = b +/- c1;
+	c = a * c2;
+        
+   to:
+   
+        a = b * c2;
+        c = a +/- c1 * c2;
+
+   in effect expanding the multiplication across addition/substraction.
+
+   Motivating example:
+   Consider the following simple integer array access:
+   
+        a[i] = c;
+        a[i + 1] = c;
+
+   The following GIMPLE equivalent will be generated:
+
+        off_1 = i * 4;
+        a_i = a + off_1;
+	*a_i = c;
+
+	off_1 = i + 1;
+	off_2 = off_1 * 4;
+	a_i1 = a + off_2;
+	*a_i1 = c;
+
+   Notice that a_i1 could simply be a_i + 4. But the calcuation of i+1
+   is preventing CSE to perform. This pass will essentially convert the
+   second expr into:
+
+        off_1 = i * 4;
+        off_2 = off_1 + 4;
+        a_i1 = a + off_2;
+        ....
+
+   Thus allowing the previous index i calculation to be reuse. off_1 + 4
+   would also be combined into a_i if offset addressing mode is available.
+   This also have side effect of avoiding redundant sign extension on
+   i+1 for LP64 model where native integer size is different from pointer size.
+
+   The algorithm iterates through all the basic blocks looking for
+   the above pattern. Care is taken to make sure off_1 only
+   has the single use otherwise the transformation cannot be perform.
+*/
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#include "tree.h"
+#include "gimple-pretty-print.h"
+#include "basic-block.h"
+#include "tree-ssa-alias.h"
+#include "internal-fn.h"
+#include "gimple-expr.h"
+#include "is-a.h"
+#include "gimple.h"
+#include "gimple-iterator.h"
+#include "gimple-ssa.h"
+#include "tree-phinodes.h"
+#include "ssa-iterators.h"
+#include "tree-pass.h"
+#include "flags.h"
+
+#include "alloc-pool.h"
+#include "target.h"
+#include "tree-pretty-print.h"
+
+/*
+  We are looking for:
+  a = b +/- c1
+  c = a * c2 (stmt incoming)
+  d = &arr + c
+*/
+static bool
+is_candidate (gimple stmt)
+{
+  tree mul_result = gimple_get_lhs (stmt);
+  tree rhs1, rhs2;
+  gimple rhs1_stmt, use_stmt;
+  use_operand_p use_p;
+  imm_use_iterator imm_iter;
+
+  /* check for a * c2 */
+  if (gimple_assign_rhs_code (stmt) != MULT_EXPR)
+    return false;
+
+  rhs1 = gimple_assign_rhs1 (stmt);
+  rhs2 = gimple_assign_rhs2 (stmt);
+
+  if (TREE_CODE (rhs2) != INTEGER_CST)
+    return false;
+  
+  /* check for b + c1 */
+  if (TREE_CODE (rhs1) == SSA_NAME)
+    {
+      rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);
+      if (is_gimple_assign (rhs1_stmt))
+	{
+	  tree rhs1_2;
+	  tree plusminus_result;
+
+	  if (gimple_assign_rhs_code (rhs1_stmt) != PLUS_EXPR
+	      && gimple_assign_rhs_code (rhs1_stmt) != MINUS_EXPR)
+	    return false;
+
+	  rhs1_2 = gimple_assign_rhs2 (rhs1_stmt);
+	  if (TREE_CODE (rhs1_2) != INTEGER_CST)
+	    return false;
+
+	  /* make sure there are no other uses of a 
+	     e.g. if a is used as an indcution variable 
+	     we cannot modified it
+	  */
+	  plusminus_result = gimple_get_lhs (rhs1_stmt);
+	  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, plusminus_result)
+	    {
+	      use_stmt = USE_STMT (use_p);
+	      
+	      /* ignore PHI node */
+	      if (is_gimple_assign (use_stmt) &&
+		  (gimple_code (use_stmt) == GIMPLE_PHI))
+		continue;
+	      if (use_stmt != stmt)
+		return false;
+	    }
+
+#if 0
+	  if (gimple_bb(rhs1_stmt) != gimple_bb(stmt))
+	    return false;
+#endif
+        }
+      else
+	return false;
+    }
+  else
+    return false;
+
+  /* now look for uses of c that is a pointer use */
+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, mul_result)
+    {
+      enum tree_code use_code;
+
+      use_stmt = USE_STMT (use_p);
+      
+      if (is_gimple_debug (use_stmt))
+	continue;
+      
+      if (gimple_bb (use_stmt) != gimple_bb (stmt))
+	return false;
+
+      if (!is_gimple_assign (use_stmt))
+	return false;
+
+      use_code = gimple_assign_rhs_code (use_stmt);
+      if (use_code != POINTER_PLUS_EXPR)
+	return false;
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Found candidate:\n");
+      print_gimple_stmt (dump_file, rhs1_stmt, 0, TDF_SLIM);
+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
+      print_gimple_stmt (dump_file, use_stmt, 0, TDF_SLIM);
+    }
+
+  return true;
+}
+
+/* Do the actual transformation:
+  a = b + c1 ==> a = b * c2
+  c = a * c2 ==> c = a + c1*c2
+*/
+static bool
+expand_plusminus_mult (gimple stmt)
+{
+  tree c1, c2, mul_result;
+  gimple rhs1_stmt;
+
+  /* get c2 */
+  c2 = gimple_assign_rhs2 (stmt);
+
+  /* get c1 */
+  rhs1_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));
+  c1 = gimple_assign_rhs2 (rhs1_stmt);
+
+  /* form c1 * c2 */
+  mul_result = double_int_to_tree (TREE_TYPE(c2), 
+		      (tree_to_double_int (c1) * tree_to_double_int (c2)));
+
+  /* a = b + c1 ==> a = b * c2 */
+  gimple_assign_set_rhs2 (rhs1_stmt, c2);
+  gimple_assign_set_rhs_code (rhs1_stmt, MULT_EXPR);
+  update_stmt (rhs1_stmt);
+
+  /* c = a * c2 ==> c = a + c1*c2 */
+  gimple_assign_set_rhs2 (stmt, mul_result);
+  /* MINUS_EXPR has already been embedded into c1*c2 */
+  gimple_assign_set_rhs_code (stmt, PLUS_EXPR);
+  update_stmt (stmt);
+
+  return true;
+}
+
+static bool
+gate_opt_array_offset (void)
+{
+  return flag_opt_array_offset && optimize;
+}
+
+static unsigned int
+execute_opt_array_offset ()
+{
+  basic_block bb;
+
+  FOR_EACH_BB_FN (bb, cfun)
+    {
+      gimple_stmt_iterator gsi;
+
+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next(&gsi))
+      {
+        gimple stmt = gsi_stmt (gsi);
+	//tree lhs,rhs1,rhs2,rhs3;
+        //enum tree_code code;
+	  
+        /* only interested in assign statement */
+        if (is_gimple_assign (stmt))
+        {
+	   /* find stmts calculating array offset */
+	  if (is_candidate (stmt))
+	    /* convert stmt */
+	    expand_plusminus_mult(stmt);
+	    
+        }
+      }
+    }
+
+  return 0;
+}
+
+namespace {
+
+const pass_data pass_data_opt_array_offset =
+{
+  GIMPLE_PASS,				/* type */
+  "opt_array_offset",			/* name */
+  OPTGROUP_NONE,			/* optinfo_flags */
+  true,					/* has_gate */
+  true,					/* has_execute */
+  TV_NONE,				/* tv_id */
+  PROP_ssa,				/* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  ( TODO_verify_ssa
+  | TODO_verify_stmts
+  | TODO_update_ssa ),                 /* todo_flags_finish */
+};
+
+class pass_opt_array_offset : public gimple_opt_pass
+{
+public:
+  pass_opt_array_offset (gcc::context *ctxt)
+    : gimple_opt_pass (pass_data_opt_array_offset, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate () { return gate_opt_array_offset (); }
+  unsigned int execute () { return execute_opt_array_offset (); }
+
+}; // class pass_tracer
+
+} // anon namespace
+
+gimple_opt_pass *
+make_pass_opt_array_offset (gcc::context *ctxt)
+{
+  return new pass_opt_array_offset (ctxt);
+}
diff -rNu gcc-4.9.2/gcc/opts.c test/gcc-4.9.2/gcc/opts.c
--- gcc-4.9.2/gcc/opts.c	2014-10-16 21:49:11.000000000 +0800
+++ test/gcc-4.9.2/gcc/opts.c	2018-04-02 14:15:31.000000000 +0800
@@ -492,6 +492,9 @@
     { OPT_LEVELS_2_PLUS, OPT_falign_jumps, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_falign_labels, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_falign_functions, NULL, 1 },
+#ifdef ENABLE_EXTELIM 
+    { OPT_LEVELS_2_PLUS, OPT_fextelim, NULL, 1 },
+#endif
     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_CHEAP },
     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },
diff -rNu gcc-4.9.2/gcc/passes.def test/gcc-4.9.2/gcc/passes.def
--- gcc-4.9.2/gcc/passes.def	2014-01-18 01:50:10.000000000 +0800
+++ test/gcc-4.9.2/gcc/passes.def	2018-04-02 14:15:31.000000000 +0800
@@ -31,6 +31,7 @@
     backend might produce already lowered functions that are not processed
     by these passes.  */
   INSERT_PASSES_AFTER (all_lowering_passes)
+  NEXT_PASS (pass_widen_types_stmts);
   NEXT_PASS (pass_warn_unused_result);
   NEXT_PASS (pass_diagnose_omp_blocks);
   NEXT_PASS (pass_diagnose_tm_blocks);
@@ -53,6 +54,7 @@
   PUSH_INSERT_PASSES_WITHIN (pass_early_local_passes)
       NEXT_PASS (pass_fixup_cfg);
       NEXT_PASS (pass_init_datastructures);
+      NEXT_PASS (pass_widen_types_bbs);
 
       NEXT_PASS (pass_build_ssa);
       NEXT_PASS (pass_ubsan);
@@ -250,6 +252,7 @@
       NEXT_PASS (pass_phiopt);
       NEXT_PASS (pass_fold_builtins);
       NEXT_PASS (pass_optimize_widening_mul);
+      NEXT_PASS (pass_opt_array_offset);
       NEXT_PASS (pass_tail_calls);
       NEXT_PASS (pass_rename_ssa_copies);
       /* FIXME: If DCE is not run before checking for uninitialized uses,
@@ -350,6 +353,9 @@
       NEXT_PASS (pass_web);
       NEXT_PASS (pass_rtl_cprop);
       NEXT_PASS (pass_cse2);
+#ifdef ENABLE_EXTELIM
+      NEXT_PASS (pass_rtl_extelim);
+#endif
       NEXT_PASS (pass_rtl_dse1);
       NEXT_PASS (pass_rtl_fwprop_addr);
       NEXT_PASS (pass_inc_dec);
diff -rNu gcc-4.9.2/gcc/pass_manager.h test/gcc-4.9.2/gcc/pass_manager.h
--- gcc-4.9.2/gcc/pass_manager.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/pass_manager.h	2018-04-02 14:15:34.000000000 +0800
@@ -29,6 +29,7 @@
   DEF_PASS_LIST (all_lowering_passes) \
   DEF_PASS_LIST (all_small_ipa_passes) \
   DEF_PASS_LIST (all_regular_ipa_passes) \
+  DEF_PASS_LIST (all_late_ipa_passes) \
   DEF_PASS_LIST (all_passes)
 
 #define DEF_PASS_LIST(LIST) PASS_LIST_NO_##LIST,
diff -rNu gcc-4.9.2/gcc/rtlanal.c test/gcc-4.9.2/gcc/rtlanal.c
--- gcc-4.9.2/gcc/rtlanal.c	2014-03-26 15:38:30.000000000 +0800
+++ test/gcc-4.9.2/gcc/rtlanal.c	2018-04-02 14:15:31.000000000 +0800
@@ -670,7 +670,7 @@
     return true;
 
   if (GET_CODE (op) == SUBREG
-      && SUBREG_PROMOTED_UNSIGNED_P (op))
+      && SUBREG_PROMOTED_SIGN (op))
     return true;
 
   return false;
@@ -4299,7 +4299,7 @@
 	 been zero-extended, we know that at least the high-order bits
 	 are zero, though others might be too.  */
 
-      if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x) > 0)
+      if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x))
 	nonzero = GET_MODE_MASK (GET_MODE (x))
 		  & cached_nonzero_bits (SUBREG_REG (x), GET_MODE (x),
 					 known_x, known_mode, known_ret);
@@ -4609,7 +4609,7 @@
 	 and we are looking at it in a wider mode, we know that at least the
 	 high-order bits are known to be sign bit copies.  */
 
-      if (SUBREG_PROMOTED_VAR_P (x) && ! SUBREG_PROMOTED_UNSIGNED_P (x))
+      if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_SIGNED_P (x))
 	{
 	  num0 = cached_num_sign_bit_copies (SUBREG_REG (x), mode,
 					     known_x, known_mode, known_ret);
diff -rNu gcc-4.9.2/gcc/rtl.h test/gcc-4.9.2/gcc/rtl.h
--- gcc-4.9.2/gcc/rtl.h	2014-01-23 16:24:38.000000000 +0800
+++ test/gcc-4.9.2/gcc/rtl.h	2018-04-02 14:15:31.000000000 +0800
@@ -1390,29 +1390,75 @@
 #define SUBREG_PROMOTED_VAR_P(RTX)					\
   (RTL_FLAG_CHECK1 ("SUBREG_PROMOTED", (RTX), SUBREG)->in_struct)
 
-#define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)				\
-do {									\
-  rtx const _rtx = RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_UNSIGNED_SET",	\
-				    (RTX), SUBREG);			\
-  if ((VAL) < 0)							\
-    _rtx->volatil = 1;							\
-  else {								\
-    _rtx->volatil = 0;							\
-    _rtx->unchanging = (VAL);						\
-  }									\
-} while (0)
-
 /* Valid for subregs which are SUBREG_PROMOTED_VAR_P().  In that case
    this gives the necessary extensions:
-   0  - signed
-   1  - normal unsigned
+   0  - signed (SPR_SIGNED)
+   1  - normal unsigned (SPR_UNSIGNED)
+   2  - value is both sign and unsign extended for mode
+	(SPR_SIGNED_AND_UNSIGNED).
    -1 - pointer unsigned, which most often can be handled like unsigned
         extension, except for generating instructions where we need to
-	emit special code (ptr_extend insns) on some architectures.  */
+	emit special code (ptr_extend insns) on some architectures
+	(SPR_POINTER). */
 
+const int SRP_POINTER = -1;
+const int SRP_SIGNED = 0;
+const int SRP_UNSIGNED = 1;
+const int SRP_SIGNED_AND_UNSIGNED = 2;
+
+/* Sets promoted mode for SUBREG_PROMOTED_VAR_P().  */
+#define SUBREG_PROMOTED_SET(RTX, VAL)		                        \
+do {								        \
+  rtx const _rtx = RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_SET",		\
+                                    (RTX), SUBREG);			\
+  switch (VAL)								\
+  {									\
+    case SRP_POINTER:							\
+      _rtx->volatil = 0;						\
+      _rtx->unchanging = 0;						\
+      break;								\
+    case SRP_SIGNED:							\
+      _rtx->volatil = 0;						\
+      _rtx->unchanging = 1;						\
+      break;								\
+    case SRP_UNSIGNED:							\
+      _rtx->volatil = 1;						\
+      _rtx->unchanging = 0;						\
+      break;								\
+    case SRP_SIGNED_AND_UNSIGNED:					\
+      _rtx->volatil = 1;						\
+      _rtx->unchanging = 1;						\
+      break;								\
+  }									\
+} while (0)
+
+/* Gets the value stored in promoted mode for SUBREG_PROMOTED_VAR_P(),
+   including SRP_SIGNED_AND_UNSIGNED if promoted for
+   both signed and unsigned.  */
+#define SUBREG_PROMOTED_GET(RTX)	\
+  (2 * (RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_GET", (RTX), SUBREG)->volatil)\
+   + (RTX)->unchanging - 1)
+
+/* Returns sign of promoted mode for SUBREG_PROMOTED_VAR_P().  */
+#define SUBREG_PROMOTED_SIGN(RTX)	\
+  ((RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_SIGN", (RTX), SUBREG)->volatil) ? 1\
+   : (RTX)->unchanging - 1)
+
+/* Predicate to check if RTX of SUBREG_PROMOTED_VAR_P() is promoted
+   for SIGNED type.  */
+#define SUBREG_PROMOTED_SIGNED_P(RTX)	\
+  (RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_SIGNED_P", (RTX), SUBREG)->unchanging)
+
+/* Predicate to check if RTX of SUBREG_PROMOTED_VAR_P() is promoted
+   for UNSIGNED type.  */
 #define SUBREG_PROMOTED_UNSIGNED_P(RTX)	\
-  ((RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_UNSIGNED_P", (RTX), SUBREG)->volatil) \
-   ? -1 : (int) (RTX)->unchanging)
+  (RTL_FLAG_CHECK1 ("SUBREG_PROMOTED_UNSIGNED_P", (RTX), SUBREG)->volatil)
+
+/* Checks if RTX of SUBREG_PROMOTED_VAR_P() is promoted for given SIGN.  */
+#define SUBREG_CHECK_PROMOTED_SIGN(RTX, SIGN)	\
+((SIGN) == SRP_POINTER ? SUBREG_PROMOTED_GET (RTX) == SRP_POINTER	\
+ : (SIGN) == SRP_SIGNED ? SUBREG_PROMOTED_SIGNED_P (RTX)		\
+ : SUBREG_PROMOTED_UNSIGNED_P (RTX))
 
 /* True if the subreg was generated by LRA for reload insns.  Such
    subregs are valid only during LRA.  */
diff -rNu gcc-4.9.2/gcc/simplify-rtx.c test/gcc-4.9.2/gcc/simplify-rtx.c
--- gcc-4.9.2/gcc/simplify-rtx.c	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/simplify-rtx.c	2018-04-02 14:15:35.000000000 +0800
@@ -1335,7 +1335,7 @@
 	 target mode is the same as the variable's promotion.  */
       if (GET_CODE (op) == SUBREG
 	  && SUBREG_PROMOTED_VAR_P (op)
-	  && ! SUBREG_PROMOTED_UNSIGNED_P (op)
+	  && SUBREG_PROMOTED_SIGNED_P (op)
 	  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))
 	{
 	  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);
@@ -1402,7 +1402,7 @@
 	 target mode is the same as the variable's promotion.  */
       if (GET_CODE (op) == SUBREG
 	  && SUBREG_PROMOTED_VAR_P (op)
-	  && SUBREG_PROMOTED_UNSIGNED_P (op) > 0
+	  && SUBREG_PROMOTED_UNSIGNED_P (op)
 	  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))
 	{
 	  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);
@@ -5654,6 +5654,7 @@
       switch (GET_CODE (el))
 	{
 	case CONST_INT:
+        case SYMBOL_REF:
 	  for (i = 0;
 	       i < HOST_BITS_PER_WIDE_INT && i < elem_bitsize;
 	       i += value_bit)
@@ -5989,7 +5990,7 @@
 	{
 	  newx = gen_rtx_SUBREG (outermode, SUBREG_REG (op), final_offset);
 	  if (SUBREG_PROMOTED_VAR_P (op)
-	      && SUBREG_PROMOTED_UNSIGNED_P (op) >= 0
+	      && SUBREG_PROMOTED_SIGN (op) >= 0
 	      && GET_MODE_CLASS (outermode) == MODE_INT
 	      && IN_RANGE (GET_MODE_SIZE (outermode),
 			   GET_MODE_SIZE (innermode),
@@ -5997,8 +5998,7 @@
 	      && subreg_lowpart_p (newx))
 	    {
 	      SUBREG_PROMOTED_VAR_P (newx) = 1;
-	      SUBREG_PROMOTED_UNSIGNED_SET
-		(newx, SUBREG_PROMOTED_UNSIGNED_P (op));
+	      SUBREG_PROMOTED_SET (newx, SUBREG_PROMOTED_GET (op));
 	    }
 	  return newx;
 	}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/sms-1.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/sms-1.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/sms-1.c	2009-04-27 20:17:09.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/sms-1.c	2018-04-02 14:15:31.000000000 +0800
@@ -2,6 +2,7 @@
    due to not handling of subreg in the lhs that is fixed.  */
 /* { dg-do run } */
 /* { dg-options "-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -fdump-rtl-sms" } */
+/* { dg-additional-options "-fno-extelim" { target { powerpc*-*-* && lp64 } } } */
 
 
 #include <limits.h>
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/sms-6.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/sms-6.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/sms-6.c	2014-02-19 23:44:11.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/sms-6.c	2018-04-02 14:15:31.000000000 +0800
@@ -2,6 +2,7 @@
 /* { dg-require-effective-target size32plus } */
 /* { dg-options "-O2 -fmodulo-sched -fdump-rtl-sms --param sms-min-sc=1" } */
 /* { dg-options "-O2 -fmodulo-sched -fdump-rtl-sms --param sms-min-sc=1 -fmodulo-sched-allow-regmoves" { target powerpc*-*-* } } */
+/* { dg-additional-options "-fno-extelim" { target { powerpc*-*-* && lp64 } } } */
 
 extern void abort (void);
 
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/stack-usage-1.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/stack-usage-1.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/stack-usage-1.c	2013-12-31 15:05:35.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/stack-usage-1.c	2018-04-02 14:15:34.000000000 +0800
@@ -51,7 +51,7 @@
 #elif defined (__powerpc__) || defined (__PPC__) || defined (__ppc__) \
       || defined (__POWERPC__) || defined (PPC) || defined (_IBMR2)
 #  if defined (__ALTIVEC__)
-#    if defined (__APPLE__)
+#    if defined (__APPLE__) || defined (__APPLE_ALTIVEC__)
 #      define SIZE 204
 #    else
 #      define SIZE 220
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-10.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-10.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-10.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-10.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m) {
+
+		s += 2;
+		m += 2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-11.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-11.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-11.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-11.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-12.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-12.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-12.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-12.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-13.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-13.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-13.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-13.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+		m += 2;
+	}
+
+	baz(s, m, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-14.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-14.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-14.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-14.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+		m += 2;
+	}
+
+	baz(s, m, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-15.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-15.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-15.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-15.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *p, char *s);
+
+void foo(char *p, char *q, char *r, char *s)
+{
+        while (*p == *q && *p == *r && p < s) {
+
+		p += 2;
+		q += 2;
+		r += 2;
+	}
+
+	baz(p, s);
+}
+
+/* { dg-final { scan-assembler-times "addi" 0 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 3 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-16.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-16.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-16.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-16.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *p, char *s);
+
+void foo(char *p, char *q, char *r, char *s)
+{
+        while (*p == *q && *p == *r && p < s) {
+
+		p += 2;
+		q += 2;
+		r += 2;
+	}
+
+	baz(p, s);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 3 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-17.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-17.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-17.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-17.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *p, char *s);
+
+void foo(char *p, char *q, char *r, char *s)
+{
+        while (*p == *q && *p == *r && p < s) {
+
+		p += 2;
+		q += 3;
+		r += 7;
+	}
+
+	baz(p, s);
+}
+
+/* { dg-final { scan-assembler-times "addi" 0 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 3 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-18.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-18.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-18.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-18.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *p, char *s);
+
+void foo(char *p, char *q, char *r, char *s)
+{
+        while (*p == *q && *p == *r && p < s) {
+
+		p += 2;
+		q += 3;
+		r += 7;
+	}
+
+	baz(p, s);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 3 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-19.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-19.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-19.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-19.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,21 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *p, char *s);
+
+void foo(char *p, char *q, char *r, char *s)
+{
+        while (*p && *q && *r && *s &&
+               *p == *q && *p == *r && *p == *s &&
+               *q == *r && *q == *s &&
+               *r == *s) {
+
+		p += 1;
+		q += 1;
+		r += 1;
+		s += 1;
+	}
+}
+
+/* { dg-final { scan-assembler-times "addi" 0 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 4 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-1.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-1.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-1.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-1.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+		m += 2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-20.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-20.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-20.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-20.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,21 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *p, char *s);
+
+void foo(char *p, char *q, char *r, char *s)
+{
+        while (*p && *q && *r && *s &&
+               *p == *q && *p == *r && *p == *s &&
+               *q == *r && *q == *s &&
+               *r == *s) {
+
+		p += 1;
+		q += 1;
+		r += 1;
+		s += 1;
+	}
+}
+
+/* { dg-final { scan-assembler-times "addi" 0 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 4 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-21.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-21.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-21.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-21.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(int *s, int *m, int *end);
+
+void foo(int *s, int *m, int *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 1;
+		m += 1;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lwzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-22.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-22.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-22.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-22.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(int *s, int *m, int *end);
+
+void foo(int *s, int *m, int *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 1;
+		m += 1;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lwzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-23.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-23.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-23.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-23.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(int *s, int *m, int *end);
+
+void foo(int *s, int *m, int *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 3;
+		m += 3;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lwzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-24.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-24.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-24.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-24.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(int *s, int *m, int *end);
+
+void foo(int *s, int *m, int *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 3;
+		m += 3;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lwzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-25.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-25.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-25.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-25.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+		m += 2;
+
+		*s = 0;
+		*m = 0;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-26.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-26.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-26.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-26.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+		m += 2;
+
+		*s = 0;
+		*m = 0;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-27.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-27.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-27.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-27.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *scan, char *match, char *strend);
+
+void foo(char *scan, char *match, char *strend)
+{
+        while (*scan == *match && scan > strend) {
+
+		scan  += -2;
+		match += -2;
+
+		*scan = 0;
+		*match = 0;
+	}
+
+	baz(scan, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-28.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-28.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-28.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-28.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *scan, char *match, char *strend);
+
+void foo(char *scan, char *match, char *strend)
+{
+        while (*scan == *match && scan > strend) {
+
+		scan  += -2;
+		match += -2;
+
+		*scan = 0;
+		*match = 0;
+	}
+
+	baz(scan, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-29.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-29.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-29.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-29.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *strend);
+
+void foo(char *s, char *m, char *strend)
+{
+        while (*s == *m && s < strend) {
+
+		s += 2;
+		m -= 2;
+	}
+
+	baz(s, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-2.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-2.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-2.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-2.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 2;
+		m += 2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-30.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-30.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-30.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-30.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *strend);
+
+void foo(char *s, char *m, char *strend)
+{
+        while (*s == *m && s < strend) {
+
+		s += 2;
+		m -= 2;
+	}
+
+	baz(s, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-31.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-31.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-31.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-31.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *scan, char *match, char *strend);
+
+void foo(char *scan, char *match, char *strend)
+{
+        while (*scan == *match && scan < strend) {
+
+		scan  += 1;
+		match += 1;
+
+		*scan = 0;
+		*match = 0;
+	}
+
+	baz(scan, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-32.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-32.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-32.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-32.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *scan, char *match, char *strend);
+
+void foo(char *scan, char *match, char *strend)
+{
+        while (*scan == *match && scan < strend) {
+
+		scan  += 1;
+		match += 1;
+
+		*scan = 0;
+		*match = 0;
+	}
+
+	baz(scan, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-33.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-33.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-33.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-33.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,20 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *scan, char *match, char *strend);
+
+void foo(char *scan, char *match, char *strend)
+{
+        while (*scan == *match && scan > strend) {
+
+		scan  += -1;
+		match += -1;
+
+		*scan = 0;
+		*match = 0;
+	}
+
+	baz(scan, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-34.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-34.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-34.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-34.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *scan, char *match, char *strend);
+
+void foo(char *scan, char *match, char *strend)
+{
+        while (*scan == *match && scan > strend) {
+
+		scan  += -1;
+		match += -1;
+
+		*scan = 0;
+		*match = 0;
+	}
+
+	baz(scan, 0, strend);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stbu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-35.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-35.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-35.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-35.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void foo (char *p, char *q, const char *bound);
+
+void incrBytes(char *p, char *q, const char *bound)
+{
+	while (*p == *q && p < bound) {
+
+		p += 1;
+		*p = *p + 1;
+
+		q += 1;
+		*q = *q+ 1;
+
+	}
+
+	foo (p, 0, bound);
+}
+
+/* { dg-final { scan-assembler-times "addi" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-36.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-36.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-36.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-36.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void foo (char *p, char *q, const char *bound);
+
+void incrBytes(char *p, char *q, const char *bound)
+{
+	while (*p == *q && p < bound) {
+
+		p += 1;
+		*p = *p + 1;
+
+		q += 1;
+		*q = *q+ 1;
+
+	}
+
+	foo (p, 0, bound);
+}
+
+/* { dg-final { scan-assembler-times "addi" 3 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-37.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-37.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-37.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-37.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,29 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+struct rx {
+ char **startp;
+};
+
+extern int *foo();
+
+int **bar(void)
+{
+ int **sp;
+ int iterations, i;
+ struct rx *rx;
+
+ for (i = i; i <= iterations; i++) {
+
+   ++sp;
+   *sp = foo();
+
+   if (rx->startp[i])
+     gorp();
+ }
+
+ return sp;
+}
+
+/* { dg-final { scan-assembler-times "addi" 3 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stwu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-38.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-38.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-38.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-38.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,29 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+struct rx {
+ char **startp;
+};
+
+extern int *foo();
+
+int **bar(void)
+{
+ int **sp;
+ int iterations, i;
+ struct rx *rx;
+
+ for (i = i; i <= iterations; i++) {
+
+   ++sp;
+   *sp = foo();
+
+   if (rx->startp[i])
+     gorp();
+ }
+
+ return sp;
+}
+
+/* { dg-final { scan-assembler-times "addi" 3 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-39.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-39.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-39.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-39.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates -fno-builtin -fno-tree-loop-optimize" } */
+
+void *memset(void *b, int c, unsigned long len)
+{
+        unsigned long i;
+
+        for (i = 0; i < len; i++)
+                ((unsigned char *)b)[i] = c;
+
+        return b;
+}
+
+/* NOTE: We ought to get at-least one stwu - there is some vector related stuff that
+ *       we need to take into consideration under -fuse-load-updates. With plain
+ *       vanilla GCC, we do get one stwu, so we are actually degrading performance
+ *       by not taking the "vector stuff" into account. */
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-3.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-3.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-3.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-3.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 1;
+		m += 1;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-40.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-40.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-40.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-40.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates -fno-builtin -fno-tree-loop-optimize" } */
+
+void *memset(void *b, int c, unsigned long len)
+{
+        unsigned long i;
+
+        for (i = 0; i < len; i++)
+                ((unsigned char *)b)[i] = c;
+
+        return b;
+}
+
+/* NOTE: We ought to get at-least one stwu - there is some vector related stuff that
+ *       we need to take into consideration under -fuse-load-updates. With plain
+ *       vanilla GCC, we do get one stwu, so we are actually degrading performance
+ *       by not taking the "vector stuff" into account. */
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-4.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-4.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-4.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-4.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += 1;
+		m += 1;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-5.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-5.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-5.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-5.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += -1;
+		m += -1;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-6.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-6.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-6.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-6.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += -1;
+		m += -1;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-7.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-7.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-7.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-7.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += -2;
+		m += -2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-8.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-8.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-8.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-8.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,19 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m && s < end) {
+
+		s += -2;
+		m += -2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "addi" 1 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
+/* { dg-final { scan-assembler-times "stdu" 1 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-9.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-9.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-9.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/tree-ssa/fsl-use-load-updates-9.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fuse-load-updates" } */
+
+extern void baz(char *s, char *m, char *end);
+
+void foo(char *s, char *m, char *end)
+{
+        while (*s == *m) {
+
+		s += 2;
+		m += 2;
+	}
+
+	baz(s, 0, end);
+}
+
+/* { dg-final { scan-assembler-times "lbzu" 2 { target powerpc*-*-* } } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b-big-array.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b-big-array.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b-big-array.c	2011-12-09 23:21:08.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b-big-array.c	2018-04-02 14:15:31.000000000 +0800
@@ -3,7 +3,7 @@
 #include <stdarg.h>
 #include "tree-vect.h"
 
-#define N 128
+#define N 64
 signed char data_ch[N];
 
 volatile int y = 0;
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.dg/zero_sign_ext_test.c test/gcc-4.9.2/gcc/testsuite/gcc.dg/zero_sign_ext_test.c
--- gcc-4.9.2/gcc/testsuite/gcc.dg/zero_sign_ext_test.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.dg/zero_sign_ext_test.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,136 @@
+extern void abort (void);
+
+/* { dg-options "-O2" } */
+/* { dg-do run } */
+
+#define TYPE_MAX(type, sign)	\
+  ((!sign) ? ((1 << (sizeof (type) * 8 - 1)) - 1) :	\
+   ((1 << (sizeof (type) * 8)) - 1))
+#define TYPE_MIN(type, sign)	\
+  ((!sign) ? -(1 << (sizeof (type) * 8 - 1)) : 0)
+
+#define TEST_FN(NAME, ARG_TYPE, RET_TYPE, CAST_TYPE, VAL, VR_MIN, VR_MAX)\
+  __attribute__((noinline, noclone)) RET_TYPE				\
+      NAME (ARG_TYPE arg){						\
+      RET_TYPE ret = VAL;						\
+      if (arg + 1 < VR_MIN || arg + 1 > VR_MAX) return ret;		\
+      /* Value Range of arg at this point will be  [VR_min, VR_max].  */\
+      arg = arg + VAL;							\
+      ret = (CAST_TYPE)arg;						\
+      return arg;							\
+  }
+
+/* Signed to signed conversion with value in-range.  */
+TEST_FN (foo1, short, short, char, 1, TYPE_MIN (char, 0), TYPE_MAX (char, 0));
+TEST_FN (foo2, short, short, char, 1, TYPE_MIN (char, 0) + 1,\
+	TYPE_MAX (char, 0) - 1);
+
+/* Signed to signed conversion with value not in-range.  */
+TEST_FN (foo3, short, short, char, -1, TYPE_MIN (short, 0) + 1,  100);
+TEST_FN (foo4, short, short, char, 1, 12, TYPE_MAX (short, 0) + 1);
+
+/* Unsigned to unsigned conversion with value in-range.  */
+TEST_FN (foo5, unsigned short, unsigned short, unsigned char, 1,\
+	TYPE_MIN (char, 1) + 1, TYPE_MAX (char, 1) - 1);
+TEST_FN (foo6, unsigned short, unsigned short, unsigned char, 1,\
+	TYPE_MIN (char, 1), TYPE_MAX (char, 1));
+
+/* Unsigned to unsigned conversion with value not in-range.  */
+TEST_FN (foo7, unsigned short, unsigned short, unsigned char, 1,\
+	TYPE_MIN (short, 1) + 1, TYPE_MAX (short, 1) - 1);
+TEST_FN (foo8, unsigned short, unsigned short, unsigned char, 1,\
+	TYPE_MIN (short, 1), TYPE_MAX (short, 1));
+
+/* Signed to unsigned conversion with value range positive.  */
+TEST_FN (foo9, short, short, unsigned char, -1, 1,\
+	TYPE_MAX (char, 1) - 1);
+TEST_FN (foo10, short, short, unsigned char, 1, 0,\
+	TYPE_MAX (char, 1));
+
+/* Signed to unsigned conversion with value range negative.  */
+TEST_FN (foo11, short, short, unsigned char, 1,\
+	TYPE_MIN (char, 0) + 1, TYPE_MAX (char, 0) - 1);
+TEST_FN (foo12, short, short, unsigned char, 1,\
+	TYPE_MIN (char, 0), TYPE_MAX (char, 0));
+
+/* Unsigned to Signed conversion with value range in signed equiv range.  */
+TEST_FN (foo13, unsigned short, unsigned short, char, 1,\
+	TYPE_MIN (char, 1) + 1, TYPE_MAX (char, 0) - 1);
+TEST_FN (foo14, unsigned short, unsigned short, char, 1,\
+	TYPE_MIN (char, 1), TYPE_MAX (char, 0));
+
+/* Unsigned to Signed conversion with value range not-in signed range.  */
+TEST_FN (foo15, unsigned short, unsigned short, char, 1,\
+	TYPE_MIN (char, 1) + 1, TYPE_MAX (char, 1) - 1);
+TEST_FN (foo16, unsigned short, unsigned short, char, 1,\
+	TYPE_MIN (char, 1), TYPE_MAX (char, 1));
+
+int main ()
+{
+  /* Signed to signed conversion with value in-range.  */
+  /* arg + 1.  */
+  if (foo1 (-32) != -31)
+    abort ();
+  /* arg + 1.  */
+  if (foo2 (32) != 33)
+    abort ();
+
+  /* Signed to signed conversion with value not in-range.  */
+  /* arg - 1.  */
+  if (foo3 (-512) != -513)
+    abort ();
+  /* arg + 1.  */
+  if (foo4 (512) != 513)
+    abort ();
+
+  /* Unsigned to unsigned conversion with value in-range.  */
+  /* arg + 1.  */
+  if (foo5 (64) != 65)
+    abort ();
+  /* arg + 1.  */
+  if (foo6 (64) != 65)
+    abort ();
+
+  /* Unsigned to unsigned conversion with value not in-range.  */
+  /* arg + 1.  */
+  if (foo7 (512) != 513)
+    abort ();
+  /* arg + 1.  */
+  if (foo8 (512) != 513)
+    abort ();
+
+  /* Signed to unsigned conversion with value range positive.  */
+  /* arg - 1.  */
+  if (foo9 (2) != 1)
+    abort ();
+  /* arg + 1.  */
+  if (foo10 (2) != 3)
+    abort ();
+
+  /* Signed to unsigned conversion with value range negative.  */
+  /* arg + 1.  */
+  if (foo11 (-125) != -124)
+    abort ();
+  /* arg + 1.  */
+  if (foo12 (-125) != -124)
+    abort ();
+
+  /* Unsigned to Signed conversion with value range in signed equiv range.  */
+  /* arg + 1.  */
+  if (foo13 (125) != 126)
+    abort ();
+  /* arg + 1.  */
+  if (foo14 (125) != 126)
+    abort ();
+
+  /* Unsigned to Signed conversion with value range not-in signed range.  */
+  /* arg + 1.  */
+  if (foo15 (250) != 251)
+    abort ();
+  /* arg + 1.  */
+  if (foo16 (250) != 251)
+    abort ();
+
+  return 0;
+}
+
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-10.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-10.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-10.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-10.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvtlx" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc1(long a, void *p)           { return __builtin_altivec_lvtlx (a,p); }
+vsf  llx01(long a, vsf *p)          { return __builtin_vec_lvtlx (a,p); }
+vsf  llx02(long a, sf *p)           { return __builtin_vec_lvtlx (a,p); }
+vbi  llx03(long a, vbi *p)          { return __builtin_vec_lvtlx (a,p); }
+vsi  llx04(long a, vsi *p)          { return __builtin_vec_lvtlx (a,p); }
+vsi  llx05(long a, si *p)           { return __builtin_vec_lvtlx (a,p); }
+vui  llx06(long a, vui *p)          { return __builtin_vec_lvtlx (a,p); }
+vui  llx07(long a, ui *p)           { return __builtin_vec_lvtlx (a,p); }
+vbs  llx08(long a, vbs *p)          { return __builtin_vec_lvtlx (a,p); }
+vp   llx09(long a, vp *p)           { return __builtin_vec_lvtlx (a,p); }
+vss  llx10(long a, vss *p)          { return __builtin_vec_lvtlx (a,p); }
+vss  llx11(long a, ss *p)           { return __builtin_vec_lvtlx (a,p); }
+vus  llx12(long a, vus *p)          { return __builtin_vec_lvtlx (a,p); }
+vus  llx13(long a, us *p)           { return __builtin_vec_lvtlx (a,p); }
+vbc  llx14(long a, vbc *p)          { return __builtin_vec_lvtlx (a,p); }
+vsc  llx15(long a, vsc *p)          { return __builtin_vec_lvtlx (a,p); }
+vsc  llx16(long a, sc *p)           { return __builtin_vec_lvtlx (a,p); }
+vuc  llx17(long a, vuc *p)          { return __builtin_vec_lvtlx (a,p); }
+vuc  llx18(long a, uc *p)           { return __builtin_vec_lvtlx (a,p); }
+vsf  Dllx01(long a, vsf *p)         { return vec_lvtlx (a,p); }
+vsf  Dllx02(long a, sf *p)          { return vec_lvtlx (a,p); }
+vbi  Dllx03(long a, vbi *p)         { return vec_lvtlx (a,p); }
+vsi  Dllx04(long a, vsi *p)         { return vec_lvtlx (a,p); }
+vsi  Dllx05(long a, si *p)          { return vec_lvtlx (a,p); }
+vui  Dllx06(long a, vui *p)         { return vec_lvtlx (a,p); }
+vui  Dllx07(long a, ui *p)          { return vec_lvtlx (a,p); }
+vbs  Dllx08(long a, vbs *p)         { return vec_lvtlx (a,p); }
+vp   Dllx09(long a, vp *p)          { return vec_lvtlx (a,p); }
+vss  Dllx10(long a, vss *p)         { return vec_lvtlx (a,p); }
+vss  Dllx11(long a, ss *p)          { return vec_lvtlx (a,p); }
+vus  Dllx12(long a, vus *p)         { return vec_lvtlx (a,p); }
+vus  Dllx13(long a, us *p)          { return vec_lvtlx (a,p); }
+vbc  Dllx14(long a, vbc *p)         { return vec_lvtlx (a,p); }
+vsc  Dllx15(long a, vsc *p)         { return vec_lvtlx (a,p); }
+vsc  Dllx16(long a, sc *p)          { return vec_lvtlx (a,p); }
+vuc  Dllx17(long a, vuc *p)         { return vec_lvtlx (a,p); }
+vuc  Dllx18(long a, uc *p)          { return vec_lvtlx (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-11.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-11.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-11.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-11.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvtlxl" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc2(long a, void *p)           { return __builtin_altivec_lvtlxl (a,p); }
+vsf  llxl01(long a, vsf *p)         { return __builtin_vec_lvtlxl (a,p); }
+vsf  llxl02(long a, sf *p)          { return __builtin_vec_lvtlxl (a,p); }
+vbi  llxl03(long a, vbi *p)         { return __builtin_vec_lvtlxl (a,p); }
+vsi  llxl04(long a, vsi *p)         { return __builtin_vec_lvtlxl (a,p); }
+vsi  llxl05(long a, si *p)          { return __builtin_vec_lvtlxl (a,p); }
+vui  llxl06(long a, vui *p)         { return __builtin_vec_lvtlxl (a,p); }
+vui  llxl07(long a, ui *p)          { return __builtin_vec_lvtlxl (a,p); }
+vbs  llxl08(long a, vbs *p)         { return __builtin_vec_lvtlxl (a,p); }
+vp   llxl09(long a, vp *p)          { return __builtin_vec_lvtlxl (a,p); }
+vss  llxl10(long a, vss *p)         { return __builtin_vec_lvtlxl (a,p); }
+vss  llxl11(long a, ss *p)          { return __builtin_vec_lvtlxl (a,p); }
+vus  llxl12(long a, vus *p)         { return __builtin_vec_lvtlxl (a,p); }
+vus  llxl13(long a, us *p)          { return __builtin_vec_lvtlxl (a,p); }
+vbc  llxl14(long a, vbc *p)         { return __builtin_vec_lvtlxl (a,p); }
+vsc  llxl15(long a, vsc *p)         { return __builtin_vec_lvtlxl (a,p); }
+vsc  llxl16(long a, sc *p)          { return __builtin_vec_lvtlxl (a,p); }
+vuc  llxl17(long a, vuc *p)         { return __builtin_vec_lvtlxl (a,p); }
+vuc  llxl18(long a, uc *p)          { return __builtin_vec_lvtlxl (a,p); }
+vsf  Dllxl01(long a, vsf *p)        { return vec_lvtlxl (a,p); }
+vsf  Dllxl02(long a, sf *p)         { return vec_lvtlxl (a,p); }
+vbi  Dllxl03(long a, vbi *p)        { return vec_lvtlxl (a,p); }
+vsi  Dllxl04(long a, vsi *p)        { return vec_lvtlxl (a,p); }
+vsi  Dllxl05(long a, si *p)         { return vec_lvtlxl (a,p); }
+vui  Dllxl06(long a, vui *p)        { return vec_lvtlxl (a,p); }
+vui  Dllxl07(long a, ui *p)         { return vec_lvtlxl (a,p); }
+vbs  Dllxl08(long a, vbs *p)        { return vec_lvtlxl (a,p); }
+vp   Dllxl09(long a, vp *p)         { return vec_lvtlxl (a,p); }
+vss  Dllxl10(long a, vss *p)        { return vec_lvtlxl (a,p); }
+vss  Dllxl11(long a, ss *p)         { return vec_lvtlxl (a,p); }
+vus  Dllxl12(long a, vus *p)        { return vec_lvtlxl (a,p); }
+vus  Dllxl13(long a, us *p)         { return vec_lvtlxl (a,p); }
+vbc  Dllxl14(long a, vbc *p)        { return vec_lvtlxl (a,p); }
+vsc  Dllxl15(long a, vsc *p)        { return vec_lvtlxl (a,p); }
+vsc  Dllxl16(long a, sc *p)         { return vec_lvtlxl (a,p); }
+vuc  Dllxl17(long a, vuc *p)        { return vec_lvtlxl (a,p); }
+vuc  Dllxl18(long a, uc *p)         { return vec_lvtlxl (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-12.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-12.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-12.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-12.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvtrx" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc3(long a, void *p)           { return __builtin_altivec_lvtrx (a,p); }
+vsf  lrx01(long a, vsf *p)          { return __builtin_vec_lvtrx (a,p); }
+vsf  lrx02(long a, sf *p)           { return __builtin_vec_lvtrx (a,p); }
+vbi  lrx03(long a, vbi *p)          { return __builtin_vec_lvtrx (a,p); }
+vsi  lrx04(long a, vsi *p)          { return __builtin_vec_lvtrx (a,p); }
+vsi  lrx05(long a, si *p)           { return __builtin_vec_lvtrx (a,p); }
+vui  lrx06(long a, vui *p)          { return __builtin_vec_lvtrx (a,p); }
+vui  lrx07(long a, ui *p)           { return __builtin_vec_lvtrx (a,p); }
+vbs  lrx08(long a, vbs *p)          { return __builtin_vec_lvtrx (a,p); }
+vp   lrx09(long a, vp *p)           { return __builtin_vec_lvtrx (a,p); }
+vss  lrx10(long a, vss *p)          { return __builtin_vec_lvtrx (a,p); }
+vss  lrx11(long a, ss *p)           { return __builtin_vec_lvtrx (a,p); }
+vus  lrx12(long a, vus *p)          { return __builtin_vec_lvtrx (a,p); }
+vus  lrx13(long a, us *p)           { return __builtin_vec_lvtrx (a,p); }
+vbc  lrx14(long a, vbc *p)          { return __builtin_vec_lvtrx (a,p); }
+vsc  lrx15(long a, vsc *p)          { return __builtin_vec_lvtrx (a,p); }
+vsc  lrx16(long a, sc *p)           { return __builtin_vec_lvtrx (a,p); }
+vuc  lrx17(long a, vuc *p)          { return __builtin_vec_lvtrx (a,p); }
+vuc  lrx18(long a, uc *p)           { return __builtin_vec_lvtrx (a,p); }
+vsf  Dlrx01(long a, vsf *p)         { return vec_lvtrx (a,p); }
+vsf  Dlrx02(long a, sf *p)          { return vec_lvtrx (a,p); }
+vbi  Dlrx03(long a, vbi *p)         { return vec_lvtrx (a,p); }
+vsi  Dlrx04(long a, vsi *p)         { return vec_lvtrx (a,p); }
+vsi  Dlrx05(long a, si *p)          { return vec_lvtrx (a,p); }
+vui  Dlrx06(long a, vui *p)         { return vec_lvtrx (a,p); }
+vui  Dlrx07(long a, ui *p)          { return vec_lvtrx (a,p); }
+vbs  Dlrx08(long a, vbs *p)         { return vec_lvtrx (a,p); }
+vp   Dlrx09(long a, vp *p)          { return vec_lvtrx (a,p); }
+vss  Dlrx10(long a, vss *p)         { return vec_lvtrx (a,p); }
+vss  Dlrx11(long a, ss *p)          { return vec_lvtrx (a,p); }
+vus  Dlrx12(long a, vus *p)         { return vec_lvtrx (a,p); }
+vus  Dlrx13(long a, us *p)          { return vec_lvtrx (a,p); }
+vbc  Dlrx14(long a, vbc *p)         { return vec_lvtrx (a,p); }
+vsc  Dlrx15(long a, vsc *p)         { return vec_lvtrx (a,p); }
+vsc  Dlrx16(long a, sc *p)          { return vec_lvtrx (a,p); }
+vuc  Dlrx17(long a, vuc *p)         { return vec_lvtrx (a,p); }
+vuc  Dlrx18(long a, uc *p)          { return vec_lvtrx (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-13.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-13.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-13.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-13.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvtrxl" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc4(long a, void *p)           { return __builtin_altivec_lvtrxl (a,p); }
+vsf  lrxl01(long a, vsf *p)         { return __builtin_vec_lvtrxl (a,p); }
+vsf  lrxl02(long a, sf *p)          { return __builtin_vec_lvtrxl (a,p); }
+vbi  lrxl03(long a, vbi *p)         { return __builtin_vec_lvtrxl (a,p); }
+vsi  lrxl04(long a, vsi *p)         { return __builtin_vec_lvtrxl (a,p); }
+vsi  lrxl05(long a, si *p)          { return __builtin_vec_lvtrxl (a,p); }
+vui  lrxl06(long a, vui *p)         { return __builtin_vec_lvtrxl (a,p); }
+vui  lrxl07(long a, ui *p)          { return __builtin_vec_lvtrxl (a,p); }
+vbs  lrxl08(long a, vbs *p)         { return __builtin_vec_lvtrxl (a,p); }
+vp   lrxl09(long a, vp *p)          { return __builtin_vec_lvtrxl (a,p); }
+vss  lrxl10(long a, vss *p)         { return __builtin_vec_lvtrxl (a,p); }
+vss  lrxl11(long a, ss *p)          { return __builtin_vec_lvtrxl (a,p); }
+vus  lrxl12(long a, vus *p)         { return __builtin_vec_lvtrxl (a,p); }
+vus  lrxl13(long a, us *p)          { return __builtin_vec_lvtrxl (a,p); }
+vbc  lrxl14(long a, vbc *p)         { return __builtin_vec_lvtrxl (a,p); }
+vsc  lrxl15(long a, vsc *p)         { return __builtin_vec_lvtrxl (a,p); }
+vsc  lrxl16(long a, sc *p)          { return __builtin_vec_lvtrxl (a,p); }
+vuc  lrxl17(long a, vuc *p)         { return __builtin_vec_lvtrxl (a,p); }
+vuc  lrxl18(long a, uc *p)          { return __builtin_vec_lvtrxl (a,p); }
+vsf  Dlrxl01(long a, vsf *p)        { return vec_lvtrxl (a,p); }
+vsf  Dlrxl02(long a, sf *p)         { return vec_lvtrxl (a,p); }
+vbi  Dlrxl03(long a, vbi *p)        { return vec_lvtrxl (a,p); }
+vsi  Dlrxl04(long a, vsi *p)        { return vec_lvtrxl (a,p); }
+vsi  Dlrxl05(long a, si *p)         { return vec_lvtrxl (a,p); }
+vui  Dlrxl06(long a, vui *p)        { return vec_lvtrxl (a,p); }
+vui  Dlrxl07(long a, ui *p)         { return vec_lvtrxl (a,p); }
+vbs  Dlrxl08(long a, vbs *p)        { return vec_lvtrxl (a,p); }
+vp   Dlrxl09(long a, vp *p)         { return vec_lvtrxl (a,p); }
+vss  Dlrxl10(long a, vss *p)        { return vec_lvtrxl (a,p); }
+vss  Dlrxl11(long a, ss *p)         { return vec_lvtrxl (a,p); }
+vus  Dlrxl12(long a, vus *p)        { return vec_lvtrxl (a,p); }
+vus  Dlrxl13(long a, us *p)         { return vec_lvtrxl (a,p); }
+vbc  Dlrxl14(long a, vbc *p)        { return vec_lvtrxl (a,p); }
+vsc  Dlrxl15(long a, vsc *p)        { return vec_lvtrxl (a,p); }
+vsc  Dlrxl16(long a, sc *p)         { return vec_lvtrxl (a,p); }
+vuc  Dlrxl17(long a, vuc *p)        { return vec_lvtrxl (a,p); }
+vuc  Dlrxl18(long a, uc *p)         { return vec_lvtrxl (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-14.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-14.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-14.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-14.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvflx" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc1(vsc v, long a, void *p)    { __builtin_altivec_stvflx (v,a,p); }
+void slx01(vsf v, long a, vsf *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx02(vsf v, long a, sf *p)    { __builtin_vec_stvflx (v,a,p); }
+void slx03(vbi v, long a, vbi *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx04(vsi v, long a, vsi *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx05(vsi v, long a, si *p)    { __builtin_vec_stvflx (v,a,p); }
+void slx06(vui v, long a, vui *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx07(vui v, long a, ui *p)    { __builtin_vec_stvflx (v,a,p); }
+void slx08(vbs v, long a, vbs *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx09(vp v, long a, vp *p)     { __builtin_vec_stvflx (v,a,p); }
+void slx10(vss v, long a, vss *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx11(vss v, long a, ss *p)    { __builtin_vec_stvflx (v,a,p); }
+void slx12(vus v, long a, vus *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx13(vus v, long a, us *p)    { __builtin_vec_stvflx (v,a,p); }
+void slx14(vbc v, long a, vbc *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx15(vsc v, long a, vsc *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx16(vsc v, long a, sc *p)    { __builtin_vec_stvflx (v,a,p); }
+void slx17(vuc v, long a, vuc *p)   { __builtin_vec_stvflx (v,a,p); }
+void slx18(vuc v, long a, uc *p)    { __builtin_vec_stvflx (v,a,p); }
+void Dslx01(vsf v, long a, vsf *p)  { vec_stvflx (v,a,p); }
+void Dslx02(vsf v, long a, sf *p)   { vec_stvflx (v,a,p); }
+void Dslx03(vbi v, long a, vbi *p)  { vec_stvflx (v,a,p); }
+void Dslx04(vsi v, long a, vsi *p)  { vec_stvflx (v,a,p); }
+void Dslx05(vsi v, long a, si *p)   { vec_stvflx (v,a,p); }
+void Dslx06(vui v, long a, vui *p)  { vec_stvflx (v,a,p); }
+void Dslx07(vui v, long a, ui *p)   { vec_stvflx (v,a,p); }
+void Dslx08(vbs v, long a, vbs *p)  { vec_stvflx (v,a,p); }
+void Dslx09(vp v, long a, vp *p)    { vec_stvflx (v,a,p); }
+void Dslx10(vss v, long a, vss *p)  { vec_stvflx (v,a,p); }
+void Dslx11(vss v, long a, ss *p)   { vec_stvflx (v,a,p); }
+void Dslx12(vus v, long a, vus *p)  { vec_stvflx (v,a,p); }
+void Dslx13(vus v, long a, us *p)   { vec_stvflx (v,a,p); }
+void Dslx14(vbc v, long a, vbc *p)  { vec_stvflx (v,a,p); }
+void Dslx15(vsc v, long a, vsc *p)  { vec_stvflx (v,a,p); }
+void Dslx16(vsc v, long a, sc *p)   { vec_stvflx (v,a,p); }
+void Dslx17(vuc v, long a, vuc *p)  { vec_stvflx (v,a,p); }
+void Dslx18(vuc v, long a, uc *p)   { vec_stvflx (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-15.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-15.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-15.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-15.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvflxl" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc2(vsc v, long a, void *p)    { __builtin_altivec_stvflxl (v,a,p); }
+void slxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl02(vsf v, long a, sf *p)   { __builtin_vec_stvflxl (v,a,p); }
+void slxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl05(vsi v, long a, si *p)   { __builtin_vec_stvflxl (v,a,p); }
+void slxl06(vui v, long a, vui *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl07(vui v, long a, ui *p)   { __builtin_vec_stvflxl (v,a,p); }
+void slxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl09(vp v, long a, vp *p)    { __builtin_vec_stvflxl (v,a,p); }
+void slxl10(vss v, long a, vss *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl11(vss v, long a, ss *p)   { __builtin_vec_stvflxl (v,a,p); }
+void slxl12(vus v, long a, vus *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl13(vus v, long a, us *p)   { __builtin_vec_stvflxl (v,a,p); }
+void slxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl16(vsc v, long a, sc *p)   { __builtin_vec_stvflxl (v,a,p); }
+void slxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvflxl (v,a,p); }
+void slxl18(vuc v, long a, uc *p)   { __builtin_vec_stvflxl (v,a,p); }
+void Dslxl01(vsf v, long a, vsf *p) { vec_stvflxl (v,a,p); }
+void Dslxl02(vsf v, long a, sf *p)  { vec_stvflxl (v,a,p); }
+void Dslxl03(vbi v, long a, vbi *p) { vec_stvflxl (v,a,p); }
+void Dslxl04(vsi v, long a, vsi *p) { vec_stvflxl (v,a,p); }
+void Dslxl05(vsi v, long a, si *p)  { vec_stvflxl (v,a,p); }
+void Dslxl06(vui v, long a, vui *p) { vec_stvflxl (v,a,p); }
+void Dslxl07(vui v, long a, ui *p)  { vec_stvflxl (v,a,p); }
+void Dslxl08(vbs v, long a, vbs *p) { vec_stvflxl (v,a,p); }
+void Dslxl09(vp v, long a, vp *p)   { vec_stvflxl (v,a,p); }
+void Dslxl10(vss v, long a, vss *p) { vec_stvflxl (v,a,p); }
+void Dslxl11(vss v, long a, ss *p)  { vec_stvflxl (v,a,p); }
+void Dslxl12(vus v, long a, vus *p) { vec_stvflxl (v,a,p); }
+void Dslxl13(vus v, long a, us *p)  { vec_stvflxl (v,a,p); }
+void Dslxl14(vbc v, long a, vbc *p) { vec_stvflxl (v,a,p); }
+void Dslxl15(vsc v, long a, vsc *p) { vec_stvflxl (v,a,p); }
+void Dslxl16(vsc v, long a, sc *p)  { vec_stvflxl (v,a,p); }
+void Dslxl17(vuc v, long a, vuc *p) { vec_stvflxl (v,a,p); }
+void Dslxl18(vuc v, long a, uc *p)  { vec_stvflxl (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-16.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-16.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-16.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-16.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvfrx" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc3(vsc v, long a, void *p)    { __builtin_altivec_stvfrx (v,a,p); }
+void srx01(vsf v, long a, vsf *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx02(vsf v, long a, sf *p)    { __builtin_vec_stvfrx (v,a,p); }
+void srx03(vbi v, long a, vbi *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx04(vsi v, long a, vsi *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx05(vsi v, long a, si *p)    { __builtin_vec_stvfrx (v,a,p); }
+void srx06(vui v, long a, vui *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx07(vui v, long a, ui *p)    { __builtin_vec_stvfrx (v,a,p); }
+void srx08(vbs v, long a, vbs *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx09(vp v, long a, vp *p)     { __builtin_vec_stvfrx (v,a,p); }
+void srx10(vss v, long a, vss *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx11(vss v, long a, ss *p)    { __builtin_vec_stvfrx (v,a,p); }
+void srx12(vus v, long a, vus *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx13(vus v, long a, us *p)    { __builtin_vec_stvfrx (v,a,p); }
+void srx14(vbc v, long a, vbc *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx15(vsc v, long a, vsc *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx16(vsc v, long a, sc *p)    { __builtin_vec_stvfrx (v,a,p); }
+void srx17(vuc v, long a, vuc *p)   { __builtin_vec_stvfrx (v,a,p); }
+void srx18(vuc v, long a, uc *p)    { __builtin_vec_stvfrx (v,a,p); }
+void Dsrx01(vsf v, long a, vsf *p)  { vec_stvfrx (v,a,p); }
+void Dsrx02(vsf v, long a, sf *p)   { vec_stvfrx (v,a,p); }
+void Dsrx03(vbi v, long a, vbi *p)  { vec_stvfrx (v,a,p); }
+void Dsrx04(vsi v, long a, vsi *p)  { vec_stvfrx (v,a,p); }
+void Dsrx05(vsi v, long a, si *p)   { vec_stvfrx (v,a,p); }
+void Dsrx06(vui v, long a, vui *p)  { vec_stvfrx (v,a,p); }
+void Dsrx07(vui v, long a, ui *p)   { vec_stvfrx (v,a,p); }
+void Dsrx08(vbs v, long a, vbs *p)  { vec_stvfrx (v,a,p); }
+void Dsrx09(vp v, long a, vp *p)    { vec_stvfrx (v,a,p); }
+void Dsrx10(vss v, long a, vss *p)  { vec_stvfrx (v,a,p); }
+void Dsrx11(vss v, long a, ss *p)   { vec_stvfrx (v,a,p); }
+void Dsrx12(vus v, long a, vus *p)  { vec_stvfrx (v,a,p); }
+void Dsrx13(vus v, long a, us *p)   { vec_stvfrx (v,a,p); }
+void Dsrx14(vbc v, long a, vbc *p)  { vec_stvfrx (v,a,p); }
+void Dsrx15(vsc v, long a, vsc *p)  { vec_stvfrx (v,a,p); }
+void Dsrx16(vsc v, long a, sc *p)   { vec_stvfrx (v,a,p); }
+void Dsrx17(vuc v, long a, vuc *p)  { vec_stvfrx (v,a,p); }
+void Dsrx18(vuc v, long a, uc *p)   { vec_stvfrx (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-17.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-17.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-17.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-17.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvfrxl" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc4(vsc v, long a, void *p)    { __builtin_altivec_stvfrxl (v,a,p); }
+void srxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl02(vsf v, long a, sf *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void srxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl05(vsi v, long a, si *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void srxl06(vui v, long a, vui *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl07(vui v, long a, ui *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void srxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl09(vp v, long a, vp *p)    { __builtin_vec_stvfrxl (v,a,p); }
+void srxl10(vss v, long a, vss *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl11(vss v, long a, ss *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void srxl12(vus v, long a, vus *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl13(vus v, long a, us *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void srxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl16(vsc v, long a, sc *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void srxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvfrxl (v,a,p); }
+void srxl18(vuc v, long a, uc *p)   { __builtin_vec_stvfrxl (v,a,p); }
+void Dsrxl01(vsf v, long a, vsf *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl02(vsf v, long a, sf *p)  { vec_stvfrxl (v,a,p); }
+void Dsrxl03(vbi v, long a, vbi *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl04(vsi v, long a, vsi *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl05(vsi v, long a, si *p)  { vec_stvfrxl (v,a,p); }
+void Dsrxl06(vui v, long a, vui *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl07(vui v, long a, ui *p)  { vec_stvfrxl (v,a,p); }
+void Dsrxl08(vbs v, long a, vbs *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl09(vp v, long a, vp *p)   { vec_stvfrxl (v,a,p); }
+void Dsrxl10(vss v, long a, vss *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl11(vss v, long a, ss *p)  { vec_stvfrxl (v,a,p); }
+void Dsrxl12(vus v, long a, vus *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl13(vus v, long a, us *p)  { vec_stvfrxl (v,a,p); }
+void Dsrxl14(vbc v, long a, vbc *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl15(vsc v, long a, vsc *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl16(vsc v, long a, sc *p)  { vec_stvfrxl (v,a,p); }
+void Dsrxl17(vuc v, long a, vuc *p) { vec_stvfrxl (v,a,p); }
+void Dsrxl18(vuc v, long a, uc *p)  { vec_stvfrxl (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-18.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-18.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-18.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-18.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvswx" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  ls1(long a, void *p)           { return __builtin_altivec_lvswx (a,p); }
+vsf  ls01(long a, vsf *p)           { return __builtin_vec_lvswx (a,p); }
+vsf  ls02(long a, sf *p)            { return __builtin_vec_lvswx (a,p); }
+vbi  ls03(long a, vbi *p)           { return __builtin_vec_lvswx (a,p); }
+vsi  ls04(long a, vsi *p)           { return __builtin_vec_lvswx (a,p); }
+vsi  ls05(long a, si *p)            { return __builtin_vec_lvswx (a,p); }
+vui  ls06(long a, vui *p)           { return __builtin_vec_lvswx (a,p); }
+vui  ls07(long a, ui *p)            { return __builtin_vec_lvswx (a,p); }
+vbs  ls08(long a, vbs *p)           { return __builtin_vec_lvswx (a,p); }
+vp   ls09(long a, vp *p)            { return __builtin_vec_lvswx (a,p); }
+vss  ls10(long a, vss *p)           { return __builtin_vec_lvswx (a,p); }
+vss  ls11(long a, ss *p)            { return __builtin_vec_lvswx (a,p); }
+vus  ls12(long a, vus *p)           { return __builtin_vec_lvswx (a,p); }
+vus  ls13(long a, us *p)            { return __builtin_vec_lvswx (a,p); }
+vbc  ls14(long a, vbc *p)           { return __builtin_vec_lvswx (a,p); }
+vsc  ls15(long a, vsc *p)           { return __builtin_vec_lvswx (a,p); }
+vsc  ls16(long a, sc *p)            { return __builtin_vec_lvswx (a,p); }
+vuc  ls17(long a, vuc *p)           { return __builtin_vec_lvswx (a,p); }
+vuc  ls18(long a, uc *p)            { return __builtin_vec_lvswx (a,p); }
+vsf  Dls01(long a, vsf *p)          { return vec_lvswx (a,p); }
+vsf  Dls02(long a, sf *p)           { return vec_lvswx (a,p); }
+vbi  Dls03(long a, vbi *p)          { return vec_lvswx (a,p); }
+vsi  Dls04(long a, vsi *p)          { return vec_lvswx (a,p); }
+vsi  Dls05(long a, si *p)           { return vec_lvswx (a,p); }
+vui  Dls06(long a, vui *p)          { return vec_lvswx (a,p); }
+vui  Dls07(long a, ui *p)           { return vec_lvswx (a,p); }
+vbs  Dls08(long a, vbs *p)          { return vec_lvswx (a,p); }
+vp   Dls09(long a, vp *p)           { return vec_lvswx (a,p); }
+vss  Dls10(long a, vss *p)          { return vec_lvswx (a,p); }
+vss  Dls11(long a, ss *p)           { return vec_lvswx (a,p); }
+vus  Dls12(long a, vus *p)          { return vec_lvswx (a,p); }
+vus  Dls13(long a, us *p)           { return vec_lvswx (a,p); }
+vbc  Dls14(long a, vbc *p)          { return vec_lvswx (a,p); }
+vsc  Dls15(long a, vsc *p)          { return vec_lvswx (a,p); }
+vsc  Dls16(long a, sc *p)           { return vec_lvswx (a,p); }
+vuc  Dls17(long a, vuc *p)          { return vec_lvswx (a,p); }
+vuc  Dls18(long a, uc *p)           { return vec_lvswx (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-19.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-19.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-19.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-19.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvswxl" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  ls2l(long a, void *p)          { return __builtin_altivec_lvswxl (a,p); }
+vsf  lsl01(long a, vsf *p)          { return __builtin_vec_lvswxl (a,p); }
+vsf  lsl02(long a, sf *p)           { return __builtin_vec_lvswxl (a,p); }
+vbi  lsl03(long a, vbi *p)          { return __builtin_vec_lvswxl (a,p); }
+vsi  lsl04(long a, vsi *p)          { return __builtin_vec_lvswxl (a,p); }
+vsi  lsl05(long a, si *p)           { return __builtin_vec_lvswxl (a,p); }
+vui  lsl06(long a, vui *p)          { return __builtin_vec_lvswxl (a,p); }
+vui  lsl07(long a, ui *p)           { return __builtin_vec_lvswxl (a,p); }
+vbs  lsl08(long a, vbs *p)          { return __builtin_vec_lvswxl (a,p); }
+vp   lsl09(long a, vp *p)           { return __builtin_vec_lvswxl (a,p); }
+vss  lsl10(long a, vss *p)          { return __builtin_vec_lvswxl (a,p); }
+vss  lsl11(long a, ss *p)           { return __builtin_vec_lvswxl (a,p); }
+vus  lsl12(long a, vus *p)          { return __builtin_vec_lvswxl (a,p); }
+vus  lsl13(long a, us *p)           { return __builtin_vec_lvswxl (a,p); }
+vbc  lsl14(long a, vbc *p)          { return __builtin_vec_lvswxl (a,p); }
+vsc  lsl15(long a, vsc *p)          { return __builtin_vec_lvswxl (a,p); }
+vsc  lsl16(long a, sc *p)           { return __builtin_vec_lvswxl (a,p); }
+vuc  lsl17(long a, vuc *p)          { return __builtin_vec_lvswxl (a,p); }
+vuc  lsl18(long a, uc *p)           { return __builtin_vec_lvswxl (a,p); }
+vsf  Dlsl01(long a, vsf *p)         { return vec_lvswxl (a,p); }
+vsf  Dlsl02(long a, sf *p)          { return vec_lvswxl (a,p); }
+vbi  Dlsl03(long a, vbi *p)         { return vec_lvswxl (a,p); }
+vsi  Dlsl04(long a, vsi *p)         { return vec_lvswxl (a,p); }
+vsi  Dlsl05(long a, si *p)          { return vec_lvswxl (a,p); }
+vui  Dlsl06(long a, vui *p)         { return vec_lvswxl (a,p); }
+vui  Dlsl07(long a, ui *p)          { return vec_lvswxl (a,p); }
+vbs  Dlsl08(long a, vbs *p)         { return vec_lvswxl (a,p); }
+vp   Dlsl09(long a, vp *p)          { return vec_lvswxl (a,p); }
+vss  Dlsl10(long a, vss *p)         { return vec_lvswxl (a,p); }
+vss  Dlsl11(long a, ss *p)          { return vec_lvswxl (a,p); }
+vus  Dlsl12(long a, vus *p)         { return vec_lvswxl (a,p); }
+vus  Dlsl13(long a, us *p)          { return vec_lvswxl (a,p); }
+vbc  Dlsl14(long a, vbc *p)         { return vec_lvswxl (a,p); }
+vsc  Dlsl15(long a, vsc *p)         { return vec_lvswxl (a,p); }
+vsc  Dlsl16(long a, sc *p)          { return vec_lvswxl (a,p); }
+vuc  Dlsl17(long a, vuc *p)         { return vec_lvswxl (a,p); }
+vuc  Dlsl18(long a, uc *p)          { return vec_lvswxl (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-1.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-1.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-1.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-1.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "vabsdub" 7 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vuc  fa1b(vuc a, vuc b)             { return __builtin_altivec_vabsdub (a,b); }
+vuc  ad1(vuc a, vuc b)              { return __builtin_vec_absd (a,b); }
+vuc  ad2(vbc a, vuc b)              { return __builtin_vec_absd (a,b); }
+vuc  ad3(vuc a, vbc b)              { return __builtin_vec_absd (a,b); }
+vuc  Dad1(vuc a, vuc b)             { return vec_absd (a,b); }
+vuc  Dad2(vbc a, vuc b)             { return vec_absd (a,b); }
+vuc  Dad3(vuc a, vbc b)             { return vec_absd (a,b); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-20.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-20.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-20.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-20.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvswx" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void ss1(vsc v, long a, vsc *p)     { __builtin_altivec_stvswx (v,a,p); }
+void ssx01(vsf v, long a, vsf *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx02(vsf v, long a, sf  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx03(vbi v, long a, vbi *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx04(vsi v, long a, vsi *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx05(vsi v, long a, si  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx06(vui v, long a, vui *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx07(vui v, long a, ui  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx08(vbs v, long a, vbs *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx09(vp  v, long a, vp  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx10(vss v, long a, vss *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx11(vss v, long a, ss  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx12(vus v, long a, vus *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx13(vus v, long a, us  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx14(vbc v, long a, vbc *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx15(vsc v, long a, vsc *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx16(vsc v, long a, sc  *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx17(vuc v, long a, vuc *p)   { __builtin_vec_stvswx (v,a,p); }
+void ssx18(vuc v, long a, uc  *p)   { __builtin_vec_stvswx (v,a,p); }
+void Dssx01(vsf v, long a, vsf *p)  { vec_stvswx (v,a,p); }
+void Dssx02(vsf v, long a, sf  *p)  { vec_stvswx (v,a,p); }
+void Dssx03(vbi v, long a, vbi *p)  { vec_stvswx (v,a,p); }
+void Dssx04(vsi v, long a, vsi *p)  { vec_stvswx (v,a,p); }
+void Dssx05(vsi v, long a, si  *p)  { vec_stvswx (v,a,p); }
+void Dssx06(vui v, long a, vui *p)  { vec_stvswx (v,a,p); }
+void Dssx07(vui v, long a, ui  *p)  { vec_stvswx (v,a,p); }
+void Dssx08(vbs v, long a, vbs *p)  { vec_stvswx (v,a,p); }
+void Dssx09(vp  v, long a, vp  *p)  { vec_stvswx (v,a,p); }
+void Dssx10(vss v, long a, vss *p)  { vec_stvswx (v,a,p); }
+void Dssx11(vss v, long a, ss  *p)  { vec_stvswx (v,a,p); }
+void Dssx12(vus v, long a, vus *p)  { vec_stvswx (v,a,p); }
+void Dssx13(vus v, long a, us  *p)  { vec_stvswx (v,a,p); }
+void Dssx14(vbc v, long a, vbc *p)  { vec_stvswx (v,a,p); }
+void Dssx15(vsc v, long a, vsc *p)  { vec_stvswx (v,a,p); }
+void Dssx16(vsc v, long a, sc  *p)  { vec_stvswx (v,a,p); }
+void Dssx17(vuc v, long a, vuc *p)  { vec_stvswx (v,a,p); }
+void Dssx18(vuc v, long a, uc  *p)  { vec_stvswx (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-21.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-21.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-21.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-21.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvswxl" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void ss2l(vsc v, long a, vsc *p)    { __builtin_altivec_stvswxl (v,a,p); }
+void ssxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl02(vsf v, long a, sf  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl05(vsi v, long a, si  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl06(vui v, long a, vui *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl07(vui v, long a, ui  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl09(vp  v, long a, vp  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl10(vss v, long a, vss *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl11(vss v, long a, ss  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl12(vus v, long a, vus *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl13(vus v, long a, us  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl16(vsc v, long a, sc  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvswxl (v,a,p); }
+void ssxl18(vuc v, long a, uc  *p)  { __builtin_vec_stvswxl (v,a,p); }
+void Dssxl01(vsf v, long a, vsf *p) { vec_stvswxl (v,a,p); }
+void Dssxl02(vsf v, long a, sf  *p) { vec_stvswxl (v,a,p); }
+void Dssxl03(vbi v, long a, vbi *p) { vec_stvswxl (v,a,p); }
+void Dssxl04(vsi v, long a, vsi *p) { vec_stvswxl (v,a,p); }
+void Dssxl05(vsi v, long a, si  *p) { vec_stvswxl (v,a,p); }
+void Dssxl06(vui v, long a, vui *p) { vec_stvswxl (v,a,p); }
+void Dssxl07(vui v, long a, ui  *p) { vec_stvswxl (v,a,p); }
+void Dssxl08(vbs v, long a, vbs *p) { vec_stvswxl (v,a,p); }
+void Dssxl09(vp  v, long a, vp  *p) { vec_stvswxl (v,a,p); }
+void Dssxl10(vss v, long a, vss *p) { vec_stvswxl (v,a,p); }
+void Dssxl11(vss v, long a, ss  *p) { vec_stvswxl (v,a,p); }
+void Dssxl12(vus v, long a, vus *p) { vec_stvswxl (v,a,p); }
+void Dssxl13(vus v, long a, us  *p) { vec_stvswxl (v,a,p); }
+void Dssxl14(vbc v, long a, vbc *p) { vec_stvswxl (v,a,p); }
+void Dssxl15(vsc v, long a, vsc *p) { vec_stvswxl (v,a,p); }
+void Dssxl16(vsc v, long a, sc  *p) { vec_stvswxl (v,a,p); }
+void Dssxl17(vuc v, long a, vuc *p) { vec_stvswxl (v,a,p); }
+void Dssxl18(vuc v, long a, uc  *p) { vec_stvswxl (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-22.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-22.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-22.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-22.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvsm" 37 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lsm(long a, void *p)           { return __builtin_altivec_lvsm (a,p); }
+vsf  lm01(long a, vsf *p)           { return __builtin_vec_lvsm (a,p); }
+vsf  lm02(long a, sf *p)            { return __builtin_vec_lvsm (a,p); }
+vbi  lm03(long a, vbi *p)           { return __builtin_vec_lvsm (a,p); }
+vsi  lm04(long a, vsi *p)           { return __builtin_vec_lvsm (a,p); }
+vsi  lm05(long a, si *p)            { return __builtin_vec_lvsm (a,p); }
+vui  lm06(long a, vui *p)           { return __builtin_vec_lvsm (a,p); }
+vui  lm07(long a, ui *p)            { return __builtin_vec_lvsm (a,p); }
+vbs  lm08(long a, vbs *p)           { return __builtin_vec_lvsm (a,p); }
+vp   lm09(long a, vp *p)            { return __builtin_vec_lvsm (a,p); }
+vss  lm10(long a, vss *p)           { return __builtin_vec_lvsm (a,p); }
+vss  lm11(long a, ss *p)            { return __builtin_vec_lvsm (a,p); }
+vus  lm12(long a, vus *p)           { return __builtin_vec_lvsm (a,p); }
+vus  lm13(long a, us *p)            { return __builtin_vec_lvsm (a,p); }
+vbc  lm14(long a, vbc *p)           { return __builtin_vec_lvsm (a,p); }
+vsc  lm15(long a, vsc *p)           { return __builtin_vec_lvsm (a,p); }
+vsc  lm16(long a, sc *p)            { return __builtin_vec_lvsm (a,p); }
+vuc  lm17(long a, vuc *p)           { return __builtin_vec_lvsm (a,p); }
+vuc  lm18(long a, uc *p)            { return __builtin_vec_lvsm (a,p); }
+vsf  Dlm01(long a, vsf *p)          { return vec_lvsm (a,p); }
+vsf  Dlm02(long a, sf *p)           { return vec_lvsm (a,p); }
+vbi  Dlm03(long a, vbi *p)          { return vec_lvsm (a,p); }
+vsi  Dlm04(long a, vsi *p)          { return vec_lvsm (a,p); }
+vsi  Dlm05(long a, si *p)           { return vec_lvsm (a,p); }
+vui  Dlm06(long a, vui *p)          { return vec_lvsm (a,p); }
+vui  Dlm07(long a, ui *p)           { return vec_lvsm (a,p); }
+vbs  Dlm08(long a, vbs *p)          { return vec_lvsm (a,p); }
+vp   Dlm09(long a, vp *p)           { return vec_lvsm (a,p); }
+vss  Dlm10(long a, vss *p)          { return vec_lvsm (a,p); }
+vss  Dlm11(long a, ss *p)           { return vec_lvsm (a,p); }
+vus  Dlm12(long a, vus *p)          { return vec_lvsm (a,p); }
+vus  Dlm13(long a, us *p)           { return vec_lvsm (a,p); }
+vbc  Dlm14(long a, vbc *p)          { return vec_lvsm (a,p); }
+vsc  Dlm15(long a, vsc *p)          { return vec_lvsm (a,p); }
+vsc  Dlm16(long a, sc *p)           { return vec_lvsm (a,p); }
+vuc  Dlm17(long a, vuc *p)          { return vec_lvsm (a,p); }
+vuc  Dlm18(long a, uc *p)           { return vec_lvsm (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-2.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-2.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-2.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-2.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "vabsduh" 7 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vus  fa2h(vus a, vus b)             { return __builtin_altivec_vabsduh (a,b); }
+vus  ad4(vus a, vus b)              { return __builtin_vec_absd (a,b); }
+vus  ad5(vbs a, vus b)              { return __builtin_vec_absd (a,b); }
+vus  ad6(vus a, vbs b)              { return __builtin_vec_absd (a,b); }
+vus  Dad4(vus a, vus b)             { return vec_absd (a,b); }
+vus  Dad5(vbs a, vus b)             { return vec_absd (a,b); }
+vus  Dad6(vus a, vbs b)             { return vec_absd (a,b); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-3.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-3.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-3.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-3.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "vabsduw" 7 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vui  fa3w(vui a, vui b)             { return __builtin_altivec_vabsduw (a,b); }
+vui  ad7(vui a, vui b)              { return __builtin_vec_absd (a,b); }
+vui  ad8(vbi a, vui b)              { return __builtin_vec_absd (a,b); }
+vui  ad9(vui a, vbi b)              { return __builtin_vec_absd (a,b); }
+vui  Dad7(vui a, vui b)             { return vec_absd (a,b); }
+vui  Dad8(vbi a, vui b)             { return vec_absd (a,b); }
+vui  Dad9(vui a, vbi b)             { return vec_absd (a,b); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-4.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-4.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-4.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-4.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,34 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvexbx" 5 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  le1b(long a, void *p)          { return __builtin_altivec_lvexbx (a,p); }
+vsc  leb1(long a, sc *p)            { return __builtin_vec_lvexbx (a,p); }
+vuc  leb2(long a, uc *p)            { return __builtin_vec_lvexbx (a,p); }
+vsc  Dleb1(long a, sc *p)           { return vec_lvexbx (a,p); }
+vuc  Dleb2(long a, uc *p)           { return vec_lvexbx (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-5.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-5.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-5.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-5.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,34 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvexhx" 5 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vss  le2h(long a, void *p)          { return __builtin_altivec_lvexhx (a,p); }
+vss  leh1(long a, ss *p)            { return __builtin_vec_lvexhx (a,p); }
+vus  leh2(long a, us *p)            { return __builtin_vec_lvexhx (a,p); }
+vss  Dleh1(long a, ss *p)           { return vec_lvexhx (a,p); }
+vus  Dleh2(long a, us *p)           { return vec_lvexhx (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-6.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-6.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-6.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-6.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,40 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "lvexwx" 11 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsi  le3w(long a, void *p)          { return __builtin_altivec_lvexwx (a,p); }
+vsf  lew1(long a, sf *p)            { return __builtin_vec_lvexwx (a,p); }
+vsi  lew2(long a, si *p)            { return __builtin_vec_lvexwx (a,p); }
+vui  lew3(long a, ui *p)            { return __builtin_vec_lvexwx (a,p); }
+vsi  lew4(long a, sl *p)            { return __builtin_vec_lvexwx (a,p); }
+vui  lew5(long a, ul *p)            { return __builtin_vec_lvexwx (a,p); }
+vsf  Dlew1(long a, sf *p)           { return vec_lvexwx (a,p); }
+vsi  Dlew2(long a, si *p)           { return vec_lvexwx (a,p); }
+vui  Dlew3(long a, ui *p)           { return vec_lvexwx (a,p); }
+vsi  Dlew4(long a, sl *p)           { return vec_lvexwx (a,p); }
+vui  Dlew5(long a, ul *p)           { return vec_lvexwx (a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-7.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-7.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-7.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-7.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvexbx" 13 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void se1b(vsc v, long a, vsc *p)    { __builtin_altivec_stvexbx (v,a,p); }
+void seb1(vsc v, long a, sc *p)     { __builtin_vec_stvexbx (v,a,p); }
+void seb2(vuc v, long a, uc *p)     { __builtin_vec_stvexbx (v,a,p); }
+void seb3(vbc v, long a, sc *p)     { __builtin_vec_stvexbx (v,a,p); }
+void seb4(vbc v, long a, uc *p)     { __builtin_vec_stvexbx (v,a,p); }
+void seb5(vsc v, long a, void *p)   { __builtin_vec_stvexbx (v,a,p); }
+void seb6(vuc v, long a, void *p)   { __builtin_vec_stvexbx (v,a,p); }
+void Dseb1(vsc v, long a, sc *p)    { vec_stvexbx (v,a,p); }
+void Dseb2(vuc v, long a, uc *p)    { vec_stvexbx (v,a,p); }
+void Dseb3(vbc v, long a, sc *p)    { vec_stvexbx (v,a,p); }
+void Dseb4(vbc v, long a, uc *p)    { vec_stvexbx (v,a,p); }
+void Dseb5(vsc v, long a, void *p)  { vec_stvexbx (v,a,p); }
+void Dseb6(vuc v, long a, void *p)  { vec_stvexbx (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-8.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-8.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-8.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-8.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvexhx" 13 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void se2h(vss v, long a, vss *p)    { __builtin_altivec_stvexhx (v,a,p); }
+void seh1(vss v, long a, ss *p)     { __builtin_vec_stvexhx (v,a,p); }
+void seh2(vus v, long a, us *p)     { __builtin_vec_stvexhx (v,a,p); }
+void seh3(vbs v, long a, ss *p)     { __builtin_vec_stvexhx (v,a,p); }
+void seh4(vbs v, long a, us *p)     { __builtin_vec_stvexhx (v,a,p); }
+void seh5(vss v, long a, void *p)   { __builtin_vec_stvexhx (v,a,p); }
+void seh6(vus v, long a, void *p)   { __builtin_vec_stvexhx (v,a,p); }
+void Dseh1(vss v, long a, ss *p)    { vec_stvexhx (v,a,p); }
+void Dseh2(vus v, long a, us *p)    { vec_stvexhx (v,a,p); }
+void Dseh3(vbs v, long a, ss *p)    { vec_stvexhx (v,a,p); }
+void Dseh4(vbs v, long a, us *p)    { vec_stvexhx (v,a,p); }
+void Dseh5(vss v, long a, void *p)  { vec_stvexhx (v,a,p); }
+void Dseh6(vus v, long a, void *p)  { vec_stvexhx (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-9.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-9.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-9.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/altivec2_builtin-9.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,46 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -maltivec2" } */
+/* { dg-final { scan-assembler-times "stvexwx" 17 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void se3w(vsi v, long a, vsi *p)    { __builtin_altivec_stvexwx (v,a,p); }
+void sew1(vsf v, long a, sf *p)     { __builtin_vec_stvexwx (v,a,p); }
+void sew2(vsi v, long a, si *p)     { __builtin_vec_stvexwx (v,a,p); }
+void sew3(vui v, long a, ui *p)     { __builtin_vec_stvexwx (v,a,p); }
+void sew4(vbi v, long a, si *p)     { __builtin_vec_stvexwx (v,a,p); }
+void sew5(vbi v, long a, ui *p)     { __builtin_vec_stvexwx (v,a,p); }
+void sew6(vsf v, long a, void *p)   { __builtin_vec_stvexwx (v,a,p); }
+void sew7(vsi v, long a, void *p)   { __builtin_vec_stvexwx (v,a,p); }
+void sew8(vui v, long a, void *p)   { __builtin_vec_stvexwx (v,a,p); }
+void Dsew1(vsf v, long a, sf *p)    { vec_stvexwx (v,a,p); }
+void Dsew2(vsi v, long a, si *p)    { vec_stvexwx (v,a,p); }
+void Dsew3(vui v, long a, ui *p)    { vec_stvexwx (v,a,p); }
+void Dsew4(vbi v, long a, si *p)    { vec_stvexwx (v,a,p); }
+void Dsew5(vbi v, long a, ui *p)    { vec_stvexwx (v,a,p); }
+void Dsew6(vsf v, long a, void *p)  { vec_stvexwx (v,a,p); }
+void Dsew7(vsi v, long a, void *p)  { vec_stvexwx (v,a,p); }
+void Dsew8(vui v, long a, void *p)  { vec_stvexwx (v,a,p); }
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,75 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-mcpu=e5500" } */
+
+#include "builtin-isel.h"
+
+/* Equality comparisons.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64eq
+
+SIGNED64_PROTO
+{
+  L = ISEL_BUILTIN (x, y, a, b);
+  U = ISEL_BUILTIN (x, y, (unsigned long) a, (unsigned long) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+  L = ISEL_BUILTIN (p, q, a, b);
+  /* Equality checks explicitly permit unsigned comparison operands.  */
+  L = ISEL_BUILTIN ((unsigned long) x, (unsigned long) y, a, b);
+  r = ISEL_BUILTIN ((unsigned long) x, (unsigned long) y, p, q);
+}
+
+/* less-than, greater-than.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64lt
+
+SIGNED64_PROTO
+{
+  L = ISEL_BUILTIN (x, y, a, b);
+  U = ISEL_BUILTIN (x, y, (unsigned long) a, (unsigned long) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64gt
+
+SIGNED64_PROTO
+{
+  L = ISEL_BUILTIN (x, y, a, b);
+  U = ISEL_BUILTIN (x, y, (unsigned long) a, (unsigned long) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+}
+
+/* Unsigned variants.  These permit unsigned and pointer operands for
+   comparison only.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64ltu
+
+UNSIGNED64_PROTO
+{
+  L = ISEL_BUILTIN (x, y, a, b);
+  U = ISEL_BUILTIN (x, y, (unsigned long) a, (unsigned long) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+  L = ISEL_BUILTIN (p, q, a, b);
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64gtu
+
+UNSIGNED64_PROTO
+{
+  L = ISEL_BUILTIN (x, y, a, b);
+  U = ISEL_BUILTIN (x, y, (unsigned long) a, (unsigned long) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+  L = ISEL_BUILTIN (p, q, a, b);
+}
+
+/* Don't use bare isel, as that'll match function names and the like.  */
+/* { dg-final { scan-assembler-times "isel " 25 } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64-errors.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64-errors.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64-errors.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel64-errors.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,110 @@
+/* Test rejection of invalid parameter combinations in isel builtins.  */
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-mcpu=e5500" } */
+
+#include "builtin-isel.h"
+
+
+/* Equality comparisons.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64eq
+
+SIGNED64_PROTO
+{
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((unsigned long) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (unsigned long) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((long *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (long *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned long) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned long) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (long *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (long *) q); /* { dg-error "isel intrinsic" } */
+}
+
+/* less-than, greater-than.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64lt
+
+SIGNED64_PROTO
+{
+  /* Unsigned comparison should be done with the *u variants.  */
+  ISEL_BUILTIN ((unsigned long) x, (unsigned long) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* So should pointer comparison.  */
+  ISEL_BUILTIN (p, q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((unsigned long) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (unsigned long) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((long *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (long *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned long) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned long) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (long *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (long *) q); /* { dg-error "isel intrinsic" } */
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64gt
+
+SIGNED64_PROTO
+{
+  /* Unsigned comparison should be done with the *u variants.  */
+  ISEL_BUILTIN ((unsigned long) x, (unsigned long) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* So should pointer comparison.  */
+  ISEL_BUILTIN (p, q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((unsigned long) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (unsigned long) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((long *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (long *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned long) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned long) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (long *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (long *) q); /* { dg-error "isel intrinsic" } */
+}
+
+/* Unsigned variants.  These permit unsigned and pointer operands for
+   comparison only.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64ltu
+
+UNSIGNED64_PROTO
+{
+  /* Signed comparison should be done with the signed variants.  */
+  ISEL_BUILTIN ((long) x, (long) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((long) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (long) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((long *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (long *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned long) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned long) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (long *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (long *) q); /* { dg-error "isel intrinsic" } */
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isel64gtu
+
+UNSIGNED64_PROTO
+{
+  /* Signed comparison should be done with the signed variants.  */
+  ISEL_BUILTIN ((long) x, (long) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((long) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (long) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((long *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (long *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned long) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned long) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (long *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (long *) q); /* { dg-error "isel intrinsic" } */
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,81 @@
+/* { dg-do compile } */
+/* { dg-options "-mcpu=e500mc" } */
+
+#include "builtin-isel.h"
+
+/* We're not being clever with the preprocessor here because DejaGNU
+   will get confused.  We do try to use it to eliminate what duplication
+   we can.  */
+
+/* We check to see that the resolution permits polymorphic results.  */
+
+/* Equality comparisons.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iseleq
+
+SIGNED_PROTO
+{
+  i = ISEL_BUILTIN (x, y, a, b);
+  u = ISEL_BUILTIN (x, y, (unsigned int) a, (unsigned int) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+  i = ISEL_BUILTIN (p, q, a, b);
+  /* Equality checks explicitly permit unsigned comparison operands.  */
+  i = ISEL_BUILTIN ((unsigned int) x, (unsigned int) y, a, b);
+  r = ISEL_BUILTIN ((unsigned int) x, (unsigned int) y, p, q);
+}
+
+/* less-than, greater-than.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isellt
+
+SIGNED_PROTO
+{
+  i = ISEL_BUILTIN (x, y, a, b);
+  u = ISEL_BUILTIN (x, y, (unsigned int) a, (unsigned int) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iselgt
+
+SIGNED_PROTO
+{
+  i = ISEL_BUILTIN (x, y, a, b);
+  u = ISEL_BUILTIN (x, y, (unsigned int) a, (unsigned int) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+}
+
+/* Unsigned variants.  These permit unsigned and pointer operands for
+   comparison only.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iselltu
+
+UNSIGNED_PROTO
+{
+  i = ISEL_BUILTIN (x, y, a, b);
+  u = ISEL_BUILTIN (x, y, (unsigned int) a, (unsigned int) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+  i = ISEL_BUILTIN (p, q, a, b);
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iselgtu
+
+UNSIGNED_PROTO
+{
+  i = ISEL_BUILTIN (x, y, a, b);
+  u = ISEL_BUILTIN (x, y, (unsigned int) a, (unsigned int) b);
+  r = ISEL_BUILTIN (x, y, p, q);
+  r = ISEL_BUILTIN (x, y, (char *) p, (char *) q);
+  i = ISEL_BUILTIN (p, q, a, b);
+}
+
+/* Don't use bare isel, as that'll match function names and the like.  */
+/* { dg-final { scan-assembler-times "isel " 25 } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel-errors.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel-errors.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel-errors.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel-errors.c	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,117 @@
+/* Test rejection of invalid parameter combinations in isel builtins.  */
+/* { dg-do compile } */
+/* { dg-options "-mcpu=e500mc" } */
+
+#include "builtin-isel.h"
+
+/* We're not being clever with the preprocessor here because DejaGNU
+   will get confused.  We do try to use it to eliminate what duplication
+   we can.  */
+
+/* We check basic resolution of each builtin.  We also check to see that
+   the resolution permits polymorphic results.  Argument type mismatches
+   and result type mismatches are not permitted, except where noted.  */
+
+/* Equality comparisons.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iseleq
+
+SIGNED_PROTO
+{
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((unsigned int) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (unsigned int) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((int *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (int *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned int) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned int) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (int *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (int *) q); /* { dg-error "isel intrinsic" } */
+}
+
+/* less-than, greater-than.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME isellt
+
+SIGNED_PROTO
+{
+  /* Unsigned comparison should be done with the *u variants.  */
+  ISEL_BUILTIN ((unsigned int) x, (unsigned int) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* So should pointer comparison.  */
+  ISEL_BUILTIN (p, q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((unsigned int) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (unsigned int) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((int *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (int *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned int) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned int) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (int *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (int *) q); /* { dg-error "isel intrinsic" } */
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iselgt
+
+SIGNED_PROTO
+{
+  /* Unsigned comparison should be done with the *u variants.  */
+  ISEL_BUILTIN ((unsigned int) x, (unsigned int) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* So should pointer comparison.  */
+  ISEL_BUILTIN (p, q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((unsigned int) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (unsigned int) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((int *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (int *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned int) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned int) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (int *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (int *) q); /* { dg-error "isel intrinsic" } */
+}
+
+/* Unsigned variants.  These permit unsigned and pointer operands for
+   comparison only.  */
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iselltu
+
+UNSIGNED_PROTO
+{
+  /* Signed comparison should be done with the signed variants.  */
+  ISEL_BUILTIN ((int) x, (int) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((int) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (int) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((int *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (int *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned int) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned int) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (int *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (int *) q); /* { dg-error "isel intrinsic" } */
+}
+
+#undef FUNCTION_NAME
+#define FUNCTION_NAME iselgtu
+
+UNSIGNED_PROTO
+{
+  /* Signed comparison should be done with the signed variants.  */
+  ISEL_BUILTIN ((int) x, (int) y, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in argument type.  */
+  ISEL_BUILTIN ((int) x, y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, (int) y, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN ((int *) p, q, a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (p, (int *) q, a, b); /* { dg-error "isel intrinsic" } */
+  /* Mismatches in return type.  */
+  ISEL_BUILTIN (x, y, (unsigned int) a, b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, a, (unsigned int) b); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, (int *) p, q); /* { dg-error "isel intrinsic" } */
+  ISEL_BUILTIN (x, y, p, (int *) q); /* { dg-error "isel intrinsic" } */
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.h test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.h
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.h	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/builtin-isel.h	2018-04-02 14:15:30.000000000 +0800
@@ -0,0 +1,25 @@
+/* Common definitions for builtin isel testing.  */
+
+#define SIGNED_ARGLIST (int x, int y, int a, int b, void *p, void *q)
+#define UNSIGNED_ARGLIST (unsigned int x, unsigned int y, \
+			  int a, int b, void *p, void *q)
+
+#define SIGNED_PROTO void FUNCTION_NAME SIGNED_ARGLIST
+#define UNSIGNED_PROTO void FUNCTION_NAME UNSIGNED_ARGLIST
+
+#define SIGNED64_ARGLIST (long x, long y, long a, long b, void *p, void *q)
+#define UNSIGNED64_ARGLIST (unsigned long x, unsigned long y, \
+			    long a, long b, void *p, void *q)
+
+#define SIGNED64_PROTO void FUNCTION_NAME SIGNED64_ARGLIST
+#define UNSIGNED64_PROTO void FUNCTION_NAME UNSIGNED64_ARGLIST
+
+#define CONCAT2(X,Y) X##Y
+#define CONCAT(X,Y) CONCAT2(X, Y)
+#define ISEL_BUILTIN CONCAT(__builtin_, FUNCTION_NAME)
+
+volatile int i;
+volatile unsigned int u;
+volatile void *r;
+volatile long L;
+volatile unsigned long U;
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/bypass-load-on-store.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/bypass-load-on-store.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/bypass-load-on-store.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/bypass-load-on-store.c	2018-04-02 14:15:35.000000000 +0800
@@ -0,0 +1,27 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-*spe* } { "*" } { "" } } */
+/* { dg-options "-O3 -fbypass-load-on-store -fdump-rtl-sched1 -fdump-rtl-sched2 -fsched-verbose=2" } */
+
+void nescaf(void)
+{
+
+	extern long a, b, c, d, e, f;
+	volatile long z, w;
+
+	a = 41; b = 79; c = 20; d = 11; e = 12; f = 100;
+
+	/* Now, we have a store followed by a load. The assignments to a-t are
+	 * all independent of the store-load computation below. The question is:
+	 * Under -fschedule-insns -fbypass-load-on-store, are 14 of the above
+	 * instructions moved between the store-load?
+	 */
+	z = 121;
+	w = z;
+}
+
+/* Note: There is going to be exactly one insn that will be assigned cost 15.
+ *       Since its insn-number will likely change, we do not include the insn
+ *       number in the scan - just the part of the dump that'll be invariant.
+ */
+/* { dg-final { scan-rtl-dump "into queue with cost=15" "sched1" { target powerpc*-*-* } } } */
+/* { dg-final { cleanup-rtl-dump "sched*" } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-altivec-dwreg.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-altivec-dwreg.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-altivec-dwreg.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-altivec-dwreg.c	2018-04-02 14:15:37.000000000 +0800
@@ -0,0 +1,18 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O0 -g -mmap_dwarf_vecreg" } */
+/* { dg-final { scan-assembler-times ".uleb128 0x481" 1 } } */
+/* { dg-final { scan-assembler-times ".uleb128 0x482" 1 } } */
+/* { dg-final { scan-assembler-times ".uleb128 0x483" 1 } } */
+
+#include <altivec.h>
+
+vector unsigned int fun()
+{
+  register vector unsigned int vi1 = {0,1,2,3}; 
+  register vector unsigned int vi2 = {1,2,3,4};
+  register vector unsigned int ri = {0,0,0,0};
+  ri = vec_add(vi1, vi2); /* ri = vi1 + vi2 */
+
+  return ri;
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim-2.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim-2.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim-2.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim-2.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-options "-O2 -std=c99" } */
+/* { dg-final { scan-assembler "rlwinm \[0-9\]+,\[0-9\]+,\[0-9\]+,0xff"  { target { ilp32 } } } } */
+
+#define GET_MODULE(_id)         ((_id & 0x00003F00) >> 8)
+#define GET_IF(_id)             ((_id & 0x000000FF))
+#define GET_IF_ID(_module, _if) (((_module) << 8) | (_if))
+
+unsigned int dev;
+
+void testthebug(unsigned short i);
+
+void testbug(void)
+{
+  unsigned char  module;
+  unsigned char  interface;
+  unsigned short ifid;
+
+  module = GET_MODULE(dev);
+  interface = GET_IF(dev);
+  ifid = GET_IF_ID(module + 1, interface + 1);
+
+  testthebug(ifid);
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-extelim.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,46 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-options "-O2 -std=c99" } */
+/* { dg-final { scan-assembler-times "rlwinm" 2 { target { ilp32 } } } } */
+/* { dg-final { scan-assembler-times "rldicl" 2 { target { lp64 } } } } */
+
+int hipBugTest_c1 ();
+
+int hipBugTest_c1 ()
+{
+  const int iN = 16;
+
+  signed char pcIn[iN];
+  unsigned char pucOut[iN];
+
+  for (int i = 0; i < iN; i++)
+  {
+    pcIn[i] = (signed char) (i - 11);
+    pucOut[i] = 0;
+  }
+
+  for (int i = 0; i < iN; i++)
+  {
+    const unsigned char ucGain = 3;
+    const unsigned char ucLimit = 100;
+
+    unsigned char ucIn;
+    unsigned char ucErr;
+    unsigned int uiVal;
+
+    if (pcIn[i] < 0)
+      ucIn = (unsigned char) ( pcIn[i] * -1);
+    else
+      ucIn = (unsigned char) pcIn[i];
+
+    uiVal = ucIn - 3;
+    uiVal = uiVal * (unsigned int) ucGain;
+
+    if (uiVal > ucLimit)
+      ucErr = ucLimit;
+    else
+      ucErr = (unsigned char)uiVal;
+
+    pucOut[i] = ucErr;
+  }
+  return pucOut[0];
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-fuse-seq-load-indexes.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-fuse-seq-load-indexes.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-fuse-seq-load-indexes.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-fuse-seq-load-indexes.c	2018-04-02 14:15:41.000000000 +0800
@@ -0,0 +1,29 @@
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-options "-O2 -fuse-seq-load-indexes" } */
+
+void
+testloadindex (
+    short   *Data,     
+    short   *AccData,  
+    short   DataSize,       
+    short   NumberOfLags,   
+    short   Scale           
+)
+{
+    int   i;
+    int   lag;
+    int   LastIndex;
+    int   Accumulator;
+
+    for (lag = 0; lag < NumberOfLags; lag++) {
+        Accumulator = 0;
+        LastIndex = DataSize - lag;
+        for (i = 0; i < LastIndex; i++) {
+            Accumulator += ((int) Data[i] * (int) Data[i+lag]) >> Scale;
+        }
+        AccData[lag] = (short) (Accumulator >> 16) ;
+    }
+}
+/* { dg-final { scan-assembler-not "lhau" } }*/
+/* { dg-final { scan-assembler-times "lhax" 2 } }*/
+
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv-2.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv-2.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv-2.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv-2.c	2018-04-02 14:15:38.000000000 +0800
@@ -0,0 +1,292 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O3 -m64 -fdump-rtl-loop2_invariant" } */
+/* { dg-final { scan-rtl-dump-times "Decided to move" 16 "loop2_invariant"} } */
+/* { dg-final { cleanup-rtl-dump "loop2_invariant" } } */
+
+#include <stdio.h>
+#include <string.h>
+
+typedef enum {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+typedef int One_Thirty;
+typedef int One_Fifty;
+typedef char Capital_Letter;
+typedef int Boolean;
+typedef char Str_30 [31];
+typedef int Arr_1_Dim [50];
+typedef int Arr_2_Dim [50] [50];
+
+typedef struct record
+{
+  struct record *Ptr_Comp;
+  Enumeration Discr;
+  union {
+    struct {
+      Enumeration Enum_Comp;
+      int Int_Comp;
+      char Str_Comp [31];
+    } var_1;
+    struct {
+      Enumeration E_Comp_2;
+      char Str_2_Comp [31];
+    } var_2;
+    struct {
+      char Ch_1_Comp;
+      char Ch_2_Comp;
+    } var_3;
+  } variant;
+} Rec_Type, *Rec_Pointer;
+
+Rec_Pointer Ptr_Glob, Next_Ptr_Glob;
+int Int_Glob;
+Boolean Bool_Glob;
+char Ch_1_Glob, Ch_2_Glob;
+int Arr_1_Glob [50];
+int Arr_2_Glob [50] [50];
+char Reg_Define[] = "Register option selected.";
+double Begin_Time, End_Time, User_Time;
+double Microseconds, Dhrystones_Per_Second, Vax_Mips;
+
+Enumeration Func_1 ();
+void exit (int);
+
+void main ()
+{
+  double dtime();
+  One_Fifty Int_1_Loc;
+  One_Fifty Int_2_Loc;
+  One_Fifty Int_3_Loc;
+  char Ch_Index;
+  Enumeration Enum_Loc;
+  Str_30 Str_1_Loc;
+  Str_30 Str_2_Loc;
+  int Run_Index;
+  int Number_Of_Runs;
+
+  FILE *Ap;
+
+
+
+  if ((Ap = fopen("dhry.res","a+")) == ((void *)0))
+    {
+       printf("Can not open dhry.res\n\n");
+       exit(1);
+    }
+
+  Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp = Next_Ptr_Glob;
+  Ptr_Glob->Discr = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp,
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+
+  printf ("\n");
+  printf ("Dhrystone Benchmark, Version 2.1 (Language: C)\n");
+  printf ("\n");
+  printf ("Please give the number of runs through the benchmark: ");
+  {
+    int n;
+    scanf ("%d", &n);
+    Number_Of_Runs = n;
+  }
+  printf ("\n");
+  printf ("Execution starts, %d runs through Dhrystone\n",Number_Of_Runs);
+
+  Begin_Time = dtime();
+  for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+  {
+
+    Proc_5();
+    Proc_4();
+
+    Int_1_Loc = 2;
+    Int_2_Loc = 3;
+    strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+    Enum_Loc = Ident_2;
+    Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+
+    while (Int_1_Loc < Int_2_Loc)
+    {
+      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+      Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+      Int_1_Loc += 1;
+    }
+
+    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+
+    Proc_1 (Ptr_Glob);
+    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+    {
+      if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+
+        {
+          Proc_6 (Ident_1, &Enum_Loc);
+          strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+          Int_2_Loc = Run_Index;
+          Int_Glob = Run_Index;
+        }
+    }
+    Int_2_Loc = Int_2_Loc * Int_1_Loc;
+    Int_1_Loc = Int_2_Loc / Int_3_Loc;
+    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+    Proc_2 (&Int_1_Loc);
+  }
+  End_Time = dtime();
+
+  printf ("Execution ends\n");
+  printf ("\n");
+  printf ("Final values of the variables used in the benchmark:\n");
+  printf ("\n");
+  printf ("Int_Glob:            %d\n", Int_Glob);
+  printf ("        should be:   %d\n", 5);
+  printf ("Bool_Glob:           %d\n", Bool_Glob);
+  printf ("        should be:   %d\n", 1);
+  printf ("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  printf ("        should be:   %c\n", 'A');
+  printf ("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  printf ("        should be:   %c\n", 'B');
+  printf ("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  printf ("        should be:   %d\n", 7);
+  printf ("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  printf ("        should be:   Number_Of_Runs + 10\n");
+  printf ("Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %d\n", Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent)\n");
+  printf ("  Discr:             %d\n", Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 2);
+  printf ("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 17);
+  printf ("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Next_Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %d\n", Next_Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent), same as above\n");
+  printf ("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 1);
+  printf ("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 18);
+  printf ("  Str_Comp:          %s\n", Next_Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Int_1_Loc:           %d\n", Int_1_Loc);
+  printf ("        should be:   %d\n", 5);
+  printf ("Int_2_Loc:           %d\n", Int_2_Loc);
+  printf ("        should be:   %d\n", 13);
+  printf ("Int_3_Loc:           %d\n", Int_3_Loc);
+  printf ("        should be:   %d\n", 7);
+  printf ("Enum_Loc:            %d\n", Enum_Loc);
+  printf ("        should be:   %d\n", 1);
+  printf ("Str_1_Loc:           %s\n", Str_1_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  printf ("Str_2_Loc:           %s\n", Str_2_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  printf ("\n");
+
+  User_Time = End_Time - Begin_Time;
+
+  if (User_Time < 2)
+  {
+    printf ("Measured time too small to obtain meaningful results\n");
+    printf ("Please increase number of runs\n");
+    printf ("\n");
+  }
+  else
+  {
+    Microseconds = User_Time * 1000000.0
+                        / (double) Number_Of_Runs;
+    Dhrystones_Per_Second = (double) Number_Of_Runs / User_Time;
+    Vax_Mips = Dhrystones_Per_Second / 1757.0;
+
+    printf ("Register option selected?  NO\n");
+    strcpy(Reg_Define, "Register option not selected.");
+
+    printf ("Microseconds for one run through Dhrystone: ");
+    printf ("%7.1lf \n", Microseconds);
+    printf ("Dhrystones per Second:                      ");
+    printf ("%10.1lf \n", Dhrystones_Per_Second);
+    printf ("VAX MIPS rating = %10.3lf \n",Vax_Mips);
+    printf ("\n");
+
+    fprintf(Ap,"\n");
+    fprintf(Ap,"Dhrystone Benchmark, Version 2.1 (Language: C)\n");
+    fprintf(Ap,"%s\n",Reg_Define);
+    fprintf(Ap,"Microseconds for one loop: %7.1lf\n",Microseconds);
+    fprintf(Ap,"Dhrystones per second: %10.1lf\n",Dhrystones_Per_Second);
+    fprintf(Ap,"VAX MIPS rating: %10.3lf\n",Vax_Mips);
+    fclose(Ap);
+  }
+}
+
+Proc_1 (Ptr_Val_Par)
+Rec_Pointer Ptr_Val_Par;
+{
+  Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;
+  *Ptr_Val_Par->Ptr_Comp = *Ptr_Glob;
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+
+  if (Next_Record->Discr == Ident_1)
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp,
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10,
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else
+    *Ptr_Val_Par = *Ptr_Val_Par->Ptr_Comp;
+}
+
+
+Proc_2 (Int_Par_Ref)
+One_Fifty *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+  Enumeration Enum_Loc;
+  Int_Loc = *Int_Par_Ref + 10;
+  do
+    if (Ch_1_Glob == 'A')
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    }
+  while (Enum_Loc != Ident_1);
+}
+
+
+Proc_3 (Ptr_Ref_Par)
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != 0)
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+}
+
+Proc_4 ()
+{
+  Boolean Bool_Loc;
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+}
+
+Proc_5 ()
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = 0;
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/ppc-fsl-loop-inv.c	2018-04-02 14:15:38.000000000 +0800
@@ -0,0 +1,80 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O3 -fdump-rtl-loop2_invariant" } */
+/* { dg-final { scan-rtl-dump-times "Decided to move" 10 "loop2_invariant"} } */
+/* { dg-final { cleanup-rtl-dump "loop2_invariant" } } */
+
+#include <string.h>
+unsigned char setmask[] =
+{
+    0x01, 0x02, 0x04, 0x08,
+    0x10, 0x20, 0x40, 0x80,
+};
+
+
+int threashold[] = { 139,138,122,120,131,135,109,130 };
+void ditherImage (unsigned char *input_buffer, int input_height,
+                         int input_width, unsigned char *output_buffer)
+{
+  int * c0;
+  int * c1;
+  int column;
+  int pixel;
+  unsigned char byte = 0;
+  int error;
+  int row;
+  int bit = 0;
+  int * temp;
+  int * err0;
+  int storage_err0[(2) * (256 +2*(1))];
+
+  memset((void*)output_buffer, 0,
+              (input_height * ((input_width-1)/(8)+1)));
+
+  err0 = storage_err0;
+  memset((void*)err0, 0,
+              (2) * (input_width+2*(1)) * sizeof(int));
+
+  c0 = err0 + (1);
+  c1 = c0 + input_width + 2*(1);
+
+  for (row = 0; row < input_height; ++row)
+  {
+    error = 0;
+    for (column = 0; column < input_width; ++column)
+    {
+      if ((pixel = *(input_buffer++)) == (255))
+        c0[column] = error = 0;
+      else
+      {
+        pixel += ((error * 8 + c1[column+1] * 3 + c1[column] * 5
+                  + c1[column-1] * 1)/16);
+        if (pixel < threashold[bit])
+        {
+          byte |= setmask[bit];
+          c0[column] = error = pixel;
+        }
+        else
+        {
+          c0[column] = error = pixel - (255);
+        }
+      }
+
+      if (++bit >= (8))
+      {
+        *(output_buffer++) = byte;
+        byte = bit = 0;
+      }
+    }
+
+    if (bit != 0)
+    {
+      *(output_buffer++) = byte;
+      byte = bit = 0;
+    }
+
+    temp = c0;
+    c0 = c1;
+    c1 = temp;
+  }
+  return;
+}
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/pr60158.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/pr60158.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/pr60158.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/pr60158.c	2018-04-02 14:15:36.000000000 +0800
@@ -0,0 +1,91 @@
+/* { dg-do compile } */
+/* { dg-skip-if "not an SPE target" { ! powerpc_spe_nocache } { "*" } { "" } } */
+/* { dg-options "-mcpu=8548 -mno-spe -mfloat-gprs=double -Os -fdata-sections -fpic -mrelocatable" } */
+
+#define NULL 0
+int func (int val);
+void *func2 (void *ptr);
+
+static const char *ifs;
+static char map[256];
+
+typedef struct {
+/*
+ * None of these fields are used, but removing any
+ * of them makes the problem go away.
+ */
+  char *data;
+  int length;
+  int maxlen;
+  int quote;
+} o_string;
+
+#define NULL_O_STRING {NULL,0,0,0}
+
+static int parse_stream (void *dest, void *ctx)
+{
+  int ch = func (0), m;
+
+  while (ch != -1) {
+    m = map[ch];
+    if (ch != '\n')
+    func2(dest);
+
+    ctx = func2 (ctx);
+    if (!func (0))
+      return 0;
+    if (m != ch) {
+      func2 ("htns");
+      break;
+    }
+  }
+  return -1;
+}
+
+static void mapset (const char *set, int code)
+{
+  const char *s;
+  for (s=set; *s; s++)  map[(int)*s] = code;
+}
+
+static void update_ifs_map(void)
+{
+  /* char *ifs and char map[256] are both globals. */
+  ifs = func2 ("abc");
+  if (ifs == NULL) ifs="def";
+
+  func2 (map);
+  {
+    char subst[2] = {4, 0};
+    mapset (subst, 3);
+  }
+  mapset (";&|#", 1);
+}
+
+int parse_stream_outer (int flag)
+{
+  int blah;
+  o_string temp=NULL_O_STRING;
+  int rcode;
+
+  do {
+    update_ifs_map ();
+    func2 (&blah); /* a memory clobber works as well */
+    rcode = parse_stream (&temp, NULL);
+    func2 ("aoeu");
+    if (func (0) != 0) {
+      func2 (NULL);
+    }
+  } while (rcode != -1);
+  return 0;
+}
+
+/* { dg-final { if ![file exists pr60158.s] { fail "pr60158.c (compile)"; return; } } } */
+
+/* { dg-final { set c_rel [llength [grep pr60158.s \\.data\\.rel\\.ro\\.local]] } } */
+/* { dg-final { set c_fix [llength [grep pr60158.s \\.fixup]] } } */
+/* { dg-final { if [string match $c_rel $c_fix] \{                     } } */
+/* { dg-final {     pass "pr60158.c (passed)"  } } */
+/* { dg-final { \} else \{                                     } } */
+/* { dg-final {     fail "pr60158.c (.fixup table entries not generated for .data.rel.ro.local section)"       } } */
+/* { dg-final { \}                                              } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/rldic-1.c test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/rldic-1.c
--- gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/rldic-1.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gcc.target/powerpc/rldic-1.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,33 @@
+/* { dg-do run { target { powerpc*-*-* } } } */
+/* skip test unless -m64 is present */
+/* { dg-skip-if "" { powerpc*-*-* } { "*" } { "-m64" } } */
+/* { dg-options "-O3 -save-temps" } */
+
+int sum;
+
+void sum1 ( unsigned  int N, short *C) __attribute__((__noinline__)); 
+void sum1 ( unsigned  int N, short *C) 
+{
+        unsigned int i;
+
+        for (i=0; i<N; i++)
+        {
+                sum += C[i*N];
+        }
+} __attribute__((__noinline__))
+int main()
+{
+        short C [5*5] = { 1 , 0, 0, 0, 0, 
+        2 , 0, 0, 0, 0, 
+        3 , 0, 0, 0, 0, 
+        4 , 0, 0, 0, 0, 
+        5 , 0, 0, 0, 0,         
+        };
+        sum1 (5, C);
+        return (sum==15 ? 0 : 1);
+}
+
+
+
+/* { dg-final { scan-assembler-times "rldic " 1  { target powerpc*-*-*  } } } */
+/* { dg-final { cleanup-saved-temps } } */
diff -rNu gcc-4.9.2/gcc/testsuite/gfortran.dg/alloc_comp_default_init_1.f90 test/gcc-4.9.2/gcc/testsuite/gfortran.dg/alloc_comp_default_init_1.f90
--- gcc-4.9.2/gcc/testsuite/gfortran.dg/alloc_comp_default_init_1.f90	2008-01-08 23:12:34.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gfortran.dg/alloc_comp_default_init_1.f90	1970-01-01 08:00:00.000000000 +0800
@@ -1,84 +0,0 @@
-! { dg-do run }
-! Checks the fixes for PR34681 and PR34704, in which various mixtures
-! of default initializer and allocatable array were not being handled
-! correctly for derived types with allocatable components.
-!
-! Contributed by Paolo Giannozzi <p.giannozzi@fisica.uniud.it>
-!
-program boh
-  integer :: c1, c2, c3, c4, c5
-  !
-  call mah (0, c1) ! These calls deal with PR34681
-  call mah (1, c2)
-  call mah (2, c3)
-  !
-  if (c1 /= c2) call abort
-  if (c1 /= c3) call abort
-  !
-  call mah0 (c4) ! These calls deal with PR34704
-  call mah1 (c5)
-  !
-  if (c4 /= c5) call abort
-  !
-end program boh
-!
-subroutine mah (i, c)
-  !
-  integer, intent(in) :: i
-  integer, intent(OUT) :: c
-  !
-  type mix_type
-     real(8), allocatable :: a(:)
-     complex(8), allocatable :: b(:)
-  end type mix_type
-  type(mix_type), allocatable, save :: t(:)
-  integer :: j, n=1024
-  !
-  if (i==0) then
-     allocate (t(1))
-     allocate (t(1)%a(n))
-     allocate (t(1)%b(n))
-     do j=1,n
-        t(1)%a(j) = j
-        t(1)%b(j) = n-j
-     end do
-  end if
-  c = sum( t(1)%a(:) ) + sum( t(1)%b(:) )
-  if ( i==2) then
-     deallocate (t(1)%b)
-     deallocate (t(1)%a)
-     deallocate (t)
-  end if
-end subroutine mah
-
-subroutine mah0 (c)
-  !
-  integer, intent(OUT) :: c
-  type mix_type
-     real(8), allocatable :: a(:)
-     integer :: n=1023
-  end type mix_type
-  type(mix_type) :: t
-  !
-  allocate(t%a(1))
-  t%a=3.1415926
-  c = t%n
-  deallocate(t%a)
-  !
-end subroutine mah0
-!
-subroutine mah1 (c)
-  !
-  integer, intent(OUT) :: c
-  type mix_type
-     real(8), allocatable :: a(:)
-     integer :: n=1023
-  end type mix_type
-  type(mix_type), save :: t
-  !
-  allocate(t%a(1))
-  t%a=3.1415926
-  c = t%n
-  deallocate(t%a)
-  !
-end subroutine mah1
diff -rNu gcc-4.9.2/gcc/testsuite/gfortran.dg/cray_pointers_8.f90 test/gcc-4.9.2/gcc/testsuite/gfortran.dg/cray_pointers_8.f90
--- gcc-4.9.2/gcc/testsuite/gfortran.dg/cray_pointers_8.f90	2011-04-15 22:06:44.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gfortran.dg/cray_pointers_8.f90	1970-01-01 08:00:00.000000000 +0800
@@ -1,63 +0,0 @@
-! { dg-do run }
-! { dg-options "-fcray-pointer -ffloat-store" }
-!
-! Test the fix for PR36528 in which the Cray pointer was not passed
-! correctly to 'euler' so that an undefined reference to fcn was
-! generated by the linker.
-!
-! Reported by Tobias Burnus  <burnus@gcc.gnu.org>
-! from http://groups.google.com/group/comp.lang.fortran/msg/86b65bad78e6af78
-!
-real function p1(x)
-  real, intent(in) :: x
-  p1 = x
-end
-
-real function euler(xp,xk,dx,f)
-  real, intent(in) :: xp, xk, dx
-  interface
-    real function f(x)
-      real, intent(in) :: x
-    end function
-  end interface
-  real x, y
-  y = 0.0
-  x = xp
-  do while (x .le. xk)
-    y = y + f(x)*dx
-    x = x + dx
-  end do
-  euler = y
-end
-program main
-  interface
-    real function p1 (x)
-      real, intent(in) :: x
-    end function
-    real function fcn (x)
-      real, intent(in) :: x
-    end function
-    real function euler (xp,xk,dx,f)
-      real, intent(in) :: xp, xk ,dx
-      interface
-        real function f(x)
-          real, intent(in) :: x
-        end function
-      end interface
-    end function
-  end interface
-  real x, xp, xk, dx, y, z
-  pointer (pfcn, fcn)
-  pfcn = loc(p1)
-  xp = 0.0
-  xk = 1.0
-  dx = 0.0005
-  y = 0.0
-  x = xp
-  do while (x .le. xk)
-    y = y + fcn(x)*dx
-    x = x + dx
-  end do
-  z = euler(0.0,1.0,0.0005,fcn)
-  if (abs (y - z) .gt. 1e-6) call abort
-end
diff -rNu gcc-4.9.2/gcc/testsuite/gfortran.dg/PR49268.f90 test/gcc-4.9.2/gcc/testsuite/gfortran.dg/PR49268.f90
--- gcc-4.9.2/gcc/testsuite/gfortran.dg/PR49268.f90	2011-06-03 05:41:12.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gfortran.dg/PR49268.f90	1970-01-01 08:00:00.000000000 +0800
@@ -1,51 +0,0 @@
-! { dg-do run }
-! { dg-options "-fcray-pointer" }
-
-! Test the fix for a runtime error 
-! Contributed by Mike Kumbera <kumbera1@llnl.gov>
-
-        program bob
-        implicit none
-        integer*8 ipfoo
-        integer n,m,i,j
-        real*8 foo
-        
-        common /ipdata/ ipfoo
-        common /ipsize/ n,m
-        POINTER ( ipfoo, foo(3,7) )
-
-        n=3
-        m=7
-
-        ipfoo=malloc(8*n*m)
-        do i=1,n
-            do j=1,m
-                foo(i,j)=1.d0
-            end do
-        end do
-        call use_foo()
-        end  program bob
-
-
-        subroutine use_foo()
-        implicit none
-        integer n,m,i,j
-        integer*8 ipfoo
-        common /ipdata/ ipfoo
-        common /ipsize/ n,m
-        real*8 foo,boo
-
-        !fails if * is the last dimension
-        POINTER ( ipfoo, foo(n,*) )
-
-        !works if the last dimension is specified
-        !POINTER ( ipfoo, foo(n,m) )
-        boo=0.d0
-        do i=1,n
-            do j=1,m
-               boo=foo(i,j)+1.0
-               if (abs (boo - 2.0) .gt. 1e-6) call abort
-            end do
-        end do
-
-        end subroutine use_foo
diff -rNu gcc-4.9.2/gcc/testsuite/gfortran.dg/specifics_1.f90 test/gcc-4.9.2/gcc/testsuite/gfortran.dg/specifics_1.f90
--- gcc-4.9.2/gcc/testsuite/gfortran.dg/specifics_1.f90	2006-11-25 05:45:36.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gfortran.dg/specifics_1.f90	1970-01-01 08:00:00.000000000 +0800
@@ -1,318 +0,0 @@
-! Program to test intrinsic functions as actual arguments
-!
-! Copied from gfortran.fortran-torture/execute/specifics.f90
-! Please keep them in sync
-!
-! It is run here with -ff2c option
-!
-! { dg-do run }
-! { dg-options "-ff2c" }
-! Program to test intrinsic functions as actual arguments
-subroutine test_c(fn, val, res)
-  complex fn
-  complex val, res
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  complex a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_z(fn, val, res)
-  double complex fn
-  double complex val, res
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  double complex a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_cabs(fn, val, res)
-  real fn, res
-  complex val
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  real a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_cdabs(fn, val, res)
-  double precision fn, res
-  double complex val
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  double precision a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_r(fn, val, res)
-  real fn
-  real val, res
-
-  if (diff(fn(val), res)) call abort
-contains
-function diff(a, b)
-  real a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine
-
-subroutine test_d(fn, val, res)
-  double precision fn
-  double precision val, res
-
-  if (diff(fn(val), res)) call abort
-contains
-function diff(a, b)
-  double precision a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001d0)
-end function
-end subroutine
-
-subroutine test_r2(fn, val1, val2, res)
-  real fn
-  real val1, val2, res
-
-  if (diff(fn(val1, val2), res)) call abort
-contains
-function diff(a, b)
-  real a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine
-
-subroutine test_d2(fn, val1, val2, res)
-  double precision fn
-  double precision val1, val2, res
-
-  if (diff(fn(val1, val2), res)) call abort
-contains
-function diff(a, b)
-  double precision a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001d0)
-end function
-end subroutine
-
-subroutine test_dprod(fn)
-  double precision fn
-  if (abs (fn (2.0, 3.0) - 6d0) .gt. 0.00001) call abort
-end subroutine
-
-subroutine test_nint(fn,val,res)
-  integer fn, res
-  real val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_idnint(fn,val,res)
-  integer fn, res
-  double precision val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_idim(fn,val1,val2,res)
-  integer fn, res, val1, val2
-  if (res .ne. fn(val1,val2)) call abort
-end subroutine
-
-subroutine test_iabs(fn,val,res)
-  integer fn, res, val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_len(fn,val,res)
-  integer fn, res
-  character(len=*) val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_index(fn,val1,val2,res)
-  integer fn, res
-  character(len=*) val1, val2
-  if (fn(val1,val2) .ne. res) call abort
-end subroutine
-
-program specifics
-  intrinsic abs
-  intrinsic aint
-  intrinsic anint
-  intrinsic acos
-  intrinsic acosh
-  intrinsic asin
-  intrinsic asinh
-  intrinsic atan
-  intrinsic atanh
-  intrinsic cos
-  intrinsic sin
-  intrinsic tan
-  intrinsic cosh
-  intrinsic sinh
-  intrinsic tanh
-  intrinsic alog
-  intrinsic alog10
-  intrinsic exp
-  intrinsic sign
-  intrinsic isign
-  intrinsic amod
-
-  intrinsic dabs
-  intrinsic dint
-  intrinsic dnint
-  intrinsic dacos
-  intrinsic dacosh
-  intrinsic dasin
-  intrinsic dasinh
-  intrinsic datan
-  intrinsic datanh
-  intrinsic dcos
-  intrinsic dsin
-  intrinsic dtan
-  intrinsic dcosh
-  intrinsic dsinh
-  intrinsic dtanh
-  intrinsic dlog
-  intrinsic dlog10
-  intrinsic dexp
-  intrinsic dsign
-  intrinsic dmod
-
-  intrinsic conjg
-  intrinsic ccos
-  intrinsic cexp
-  intrinsic clog
-  intrinsic csin
-  intrinsic csqrt
-
-  intrinsic dconjg
-  intrinsic cdcos
-  intrinsic cdexp
-  intrinsic cdlog
-  intrinsic cdsin
-  intrinsic cdsqrt
-  intrinsic zcos
-  intrinsic zexp
-  intrinsic zlog
-  intrinsic zsin
-  intrinsic zsqrt
-
-  intrinsic cabs
-  intrinsic cdabs
-  intrinsic zabs
-
-  intrinsic dprod
-
-  intrinsic nint
-  intrinsic idnint
-  intrinsic dim
-  intrinsic ddim
-  intrinsic idim
-  intrinsic iabs
-  intrinsic mod
-  intrinsic len
-  intrinsic index
-
-  intrinsic aimag
-  intrinsic dimag
-
-  call test_r (abs, -1.0, abs(-1.0))
-  call test_r (aint, 1.7, aint(1.7))
-  call test_r (anint, 1.7, anint(1.7))
-  call test_r (acos, 0.5, acos(0.5))
-  call test_r (acosh, 1.5, acosh(1.5))
-  call test_r (asin, 0.5, asin(0.5))
-  call test_r (asinh, 0.5, asinh(0.5))
-  call test_r (atan, 0.5, atan(0.5))
-  call test_r (atanh, 0.5, atanh(0.5))
-  call test_r (cos, 1.0, cos(1.0))
-  call test_r (sin, 1.0, sin(1.0))
-  call test_r (tan, 1.0, tan(1.0))
-  call test_r (cosh, 1.0, cosh(1.0))
-  call test_r (sinh, 1.0, sinh(1.0))
-  call test_r (tanh, 1.0, tanh(1.0))
-  call test_r (alog, 2.0, alog(2.0))
-  call test_r (alog10, 2.0, alog10(2.0))
-  call test_r (exp, 1.0, exp(1.0))
-  call test_r2 (sign, 1.0, -2.0, sign(1.0, -2.0))
-  call test_r2 (amod, 3.5, 2.0, amod(3.5, 2.0))
-  
-  call test_d (dabs, -1d0, abs(-1d0))
-  call test_d (dint, 1.7d0, 1d0)
-  call test_d (dnint, 1.7d0, 2d0)
-  call test_d (dacos, 0.5d0, dacos(0.5d0))
-  call test_d (dacosh, 1.5d0, dacosh(1.5d0))
-  call test_d (dasin, 0.5d0, dasin(0.5d0))
-  call test_d (dasinh, 0.5d0, dasinh(0.5d0))
-  call test_d (datan, 0.5d0, datan(0.5d0))
-  call test_d (datanh, 0.5d0, datanh(0.5d0))
-  call test_d (dcos, 1d0, dcos(1d0))
-  call test_d (dsin, 1d0, dsin(1d0))
-  call test_d (dtan, 1d0, dtan(1d0))
-  call test_d (dcosh, 1d0, dcosh(1d0))
-  call test_d (dsinh, 1d0, dsinh(1d0))
-  call test_d (dtanh, 1d0, dtanh(1d0))
-  call test_d (dlog, 2d0, dlog(2d0))
-  call test_d (dlog10, 2d0, dlog10(2d0))
-  call test_d (dexp, 1d0, dexp(1d0))
-  call test_d2 (dsign, 1d0, -2d0, sign(1d0, -2d0))
-  call test_d2 (dmod, 3.5d0, 2d0, dmod(3.5d0, 2d0))
-
-  call test_dprod (dprod)
-
-  call test_c (conjg, (1.2,-4.), conjg((1.2,-4.)))
-  call test_c (ccos, (1.2,-4.), ccos((1.2,-4.)))
-  call test_c (cexp, (1.2,-4.), cexp((1.2,-4.)))
-  call test_c (clog, (1.2,-4.), clog((1.2,-4.)))
-  call test_c (csin, (1.2,-4.), csin((1.2,-4.)))
-  call test_c (csqrt, (1.2,-4.), csqrt((1.2,-4.)))
-
-  call test_z (dconjg, (1.2d0,-4.d0), dconjg((1.2d0,-4.d0)))
-  call test_z (cdcos, (1.2d0,-4.d0), cdcos((1.2d0,-4.d0)))
-  call test_z (zcos, (1.2d0,-4.d0), zcos((1.2d0,-4.d0)))
-  call test_z (cdexp, (1.2d0,-4.d0), cdexp((1.2d0,-4.d0)))
-  call test_z (zexp, (1.2d0,-4.d0), zexp((1.2d0,-4.d0)))
-  call test_z (cdlog, (1.2d0,-4.d0), cdlog((1.2d0,-4.d0)))
-  call test_z (zlog, (1.2d0,-4.d0), zlog((1.2d0,-4.d0)))
-  call test_z (cdsin, (1.2d0,-4.d0), cdsin((1.2d0,-4.d0)))
-  call test_z (zsin, (1.2d0,-4.d0), zsin((1.2d0,-4.d0)))
-  call test_z (cdsqrt, (1.2d0,-4.d0), cdsqrt((1.2d0,-4.d0)))
-  call test_z (zsqrt, (1.2d0,-4.d0), zsqrt((1.2d0,-4.d0)))
-
-  call test_cabs (cabs, (1.2,-4.), cabs((1.2,-4.)))
-  call test_cdabs (cdabs, (1.2d0,-4.d0), cdabs((1.2d0,-4.d0)))
-  call test_cdabs (zabs, (1.2d0,-4.d0), zabs((1.2d0,-4.d0)))
-  call test_cabs (aimag, (1.2,-4.), aimag((1.2,-4.)))
-  call test_cdabs (dimag, (1.2d0,-4.d0), dimag((1.2d0,-4.d0)))
-
-  call test_nint (nint, -1.2, nint(-1.2))
-  call test_idnint (idnint, -1.2d0, idnint(-1.2d0))
-  call test_idim (isign, -42, 17, isign(-42, 17))
-  call test_idim (idim, -42, 17, idim(-42,17))
-  call test_idim (idim, 42, 17, idim(42,17))
-  call test_r2 (dim, 1.2, -4., dim(1.2, -4.))
-  call test_d2 (ddim, 1.2d0, -4.d0, ddim(1.2d0, -4.d0))
-  call test_iabs (iabs, -7, iabs(-7))
-  call test_idim (mod, 5, 2, mod(5,2))
-  call test_len (len, "foobar", len("foobar"))
-  call test_index (index, "foobarfoobar", "bar", index("foobarfoobar","bar"))
-
-end program
-
diff -rNu gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x test/gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x
--- gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x	2013-07-19 22:25:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x	2018-04-02 14:15:40.000000000 +0800
@@ -6,5 +6,9 @@
     # z'7f7fffff' value not preserved by lfs instruction.
     return 1
 }
+if [istarget "powerpc-*-*gnuspe"] {
+    # No Inf/NaN support on SPE.
+    return 1
+}
 add-ieee-options
 return 0
diff -rNu gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/specifics.f90 test/gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/specifics.f90
--- gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/specifics.f90	2006-11-25 22:28:56.000000000 +0800
+++ test/gcc-4.9.2/gcc/testsuite/gfortran.fortran-torture/execute/specifics.f90	1970-01-01 08:00:00.000000000 +0800
@@ -1,311 +0,0 @@
-! Program to test intrinsic functions as actual arguments
-!
-! Please keep the content of this file in sync with gfortran.dg/specifics_1.f90
-subroutine test_c(fn, val, res)
-  complex fn
-  complex val, res
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  complex a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_z(fn, val, res)
-  double complex fn
-  double complex val, res
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  double complex a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_cabs(fn, val, res)
-  real fn, res
-  complex val
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  real a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_cdabs(fn, val, res)
-  double precision fn, res
-  double complex val
-
-  if (diff(fn(val),res)) call abort
-contains
-function diff(a,b)
-  double precision a,b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine 
-
-subroutine test_r(fn, val, res)
-  real fn
-  real val, res
-
-  if (diff(fn(val), res)) call abort
-contains
-function diff(a, b)
-  real a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine
-
-subroutine test_d(fn, val, res)
-  double precision fn
-  double precision val, res
-
-  if (diff(fn(val), res)) call abort
-contains
-function diff(a, b)
-  double precision a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001d0)
-end function
-end subroutine
-
-subroutine test_r2(fn, val1, val2, res)
-  real fn
-  real val1, val2, res
-
-  if (diff(fn(val1, val2), res)) call abort
-contains
-function diff(a, b)
-  real a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001)
-end function
-end subroutine
-
-subroutine test_d2(fn, val1, val2, res)
-  double precision fn
-  double precision val1, val2, res
-
-  if (diff(fn(val1, val2), res)) call abort
-contains
-function diff(a, b)
-  double precision a, b
-  logical diff
-  diff = (abs(a - b) .gt. 0.00001d0)
-end function
-end subroutine
-
-subroutine test_dprod(fn)
-  double precision fn
-  if (abs (fn (2.0, 3.0) - 6d0) .gt. 0.00001) call abort
-end subroutine
-
-subroutine test_nint(fn,val,res)
-  integer fn, res
-  real val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_idnint(fn,val,res)
-  integer fn, res
-  double precision val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_idim(fn,val1,val2,res)
-  integer fn, res, val1, val2
-  if (res .ne. fn(val1,val2)) call abort
-end subroutine
-
-subroutine test_iabs(fn,val,res)
-  integer fn, res, val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_len(fn,val,res)
-  integer fn, res
-  character(len=*) val
-  if (res .ne. fn(val)) call abort
-end subroutine
-
-subroutine test_index(fn,val1,val2,res)
-  integer fn, res
-  character(len=*) val1, val2
-  if (fn(val1,val2) .ne. res) call abort
-end subroutine
-
-program specifics
-  intrinsic abs
-  intrinsic aint
-  intrinsic anint
-  intrinsic acos
-  intrinsic acosh
-  intrinsic asin
-  intrinsic asinh
-  intrinsic atan
-  intrinsic atanh
-  intrinsic cos
-  intrinsic sin
-  intrinsic tan
-  intrinsic cosh
-  intrinsic sinh
-  intrinsic tanh
-  intrinsic alog
-  intrinsic alog10
-  intrinsic exp
-  intrinsic sign
-  intrinsic isign
-  intrinsic amod
-
-  intrinsic dabs
-  intrinsic dint
-  intrinsic dnint
-  intrinsic dacos
-  intrinsic dacosh
-  intrinsic dasin
-  intrinsic dasinh
-  intrinsic datan
-  intrinsic datanh
-  intrinsic dcos
-  intrinsic dsin
-  intrinsic dtan
-  intrinsic dcosh
-  intrinsic dsinh
-  intrinsic dtanh
-  intrinsic dlog
-  intrinsic dlog10
-  intrinsic dexp
-  intrinsic dsign
-  intrinsic dmod
-
-  intrinsic conjg
-  intrinsic ccos
-  intrinsic cexp
-  intrinsic clog
-  intrinsic csin
-  intrinsic csqrt
-
-  intrinsic dconjg
-  intrinsic cdcos
-  intrinsic cdexp
-  intrinsic cdlog
-  intrinsic cdsin
-  intrinsic cdsqrt
-  intrinsic zcos
-  intrinsic zexp
-  intrinsic zlog
-  intrinsic zsin
-  intrinsic zsqrt
-
-  intrinsic cabs
-  intrinsic cdabs
-  intrinsic zabs
-
-  intrinsic dprod
-
-  intrinsic nint
-  intrinsic idnint
-  intrinsic dim
-  intrinsic ddim
-  intrinsic idim
-  intrinsic iabs
-  intrinsic mod
-  intrinsic len
-  intrinsic index
-
-  intrinsic aimag
-  intrinsic dimag
-
-  call test_r (abs, -1.0, abs(-1.0))
-  call test_r (aint, 1.7, aint(1.7))
-  call test_r (anint, 1.7, anint(1.7))
-  call test_r (acos, 0.5, acos(0.5))
-  call test_r (acosh, 1.5, acosh(1.5))
-  call test_r (asin, 0.5, asin(0.5))
-  call test_r (asinh, 0.5, asinh(0.5))
-  call test_r (atan, 0.5, atan(0.5))
-  call test_r (atanh, 0.5, atanh(0.5))
-  call test_r (cos, 1.0, cos(1.0))
-  call test_r (sin, 1.0, sin(1.0))
-  call test_r (tan, 1.0, tan(1.0))
-  call test_r (cosh, 1.0, cosh(1.0))
-  call test_r (sinh, 1.0, sinh(1.0))
-  call test_r (tanh, 1.0, tanh(1.0))
-  call test_r (alog, 2.0, alog(2.0))
-  call test_r (alog10, 2.0, alog10(2.0))
-  call test_r (exp, 1.0, exp(1.0))
-  call test_r2 (sign, 1.0, -2.0, sign(1.0, -2.0))
-  call test_r2 (amod, 3.5, 2.0, amod(3.5, 2.0))
-  
-  call test_d (dabs, -1d0, abs(-1d0))
-  call test_d (dint, 1.7d0, 1d0)
-  call test_d (dnint, 1.7d0, 2d0)
-  call test_d (dacos, 0.5d0, dacos(0.5d0))
-  call test_d (dacosh, 1.5d0, dacosh(1.5d0))
-  call test_d (dasin, 0.5d0, dasin(0.5d0))
-  call test_d (dasinh, 0.5d0, dasinh(0.5d0))
-  call test_d (datan, 0.5d0, datan(0.5d0))
-  call test_d (datanh, 0.5d0, datanh(0.5d0))
-  call test_d (dcos, 1d0, dcos(1d0))
-  call test_d (dsin, 1d0, dsin(1d0))
-  call test_d (dtan, 1d0, dtan(1d0))
-  call test_d (dcosh, 1d0, dcosh(1d0))
-  call test_d (dsinh, 1d0, dsinh(1d0))
-  call test_d (dtanh, 1d0, dtanh(1d0))
-  call test_d (dlog, 2d0, dlog(2d0))
-  call test_d (dlog10, 2d0, dlog10(2d0))
-  call test_d (dexp, 1d0, dexp(1d0))
-  call test_d2 (dsign, 1d0, -2d0, sign(1d0, -2d0))
-  call test_d2 (dmod, 3.5d0, 2d0, dmod(3.5d0, 2d0))
-
-  call test_dprod (dprod)
-
-  call test_c (conjg, (1.2,-4.), conjg((1.2,-4.)))
-  call test_c (ccos, (1.2,-4.), ccos((1.2,-4.)))
-  call test_c (cexp, (1.2,-4.), cexp((1.2,-4.)))
-  call test_c (clog, (1.2,-4.), clog((1.2,-4.)))
-  call test_c (csin, (1.2,-4.), csin((1.2,-4.)))
-  call test_c (csqrt, (1.2,-4.), csqrt((1.2,-4.)))
-
-  call test_z (dconjg, (1.2d0,-4.d0), dconjg((1.2d0,-4.d0)))
-  call test_z (cdcos, (1.2d0,-4.d0), cdcos((1.2d0,-4.d0)))
-  call test_z (zcos, (1.2d0,-4.d0), zcos((1.2d0,-4.d0)))
-  call test_z (cdexp, (1.2d0,-4.d0), cdexp((1.2d0,-4.d0)))
-  call test_z (zexp, (1.2d0,-4.d0), zexp((1.2d0,-4.d0)))
-  call test_z (cdlog, (1.2d0,-4.d0), cdlog((1.2d0,-4.d0)))
-  call test_z (zlog, (1.2d0,-4.d0), zlog((1.2d0,-4.d0)))
-  call test_z (cdsin, (1.2d0,-4.d0), cdsin((1.2d0,-4.d0)))
-  call test_z (zsin, (1.2d0,-4.d0), zsin((1.2d0,-4.d0)))
-  call test_z (cdsqrt, (1.2d0,-4.d0), cdsqrt((1.2d0,-4.d0)))
-  call test_z (zsqrt, (1.2d0,-4.d0), zsqrt((1.2d0,-4.d0)))
-
-  call test_cabs (cabs, (1.2,-4.), cabs((1.2,-4.)))
-  call test_cdabs (cdabs, (1.2d0,-4.d0), cdabs((1.2d0,-4.d0)))
-  call test_cdabs (zabs, (1.2d0,-4.d0), zabs((1.2d0,-4.d0)))
-  call test_cabs (aimag, (1.2,-4.), aimag((1.2,-4.)))
-  call test_cdabs (dimag, (1.2d0,-4.d0), dimag((1.2d0,-4.d0)))
-
-  call test_nint (nint, -1.2, nint(-1.2))
-  call test_idnint (idnint, -1.2d0, idnint(-1.2d0))
-  call test_idim (isign, -42, 17, isign(-42, 17))
-  call test_idim (idim, -42, 17, idim(-42,17))
-  call test_idim (idim, 42, 17, idim(42,17))
-  call test_r2 (dim, 1.2, -4., dim(1.2, -4.))
-  call test_d2 (ddim, 1.2d0, -4.d0, ddim(1.2d0, -4.d0))
-  call test_iabs (iabs, -7, iabs(-7))
-  call test_idim (mod, 5, 2, mod(5,2))
-  call test_len (len, "foobar", len("foobar"))
-  call test_index (index, "foobarfoobar", "bar", index("foobarfoobar","bar"))
-
-end program
-
diff -rNu gcc-4.9.2/gcc/timevar.def test/gcc-4.9.2/gcc/timevar.def
--- gcc-4.9.2/gcc/timevar.def	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/timevar.def	2018-04-02 14:15:31.000000000 +0800
@@ -199,6 +199,7 @@
 DEFTIMEVAR (TV_VARCONST              , "varconst")
 DEFTIMEVAR (TV_LOWER_SUBREG	     , "lower subreg")
 DEFTIMEVAR (TV_JUMP                  , "jump")
+DEFTIMEVAR (TV_EXTELIM               , "extension elimination")
 DEFTIMEVAR (TV_FWPROP                , "forward prop")
 DEFTIMEVAR (TV_CSE                   , "CSE")
 DEFTIMEVAR (TV_DCE                   , "dead code elimination")
diff -rNu gcc-4.9.2/gcc/tree-pass.h test/gcc-4.9.2/gcc/tree-pass.h
--- gcc-4.9.2/gcc/tree-pass.h	2014-01-03 06:23:26.000000000 +0800
+++ test/gcc-4.9.2/gcc/tree-pass.h	2018-04-02 14:15:31.000000000 +0800
@@ -343,6 +343,7 @@
 extern void register_pass (opt_pass* pass, pass_positioning_ops pos,
 			   const char* ref_pass_name, int ref_pass_inst_number);
 
+extern gimple_opt_pass *make_pass_widen_types_stmts (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_asan (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_asan_O0 (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_tsan (gcc::context *ctxt);
@@ -404,6 +405,7 @@
 extern gimple_opt_pass *make_pass_lower_vector_ssa (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_lower_omp (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_diagnose_omp_blocks (gcc::context *ctxt);
+extern gimple_opt_pass *make_pass_widen_types_bbs (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_expand_omp (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);
@@ -415,6 +417,7 @@
 extern gimple_opt_pass *make_pass_cse_sincos (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_optimize_bswap (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_optimize_widening_mul (gcc::context *ctxt);
+extern gimple_opt_pass *make_pass_opt_array_offset (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_warn_function_return (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_warn_function_noreturn (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_cselim (gcc::context *ctxt);
@@ -487,6 +490,9 @@
 
 extern rtl_opt_pass *make_pass_expand (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_instantiate_virtual_regs (gcc::context *ctxt);
+#ifdef ENABLE_EXTELIM
+extern rtl_opt_pass *make_pass_rtl_extelim (gcc::context *ctxt);
+#endif
 extern rtl_opt_pass *make_pass_rtl_fwprop (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_rtl_fwprop_addr (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_jump (gcc::context *ctxt);
diff -rNu gcc-4.9.2/gcc/tree-ssa-loop-ivopts.c test/gcc-4.9.2/gcc/tree-ssa-loop-ivopts.c
--- gcc-4.9.2/gcc/tree-ssa-loop-ivopts.c	2014-08-06 19:42:22.000000000 +0800
+++ test/gcc-4.9.2/gcc/tree-ssa-loop-ivopts.c	2018-04-02 14:15:41.000000000 +0800
@@ -2392,6 +2392,8 @@
   return false;
 }
 
+#define WANT_LOAD_UPDATES (flag_use_load_updates == 1)
+
 /* If possible, adds autoincrement candidates BASE + STEP * i based on use USE.
    Important field is set to IMPORTANT.  */
 
@@ -2421,7 +2423,10 @@
        && GET_MODE_SIZE (mem_mode) == cstepi)
       || ((USE_LOAD_PRE_DECREMENT (mem_mode)
 	   || USE_STORE_PRE_DECREMENT (mem_mode))
-	  && GET_MODE_SIZE (mem_mode) == -cstepi))
+	  && GET_MODE_SIZE (mem_mode) == -cstepi)
+      || (WANT_LOAD_UPDATES && HAVE_PRE_MODIFY_DISP
+	  && (GET_MODE_SIZE (mem_mode) != 0
+	      && cstepi % GET_MODE_SIZE (mem_mode) == 0)))
     {
       enum tree_code code = MINUS_EXPR;
       tree new_base;
@@ -3215,6 +3220,7 @@
 {
   AINC_PRE_INC,		/* Pre increment.  */
   AINC_PRE_DEC,		/* Pre decrement.  */
+  AINC_PRE_MOD,		/* Pre Modify */
   AINC_POST_INC,	/* Post increment.  */
   AINC_POST_DEC,	/* Post decrement.  */
   AINC_NONE		/* Also the number of auto increment types.  */
@@ -3241,6 +3247,7 @@
   address_cost_data data;
   static bool has_preinc[MAX_MACHINE_MODE], has_postinc[MAX_MACHINE_MODE];
   static bool has_predec[MAX_MACHINE_MODE], has_postdec[MAX_MACHINE_MODE];
+  static bool has_premod_d[MAX_MACHINE_MODE];
   unsigned cost, acost, complexity;
   enum ainc_type autoinc_type;
   bool offset_p, ratio_p, autoinc;
@@ -3358,6 +3365,14 @@
 	    data->ainc_costs[AINC_POST_INC]
 	      = address_cost (addr, mem_mode, as, speed);
 	}
+      if (WANT_LOAD_UPDATES && HAVE_PRE_MODIFY_DISP)
+	{
+	  addr = gen_rtx_PRE_MODIFY (address_mode, reg0,
+	                             gen_rtx_PLUS (address_mode, reg0,
+	                                           GEN_INT (cstep)));
+	  has_premod_d[mem_mode]
+	    = memory_address_addr_space_p (mem_mode, addr, as);
+	}
       for (i = 0; i < 16; i++)
 	{
 	  sym_p = i & 1;
@@ -3466,7 +3481,8 @@
 	      fprintf (dump_file, "index costs %d\n", acost);
 	    }
 	  if (has_predec[mem_mode] || has_postdec[mem_mode]
-	      || has_preinc[mem_mode] || has_postinc[mem_mode])
+	      || has_preinc[mem_mode] || has_postinc[mem_mode]
+	      || (WANT_LOAD_UPDATES && has_premod_d[mem_mode]))
 	    fprintf (dump_file, "  May include autoinc/dec\n");
 	  fprintf (dump_file, "\n");
 	}
@@ -3503,6 +3519,11 @@
       else if (has_predec[mem_mode] && autoinc_offset == -msize
 	       && msize == -cstep)
 	autoinc_type = AINC_PRE_DEC;
+      else if (WANT_LOAD_UPDATES && has_premod_d[mem_mode]
+               && msize != 0
+               && autoinc_offset % msize == 0
+               && cstep % msize == 0)
+	autoinc_type = AINC_PRE_MOD;
 
       if (autoinc_type != AINC_NONE)
 	autoinc = true;
@@ -3523,7 +3544,7 @@
 
   if (may_autoinc)
     *may_autoinc = autoinc;
-  if (autoinc)
+  if (autoinc && (autoinc_type != AINC_PRE_MOD))
     acost = data->ainc_costs[autoinc_type];
   else
     acost = data->costs[symbol_present][var_present][offset_p][ratio_p];
@@ -5671,6 +5692,69 @@
       }
   fprintf (file, "\n\n");
 }
+/* Find out if the given iv use pattern for a given candidate which would
+ * generate two sequential load indexes so that they can be pipelined and
+ * result in performance improvement over one load update and load index.
+ * Below are the heuristics.
+ * 1)IV candidate base object should be same as that of IV uses for which
+ *   two loads would be generated.
+ * 2)base values of two uses should be different and the first base should
+ *   be just an object name.
+ * 3)both the uses should be consecutive.
+ *   returns true if above hueristics are matched otherwise return false.
+ */
+static bool
+iv_use_pipeline_possibility (struct ivopts_data *data,struct iv_ca *ivs,
+                             struct iv_cand *cand)
+{
+  unsigned i,count = 0;
+  struct iv_use *use;
+  int base_check = true;
+  tree cand_base_obj,base_obj;
+  tree cur_base = NULL,prev_base = NULL;
+  cand_base_obj = cand->iv->base_object;
+
+  if (cand_base_obj)
+   STRIP_NOPS (cand_base_obj);
+  for (i = 0; i < ivs->upto; i++)
+    {
+      use = iv_use (data, i);
+      base_obj = use->iv->base_object;
+      cur_base = use->iv->base;
+      if (cur_base)
+        {
+          STRIP_NOPS (cur_base);
+        }
+      if (base_obj)
+        {
+          STRIP_NOPS (base_obj);
+        }
+      if (count == 2)
+       break;
+      if (prev_base && count == 1)
+	{
+         if (TREE_CODE (prev_base) == SSA_NAME &&
+             TREE_CODE (cur_base) != SSA_NAME)
+          base_check=true;
+         else
+          base_check = false;
+        }
+      else
+       base_check = true;
+	
+      if ((cand_base_obj == base_obj) &&
+           (use->type == USE_ADDRESS) && base_check)
+       count++;
+      else
+       count = 0;
+ 
+       prev_base = cur_base;
+    }
+     if (count == 2)
+      return true;
+     else
+      return false;
+}
 
 /* Try changing candidate in IVS to CAND for each use.  Return cost of the
    new set, and store differences in DELTA.  Number of induction variables
@@ -5707,6 +5791,10 @@
       if (!min_ncand && !cheaper_cost_pair (new_cp, old_cp))
         continue;
 
+      if (flag_use_seq_load_indexes &&
+          iv_use_pipeline_possibility (data,ivs,cand))
+        continue;
+
       *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);
     }
 
diff -rNu gcc-4.9.2/gcc/varasm.c test/gcc-4.9.2/gcc/varasm.c
--- gcc-4.9.2/gcc/varasm.c	2014-04-11 19:45:44.000000000 +0800
+++ test/gcc-4.9.2/gcc/varasm.c	2018-04-02 14:15:36.000000000 +0800
@@ -3881,7 +3881,7 @@
   targetm.asm_out.internal_label (asm_out_file, "LC", desc->labelno);
 
   /* Output the data.  */
-  output_constant_pool_2 (desc->mode, x, align);
+  output_constant_pool_2 (desc->mode, x, desc->align);
 
   /* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS
      sections have proper size.  */
diff -rNu gcc-4.9.2/gcc/widen-types.c test/gcc-4.9.2/gcc/widen-types.c
--- gcc-4.9.2/gcc/widen-types.c	1970-01-01 08:00:00.000000000 +0800
+++ test/gcc-4.9.2/gcc/widen-types.c	2018-04-02 14:15:31.000000000 +0800
@@ -0,0 +1,1453 @@
+/*
+ Type Widening:
+  
+ Locals and temporaries having signed integral types, whose address has
+ not been taken, are not volatile qualified, and having type precision
+ less than that of type long are widened to type long (with any other
+ qualifiers retained).
+ 
+   Copyright (C) 2011
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#include "tree.h"
+#include "stor-layout.h"
+#include "basic-block.h"
+#include "tree-ssa-alias.h"
+#include "internal-fn.h"
+#include "gimple-expr.h"
+#include "is-a.h"
+#include "gimple.h"
+#include "gimple-iterator.h"
+#include "tree-cfg.h"
+#include "langhooks.h"
+#include "tree-pass.h"
+#include "diagnostic-core.h"
+#include "pointer-set.h"
+
+/* define TW_FINALIZE_STMTS to 1, if you want to run the widening
+ * pass just after gimplification - over the sequence of statements.
+ */
+#define TW_FINALIZE_STMTS 1
+
+#define TW_DEBUG 0
+#if TW_DEBUG
+
+#define TWDBG_STMT(stmt) fprintf (stderr, "%s: ", __FUNCTION__); \
+                         debug_gimple_stmt (stmt);
+
+#define TWDBG_TREE(tree)            \
+{                                   \
+  fprintf (stderr, "%s:\n", #tree); \
+  debug_tree (tree);                \
+  fprintf (stderr, "\n");           \
+}
+
+#define TWDBG_MSG(fmt) \
+fprintf (stderr, "%s: ", __FUNCTION__); \
+fprintf (stderr, fmt)
+
+#define TWDBG_MSG1(fmt, msg) \
+fprintf (stderr, "%s: ", __FUNCTION__); \
+fprintf (stderr, fmt, msg)
+
+#else
+#define TWDBG_STMT(stmt)
+#define TWDBG_TREE(tree)
+#define TWDBG_MSG(fmt)
+#define TWDBG_MSG1(fmt, msg)
+#endif
+
+#if TW_DEBUG
+static void tw_dump_candidate_list (void);
+static bool tw_debug_candidate (const void *t, void **candidacy, void *data);
+#endif
+static void tw_init (void);
+static void tw_reset (void);
+static long tw_candidate (tree node);
+static long tw_candidate_const (tree node);
+static long *tw_log_candidate (tree node);
+static long tw_candidacy_valid (tree node);
+static void tw_candidacy (tree node, long value);
+static long tw_in_candidate_list (tree node);
+static tree tw_widen_constant (tree node);
+static tree tw_widen_variable (tree node);
+#ifdef TW_FINALIZE_STMTS
+static long tw_fn_has_openmp (gimple_seq stmts);
+#endif
+static void tw_log_parms (tree fndecl);
+#ifdef TW_FINALIZE_STMTS
+static void tw_log_vars (gimple_seq stmts);
+#endif
+static void tw_log_local_decls (void);
+#ifdef TW_FINALIZE_STMTS
+static bool gate_tw_stmts (void);
+static unsigned int tw_finalize_stmts (void);
+#endif
+static bool gate_tw_bbs (void);
+static unsigned int tw_finalize_bbs (void);
+static long tw_gimple_in_seq (gimple_seq stmts, long widen);
+static long tw_gimple_in_bb (basic_block bb, long widen);
+static long tw_switch (gimple stmt, long widen);
+static long tw_gimple_stmt (gimple stmt, long widen);
+static long tw_gimple_assign (gimple stmt, long widen);
+static long tw_gimple_assign_single (gimple stmt, long widen);
+static long tw_gimple_assign_unary (gimple stmt, long widen);
+static long tw_gimple_assign_binary (gimple stmt, long widen);
+static long tw_gimple_assign_ternary (gimple stmt, long widen);
+static bool is_formatted_IO_fn (tree decl);
+static long tw_gimple_call (gimple stmt, long widen);
+static long tw_gimple_comparison (gimple stmt, long widen);
+static long tw_gimple_switch (gimple stmt, long widen);
+static long tw_gimple_return (gimple stmt, long widen);
+static long tw_gimple_asm (gimple stmt, long widen);
+static long tw_gimple_debug (gimple stmt, long widen);
+
+static struct pointer_map_t *tw_candidate_list;
+
+#if TW_DEBUG
+static void
+tw_dump_candidate_list (void)
+{
+  TWDBG_MSG ("Dumping candidate list:\n"); 
+  pointer_map_traverse (tw_candidate_list, tw_debug_candidate, NULL);
+  TWDBG_MSG ("Done dumping candidate list\n"); 
+}
+
+static
+bool tw_debug_candidate (const void *t, void **candidacy, void *data)
+{
+  debug_tree (t);
+  fprintf(stderr, "candidacy: %ld\n data (ignore): %p", *((long *) candidacy), data);
+  return true;
+}
+#endif
+
+static void
+tw_init (void)
+{
+  gcc_assert (tw_candidate_list == NULL);
+  tw_candidate_list = pointer_map_create ();
+}
+
+static void
+tw_reset (void)
+{
+  if (tw_candidate_list)
+    {
+      pointer_map_destroy (tw_candidate_list);
+      tw_candidate_list = NULL;
+    }
+}
+
+/* gcc.dg/torture/pr43879_[12].c
+ * Initialized statics should not be widened:
+ *
+ * void bar(int c)
+ * {
+ *  static int x = 1; // if widened, x gets initialized to (2^32)
+ *  if (c != x) __builtin_abort();
+ *   x--;
+ * }
+ *
+ *  int main()
+ *  {
+ *   int c = 1;
+ *   bar (1);
+ *   return 0;
+ *  }
+ *
+ * Likely, the initial value is laid out/translated to RTL way before
+ * the rest of the code is translated to GIMPLE; so when we widen the
+ * type, it's already too late.
+ */
+
+/* tw_candidate() has no way to tell if it was passed a local variable
+ * (or not) - so make sure it is passed local variables or parameters only.
+ */
+static long
+tw_candidate (tree node)
+{
+  long rv = 0;
+
+  if (!node || TREE_TYPE (node) == error_mark_node)
+    return 0;
+
+  if (node && TREE_TYPE (node) != error_mark_node &&
+      ((TREE_CODE (node) == VAR_DECL &&
+        /* See note: Initialized statics should not be widened. */
+        (!TREE_STATIC (node) || !DECL_INITIAL (node))) ||
+       TREE_CODE (node) == PARM_DECL ||
+       TREE_CODE (node) == DEBUG_EXPR_DECL) &&
+      !TYPE_VOLATILE (TREE_TYPE (node)) &&
+      !TREE_ADDRESSABLE (node) &&
+      !POINTER_TYPE_P (TREE_TYPE (node)) &&
+      INTEGRAL_TYPE_P (TREE_TYPE (node)) &&
+      !TYPE_UNSIGNED (TREE_TYPE (node))  &&
+      (TYPE_PRECISION (TREE_TYPE (node)) < TYPE_PRECISION (long_integer_type_node)))
+    rv = 1;
+  return rv;
+}
+
+static long
+tw_candidate_const (tree node)
+{
+  long rv = 0;
+
+  if (node && TREE_TYPE (node) != error_mark_node &&
+      INTEGRAL_TYPE_P (TREE_TYPE (node)) &&
+      TREE_CONSTANT (node) &&
+      (TYPE_PRECISION (TREE_TYPE (node)) < TYPE_PRECISION (long_integer_type_node)))
+    rv = 1;
+  return rv;
+}
+
+static long *
+tw_log_candidate (tree node)
+{
+  long *pval = NULL;
+
+  if (tw_candidate_list && node && TREE_TYPE (node) != error_mark_node)
+    {
+      pval = (long *) pointer_map_contains (tw_candidate_list, node);
+      if (!pval)
+        {
+          pval = (long *) pointer_map_insert (tw_candidate_list, node);
+          *pval = 1;
+          TWDBG_MSG ("Logged variable:\n");
+          TWDBG_TREE (node);
+        }
+    }
+  return pval; 
+}
+
+static long
+tw_candidacy_valid (tree node)
+{
+  long rval = 0;
+  long *pval = NULL;
+
+  if (tw_candidate_list && node && TREE_TYPE (node) != error_mark_node)
+    pval = (long *) pointer_map_contains (tw_candidate_list, node); 
+  if (pval)
+    rval = *pval ? 1 : 0;
+  return rval;
+}
+
+static void
+tw_candidacy (tree node, long value)
+{
+  long *pval;
+
+  if (tw_candidate_list && node)
+    {
+      pval = (long *) pointer_map_contains (tw_candidate_list, node);
+      if (pval)
+        {
+          *pval = value;
+#if TW_DEBUG
+          fprintf (stderr, "Setting candidacy of node:\n");
+          TWDBG_TREE (node);
+          fprintf (stderr, "to: %ld\n", value);
+#endif
+        }
+    }
+}
+
+static long
+tw_in_candidate_list (tree node)
+{
+  long *pval;
+  long rval = 0;
+
+  if (tw_candidate_list && node && TREE_TYPE (node) != error_mark_node)
+    {
+     pval = (long *) pointer_map_contains (tw_candidate_list, node);
+     rval = pval ? 1 : 0;
+    }
+  return rval;
+}
+
+static tree
+tw_widen_constant (tree node)
+{
+  if (node && tw_candidate_const (node))
+    node = build_int_cst (long_integer_type_node, TREE_INT_CST_LOW (node));
+
+  return node;
+}
+
+static tree
+tw_widen_variable (tree node)
+{
+  if (node && tw_candidacy_valid (node))
+  {
+    TWDBG_MSG ("Widening:\n");
+    TWDBG_TREE(node);
+
+    TREE_TYPE (node) = build_qualified_type (long_integer_type_node,
+                                             TYPE_QUALS (TREE_TYPE (node)));
+
+    if (TREE_CODE (node) != DEBUG_EXPR_DECL)
+      relayout_decl (node);
+  }
+  return node;
+}
+
+#ifdef TW_FINALIZE_STMTS
+static long
+tw_fn_has_openmp (gimple_seq stmts)
+{
+  gimple_stmt_iterator ittr;
+  long found_openmp = 0;
+
+  for (ittr = gsi_start (stmts); !gsi_end_p (ittr) && !found_openmp; gsi_next (&ittr))
+    {
+      gimple stmt = gsi_stmt (ittr);
+
+      switch (gimple_code (stmt))
+        {
+	case GIMPLE_BIND:
+	  found_openmp = tw_fn_has_openmp (gimple_bind_body (stmt));
+	  break;
+
+	case GIMPLE_TRY:
+	  found_openmp = tw_fn_has_openmp (gimple_try_eval (stmt));
+	  found_openmp = tw_fn_has_openmp (gimple_try_cleanup (stmt));
+	  break;
+
+	case GIMPLE_EH_FILTER:
+	  found_openmp = tw_fn_has_openmp (gimple_eh_filter_failure (stmt));
+	  break;
+
+	case GIMPLE_CATCH:
+	  found_openmp = tw_fn_has_openmp (gimple_catch_handler (stmt));
+	  break;
+
+	default:
+          switch (gimple_code (stmt))
+            {
+            CASE_GIMPLE_OMP:
+            found_openmp = 1;
+            break;
+            default:
+            break;
+            }
+	}
+    }
+  return found_openmp;  
+}
+#endif
+
+static
+void
+tw_log_parms (tree fndecl)
+{
+  tree parm;
+
+  if (!fndecl)
+    return;
+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))
+    if (tw_candidate (parm))
+      tw_log_candidate (parm);
+  return;
+}
+
+#ifdef TW_FINALIZE_STMTS
+static
+void
+tw_log_vars (gimple_seq stmts)
+{
+  gimple_stmt_iterator ittr;
+  tree vars, vindex;
+
+  if (!stmts)
+    return;
+
+  gcc_assert (tw_candidate_list != NULL);
+
+  for (ittr = gsi_start (stmts); !gsi_end_p (ittr); gsi_next (&ittr))
+    {
+      gimple stmt = gsi_stmt (ittr);
+
+      switch (gimple_code (stmt))
+        {
+	case GIMPLE_BIND:
+          vars = gimple_bind_vars (stmt);
+          for (vindex = vars; vindex; vindex = DECL_CHAIN (vindex))
+            if (tw_candidate (vindex))
+              tw_log_candidate (vindex);
+          tw_log_vars (gimple_bind_body (stmt));
+	  break;
+
+	case GIMPLE_TRY:
+	  tw_log_vars (gimple_try_eval (stmt));
+	  tw_log_vars (gimple_try_cleanup (stmt));
+	  break;
+
+	case GIMPLE_EH_FILTER:
+	  tw_log_vars (gimple_eh_filter_failure (stmt));
+	  break;
+
+	case GIMPLE_CATCH:
+	  tw_log_vars (gimple_catch_handler (stmt));
+	  break;
+
+	default:
+          break;
+	}
+    }
+
+  return;
+}
+#endif
+
+static
+void
+tw_log_local_decls (void)
+{
+  tree decl;
+  unsigned ix;
+
+  FOR_EACH_LOCAL_DECL (cfun, ix, decl)
+    {
+      TWDBG_MSG ("Testing decl:\n");
+      TWDBG_TREE (decl);
+      if (tw_candidate (decl))
+        tw_log_candidate (decl);
+    }
+}
+
+/* Assumes that we have run verify_gimple_in_seq (stmts)
+ * i.e. that we have valid gimple.
+ */
+static long
+tw_gimple_in_seq (gimple_seq stmts, long widen)
+{
+  gimple_stmt_iterator ittr;
+  long iv = 0;
+
+  for (ittr = gsi_start (stmts); !gsi_end_p (ittr); gsi_next (&ittr))
+    {
+      gimple stmt = gsi_stmt (ittr);
+      iv += tw_switch (stmt, widen);
+    }
+  return iv;  
+}
+
+static long
+tw_gimple_in_bb (basic_block bb, long widen)
+{
+  gimple_stmt_iterator ittr;
+  long iv = 0;
+
+#if TW_DEBUG
+  fprintf (stderr, "Dumping basic block (widen = %ld):\n", widen);
+  debug_bb (bb);
+  fprintf (stderr, "Done dumping basic block (widen = %ld)\n", widen);
+#endif
+  for (ittr = gsi_start_bb (bb); !gsi_end_p (ittr); gsi_next (&ittr))
+    {
+      gimple stmt = gsi_stmt (ittr);
+      iv += tw_switch (stmt, widen);
+    }
+  return iv;  
+}
+
+static long
+tw_switch (gimple stmt, long widen)
+{
+  long iv = 0;
+
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_BIND:
+      iv += tw_gimple_in_seq (gimple_bind_body (stmt), widen);
+      break;
+
+    case GIMPLE_TRY:
+      iv += tw_gimple_in_seq (gimple_try_eval (stmt), widen);
+      iv += tw_gimple_in_seq (gimple_try_cleanup (stmt), widen);
+      break;
+
+    case GIMPLE_EH_FILTER:
+      iv += tw_gimple_in_seq (gimple_eh_filter_failure (stmt), widen);
+      break;
+
+    case GIMPLE_CATCH:
+      iv += tw_gimple_in_seq (gimple_catch_handler (stmt), widen);
+      break;
+
+    default:
+      iv += tw_gimple_stmt (stmt, widen);
+      break;
+    }
+  return iv;  
+}
+
+/* tw_gimple_stmt () mimics verify_gimple_stmt ()
+ */
+static long
+tw_gimple_stmt (gimple stmt, long widen)
+{
+  long iv = 0;
+
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_ASSIGN:
+      iv = tw_gimple_assign (stmt, widen);
+      break;
+
+    case GIMPLE_CALL:
+      iv = tw_gimple_call (stmt, widen);
+      break;
+
+    case GIMPLE_COND:
+      iv = tw_gimple_comparison (stmt, widen);
+      break;
+
+    case GIMPLE_SWITCH:
+      iv = tw_gimple_switch (stmt, widen);
+      break;
+
+    case GIMPLE_RETURN:
+      iv = tw_gimple_return (stmt, widen);
+      break;
+
+    case GIMPLE_LABEL:
+      TWDBG_STMT(stmt);
+      break;
+
+    case GIMPLE_GOTO:
+      TWDBG_STMT(stmt);
+      break;
+
+    case GIMPLE_ASM:
+      iv = tw_gimple_asm (stmt, widen);
+      break;
+
+    /* Tuples that do not have tree operands.  */
+    case GIMPLE_NOP:
+    case GIMPLE_PREDICT:
+    case GIMPLE_RESX:
+    case GIMPLE_EH_DISPATCH:
+    case GIMPLE_EH_MUST_NOT_THROW:
+      TWDBG_STMT(stmt);
+      break;
+
+    CASE_GIMPLE_OMP:
+      TWDBG_STMT(stmt);
+      break;
+
+    case GIMPLE_DEBUG:
+      iv = tw_gimple_debug (stmt, widen);
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+  return iv;  
+}
+
+static long
+tw_gimple_assign (gimple stmt, long widen)
+{
+  long iv = 0;
+
+  switch (gimple_assign_rhs_class (stmt))
+    {
+    case GIMPLE_SINGLE_RHS:
+      iv = tw_gimple_assign_single (stmt, widen);
+      break;
+
+    case GIMPLE_UNARY_RHS:
+      iv = tw_gimple_assign_unary (stmt, widen);
+      break;
+
+    case GIMPLE_BINARY_RHS:
+      iv = tw_gimple_assign_binary (stmt, widen);
+      break;
+
+    case GIMPLE_TERNARY_RHS:
+      iv = tw_gimple_assign_ternary (stmt, widen);
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+  return iv;  
+}
+
+static long
+tw_gimple_assign_single (gimple stmt, long widen)
+{
+  tree lhs = gimple_assign_lhs (stmt);
+  tree rhs1 = gimple_assign_rhs1 (stmt);
+  tree value;
+  long iv = 0;
+  unsigned int idx;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(lhs);
+  TWDBG_TREE(rhs1);
+
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      if (TREE_CODE (rhs1) == ARRAY_REF &&
+          tw_candidacy_valid (TREE_OPERAND (rhs1, 1)))
+        {
+          /* Note that we are widening the array index, hence no 
+           * gimple_assign_set_rhs1 () */
+          tw_widen_variable (TREE_OPERAND (rhs1, 1));
+        }
+      else if (TREE_CODE (lhs) == ARRAY_REF &&
+          tw_candidacy_valid (TREE_OPERAND (lhs, 1)))
+        {
+          /* Note that we are widening the array index, hence no 
+           * gimple_assign_set_lhs () */
+          tw_widen_variable (TREE_OPERAND (lhs, 1));
+        }
+      else if (tw_candidacy_valid (lhs) && tw_candidate_const (rhs1))
+        {
+          gimple_assign_set_lhs (stmt, tw_widen_variable (lhs));
+          gimple_assign_set_rhs1 (stmt, tw_widen_constant (rhs1));
+        }
+      else if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs1))
+        {
+          gimple_assign_set_lhs (stmt, tw_widen_variable (lhs));
+          gimple_assign_set_rhs1 (stmt, tw_widen_variable (rhs1));
+        }
+    }
+  else
+    {
+      TWDBG_MSG ("Validating run.\n");
+      if (tw_candidacy_valid (lhs) && tw_candidate_const (rhs1))
+        return iv;
+      if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs1))
+        return iv;
+      if (TREE_CODE (lhs) == VAR_DECL && TREE_CODE (TREE_TYPE (lhs)) == VECTOR_TYPE &&
+          TREE_CODE (rhs1) == CONSTRUCTOR && TREE_CODE (TREE_TYPE (rhs1)) == VECTOR_TYPE)
+        { 
+          FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs1), idx, value)
+            {
+              if (tw_candidacy_valid (value))
+                {
+                  TWDBG_MSG ("Invalidating candidacy of constructor element:\n");
+                  TWDBG_TREE (value);
+                  tw_candidacy (value, 0);
+                  iv++;
+                }
+            }
+        }
+      if (tw_candidacy_valid (lhs))
+        {
+          tw_candidacy (lhs, 0);
+          iv++;
+        }
+      if (tw_candidacy_valid (rhs1))
+        {
+          tw_candidacy (rhs1, 0);
+          iv++;
+        }
+    }
+  return iv;
+}
+
+static long
+tw_gimple_assign_unary (gimple stmt, long widen)
+{
+  tree lhs = gimple_assign_lhs (stmt);
+  tree rhs1 = gimple_assign_rhs1 (stmt);
+  long iv = 0;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(lhs);
+  TWDBG_TREE(rhs1);
+  
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      if (gimple_assign_rhs_code (stmt) == NOP_EXPR &&
+          tw_candidacy_valid (rhs1) &&
+          (TREE_TYPE (lhs) == long_unsigned_type_node ||
+           TREE_TYPE (lhs) == long_integer_type_node))
+        gimple_assign_set_rhs1 (stmt, tw_widen_variable (rhs1));
+    }
+  else
+    {
+      TWDBG_MSG ("Validating run.\n");
+      if (gimple_assign_rhs_code (stmt) == NOP_EXPR &&
+          tw_candidacy_valid (rhs1) &&
+          (TREE_TYPE (lhs) == long_unsigned_type_node ||
+           TREE_TYPE (lhs) == long_integer_type_node))
+        return iv;
+      if (tw_candidacy_valid (lhs))
+        {
+          tw_candidacy (lhs, 0);
+          iv++;
+        }
+      if (tw_candidacy_valid (rhs1))
+        {
+          tw_candidacy (rhs1, 0);
+          iv++;
+        }
+    }
+    return iv;
+}
+
+static long
+tw_gimple_assign_binary (gimple stmt, long widen)
+{
+  tree lhs = gimple_assign_lhs (stmt);
+  tree rhs1 = gimple_assign_rhs1 (stmt);
+  tree rhs2 = gimple_assign_rhs2 (stmt);
+  long iv = 0;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(lhs);
+  TWDBG_TREE(rhs1);
+  TWDBG_TREE(rhs2);
+
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs1) && tw_candidate_const (rhs2))
+        {
+          gimple_assign_set_lhs (stmt, tw_widen_variable (lhs));
+          gimple_assign_set_rhs1 (stmt, tw_widen_variable (rhs1));
+          gimple_assign_set_rhs2 (stmt, tw_widen_constant (rhs2));
+        }
+      else if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs1) && tw_candidacy_valid (rhs2))
+        {
+          gimple_assign_set_lhs (stmt, tw_widen_variable (lhs));
+          gimple_assign_set_rhs1 (stmt, tw_widen_variable (rhs1));
+          gimple_assign_set_rhs2 (stmt, tw_widen_variable (rhs2));
+        }
+    }
+  else
+    {
+      TWDBG_MSG ("Validating run.\n");
+      if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs1) && tw_candidate_const (rhs2))
+        return iv;
+      if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs1) && tw_candidacy_valid (rhs2))
+        return iv;
+      if (tw_candidacy_valid (lhs))
+        {
+          tw_candidacy (lhs, 0);
+          iv++;
+        }
+      if (tw_candidacy_valid (rhs1))
+        {
+          tw_candidacy (rhs1, 0);
+          iv++;
+        }
+      if (tw_candidacy_valid (rhs2))
+        {
+          tw_candidacy (rhs2, 0);
+          iv++;
+        }
+    }
+    return iv;
+}
+
+static long
+tw_gimple_assign_ternary (gimple stmt, long widen)
+{
+  tree lhs = gimple_assign_lhs (stmt);
+  tree rhs1 = gimple_assign_rhs1 (stmt);
+  tree rhs2 = gimple_assign_rhs2 (stmt);
+  tree rhs3 = gimple_assign_rhs3 (stmt);
+  long iv = 0;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(lhs);
+  TWDBG_TREE(rhs1);
+  TWDBG_TREE(rhs2);
+  TWDBG_TREE(rhs3);
+
+  if (widen)
+    {
+     TWDBG_MSG ("Widening run.\n");
+     return iv;
+    }
+
+  TWDBG_MSG ("Validating run.\n");
+  if (tw_candidacy_valid (lhs))
+    {
+      tw_candidacy (lhs, 0);
+      iv++;
+    }
+  if (tw_candidacy_valid (rhs1))
+    {
+      tw_candidacy (rhs1, 0);
+      iv++;
+    }
+  if (tw_candidacy_valid (rhs2))
+    {
+      tw_candidacy (rhs2, 0);
+      iv++;
+    }
+  if (tw_candidacy_valid (rhs3))
+    {
+      tw_candidacy (rhs3, 0);
+      iv++;
+    }
+  return iv;
+}
+
+/* Ref. WG14/N1256 Committee Draft - September 7, 2007 ISO/IEC 9899:TC3
+ * 7.19.6 Formatted input/output functions
+ * Sec. 17.19.6.[1 ... 14]
+ */
+#define IO_FN_COUNT 14
+static const char *IO_fn_names[IO_FN_COUNT] =
+{
+  "fprintf", "fscanf",
+  "printf",  "scanf",
+  "snprintf",
+  "sprintf", "sscanf",
+  "vfprintf", "vfscanf",
+  "vprintf", "vscanf",
+  "vsnprintf",
+  "vsprintf", "vsscanf",
+};
+
+static bool
+is_formatted_IO_fn (tree decl)
+{
+  const char *fn_name;
+  long i;
+
+  if (decl && TREE_CODE (decl) == FUNCTION_DECL &&
+      DECL_NAME (decl) /* TREE_CODE (decl) == IDENTIFIER_NODE */ &&
+      (fn_name = IDENTIFIER_POINTER (DECL_NAME (decl))))
+    {
+      for (i = 0; i < IO_FN_COUNT; i++)
+        if (strcmp (IO_fn_names[i], fn_name) == 0)
+          return true;
+    }
+  return false;
+}
+
+/* TODO: If you have:
+ * 
+ *  int i, n, f();
+ *
+ *  n = f();
+ *
+ *  for (i = 0; i < n; i++) 
+ *    // stuff
+ *
+ *  then (after the candidate set stabilizes) do:
+ *
+ *  int n, f();
+ *  long twl.n;
+ *
+ *  n = f();
+ *  twl.n = (long) n;
+ *
+ *  for (i = 0; i < twl.n; i++) 
+ *    // stuff
+ *
+ *  only if adding twl.n does not decrease the size of the stabilized
+ *  candidate set or "cause any other damage".
+ *
+ * This should help in benchmarks where parameters are set via function
+ * calls to prevent them from being optimized away.
+ *
+ */
+static long
+tw_gimple_call (gimple stmt, long widen)
+{
+#if TW_DEBUG
+  tree fn = gimple_call_fn (stmt);
+#endif
+  long iv = 0;
+  unsigned i;
+  tree arg;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(fn);
+  TWDBG_TREE(gimple_call_fndecl (stmt));
+
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      for (i = 0; i < gimple_call_num_args (stmt); i++)
+        {
+          arg = gimple_call_arg (stmt, i);
+          if (arg && tw_candidacy_valid (arg))
+            gimple_call_set_arg (stmt, i, tw_widen_variable (arg));
+        }
+      return iv;
+    }
+
+  TWDBG_MSG ("Validating run.\n");
+  if (gimple_call_lhs (stmt) && tw_candidacy_valid (gimple_call_lhs (stmt)))
+    {
+      tw_candidacy (gimple_call_lhs (stmt), 0);
+      iv++;
+    }
+  if (gimple_call_fndecl (stmt) &&
+      (is_builtin_fn (gimple_call_fndecl (stmt)) ||
+       is_formatted_IO_fn (gimple_call_fndecl (stmt))))
+    {
+      /* Certain types of function (printf-scanf family,
+       * formatted IO functions, builtin functions) ought
+       * not to have their args widened.
+       *
+       * e.g. A call to printf () such as:
+       * int x;
+       * printf ("%d", x);
+       * because, we cannot change the %d to a %ld.
+       *
+       * or e.g. in:
+       *
+       * int D.2852;
+       * int si;
+       *
+       * si = 2;
+       * __builtin_altivec_dst (&vi, si, 0);
+       * D.2852 = 0;
+       *
+       * si should not be widened.
+       *
+       * PS: We could generate code for casts to their original types in the
+       *     call, but that would slow-down performance and we do not expect
+       *     a loop index to be used in a call to a formatted IO function.
+       */
+      for (i = 0; i < gimple_call_num_args (stmt); i++)
+        {
+          arg = gimple_call_arg (stmt, i);
+          if (arg && tw_candidacy_valid (arg))
+            {
+              tw_candidacy (arg, 0);
+              iv++;
+            }
+        }
+    }
+  return iv;
+}
+
+static long
+tw_gimple_comparison (gimple stmt, long widen)
+{
+  tree lhs = gimple_cond_lhs (stmt);
+  tree rhs = gimple_cond_rhs (stmt);
+  long iv = 0;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(lhs); 
+  TWDBG_TREE(rhs); 
+
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      if (tw_candidacy_valid (lhs) && tw_candidate_const (rhs))
+        {
+          gimple_cond_set_lhs (stmt, tw_widen_variable (lhs));
+          gimple_cond_set_rhs (stmt, tw_widen_constant (rhs));
+        }
+      else if (tw_candidate_const (lhs) && tw_candidacy_valid (rhs))
+        {
+          gimple_cond_set_lhs (stmt, tw_widen_constant (lhs));
+          gimple_cond_set_rhs (stmt, tw_widen_variable (rhs));
+        }
+      else if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs))
+        {
+          gimple_cond_set_lhs (stmt, tw_widen_variable (lhs));
+          gimple_cond_set_rhs (stmt, tw_widen_variable (rhs));
+        }
+    }
+  else
+    {
+      TWDBG_MSG ("Validating run.\n");
+      if (tw_candidacy_valid (lhs) && tw_candidate_const (rhs))
+        return iv;
+      if (tw_candidate_const (lhs) && tw_candidacy_valid (rhs))
+        return iv;
+      if (tw_candidacy_valid (lhs) && tw_candidacy_valid (rhs))
+        return iv;
+      if (tw_candidacy_valid (lhs))
+        {
+          tw_candidacy (lhs, 0);
+          iv++;
+        }
+      if (tw_candidacy_valid (rhs))
+        {
+          tw_candidacy (rhs, 0);
+          iv++;
+        }
+    }
+  return iv;
+}
+
+static long
+tw_gimple_switch (gimple stmt, long widen)
+{
+  tree index = gimple_switch_index (stmt);
+  long iv = 0;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(index); 
+
+  if (widen && tw_candidacy_valid (index))
+    {
+      TWDBG_MSG ("Widening run.\n");
+      gimple_switch_set_index (stmt, tw_widen_variable (index));
+      return iv;
+    }
+   
+  TWDBG_MSG ("Validating run.\n");
+  return iv;
+}
+
+static long
+tw_gimple_return (gimple stmt, long widen)
+{
+  tree op = gimple_return_retval (stmt);
+  long iv = 0;
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(op); 
+
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      return iv;
+    }
+
+  TWDBG_MSG ("Validating run.\n");
+  if (tw_candidacy_valid (op))
+    {
+      tw_candidacy (op, 0);
+      iv++;
+    }
+  return iv;
+}
+
+static long
+tw_gimple_asm (gimple stmt, long widen)
+{
+  long iv = 0;
+  unsigned int ninputs = gimple_asm_ninputs (stmt);
+  unsigned int noutputs = gimple_asm_noutputs (stmt);
+  unsigned int nclobbers = gimple_asm_nclobbers (stmt);
+  unsigned int i;
+
+  TWDBG_STMT(stmt);
+  TWDBG_MSG("Inputs:\n");
+  for (i = 0; i < ninputs; i++)
+    {
+      TWDBG_MSG1 ("input %d\n", i);
+      TWDBG_TREE (gimple_asm_input_op (stmt, i));
+    }
+  TWDBG_MSG("Outputs:\n");
+  for (i = 0; i < noutputs; i++)
+    {
+      TWDBG_MSG1 ("output %d\n", i);
+      TWDBG_TREE (gimple_asm_output_op (stmt, i));
+    }
+  TWDBG_MSG("Clobbers:\n");
+  for (i = 0; i < nclobbers; i++)
+    {
+      TWDBG_MSG1 ("clobber %d\n", i);
+      TWDBG_TREE (gimple_asm_clobber_op (stmt, i));
+    }
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      return iv;
+    }
+  TWDBG_MSG ("Validating run.\n");
+  for (i = 0; i < ninputs; i++)
+    {
+      if (tw_candidacy_valid (gimple_asm_input_op (stmt, i)))
+        {
+          tw_candidacy (gimple_asm_input_op (stmt, i), 0);
+          iv++;
+        }
+    }
+  for (i = 0; i < noutputs; i++)
+    {
+      if (tw_candidacy_valid (gimple_asm_output_op (stmt, i)))
+        {
+          tw_candidacy (gimple_asm_output_op (stmt, i), 0);
+          iv++;
+        }
+    }
+  for (i = 0; i < nclobbers; i++)
+    {
+      if (tw_candidacy_valid (gimple_asm_clobber_op (stmt, i)))
+        {
+          tw_candidacy (gimple_asm_clobber_op (stmt, i), 0);
+          iv++;
+        }
+    }
+  return iv;
+}
+
+static long
+tw_gimple_debug (gimple stmt, long widen)
+{
+  long iv = 0;
+  tree var, value;
+
+  var = gimple_debug_bind_get_var (stmt);
+  value = gimple_debug_bind_get_value (stmt);
+
+  TWDBG_STMT(stmt);
+  TWDBG_TREE(var);
+  TWDBG_TREE(value);
+
+  /* TODO: What if the value is a constant? */
+ 
+  if (widen)
+    {
+      TWDBG_MSG ("Widening run.\n");
+      if (tw_candidacy_valid (var) && tw_candidacy_valid (value))
+        {
+          gimple_debug_bind_set_var (stmt, tw_widen_variable (var));
+          gimple_debug_bind_set_value (stmt, tw_widen_variable (value));
+        }
+      else if (tw_candidacy_valid (var) && tw_candidate_const (value))
+        {
+          gimple_debug_bind_set_var (stmt, tw_widen_variable (var));
+          gimple_debug_bind_set_value (stmt, tw_widen_constant (value));
+        }
+    }
+  else
+    {
+      TWDBG_MSG ("Validating run.\n");
+
+      if (var && !tw_in_candidate_list (var) && tw_candidate (var))
+        tw_log_candidate (var);
+      if (value && !tw_in_candidate_list (value) && tw_candidate (value))
+        tw_log_candidate (value);
+      if (tw_candidacy_valid (var) && tw_candidacy_valid (value))
+        return iv;
+      if (tw_candidacy_valid (var))
+        {
+          tw_candidacy (var, 0);
+          iv++;
+        }
+      if (tw_candidacy_valid (value))
+        {
+          tw_candidacy (value, 0);
+          iv++;
+        }
+    }
+   
+  return iv;
+}
+
+namespace {
+
+#ifdef TW_FINALIZE_STMTS
+const pass_data pass_data_widen_types_stmts =
+{
+  GIMPLE_PASS,				/* type */
+  "tw-stmts",				/* name */
+  OPTGROUP_NONE,			/* optinfo_flags */
+  true,					/* has_gate */
+  true,					/* has_execute */
+  TV_NONE,				/* tv_id */
+  PROP_gimple_any,			/* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0,					/* todo_flags_finish */
+};
+
+class pass_widen_types_stmts : public gimple_opt_pass
+{
+public:
+  pass_widen_types_stmts (gcc::context *ctxt)
+    : gimple_opt_pass (pass_data_widen_types_stmts, ctxt)
+  {}
+
+  bool gate () { return gate_tw_stmts (); }
+  unsigned int execute () { return tw_finalize_stmts (); }
+
+}; // class pass_widen_types_stmts
+#endif
+
+const pass_data pass_data_widen_types_bbs =
+{
+  GIMPLE_PASS,				/* type */
+  "tw-bbs",				/* name */
+  OPTGROUP_NONE,			/* optinfo_flags */
+  true,					/* has_gate */
+  true,					/* has_execute */
+  TV_NONE,				/* tv_id */
+  PROP_gimple_any,			/* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0,					/* todo_flags_finish */
+};
+
+class pass_widen_types_bbs : public gimple_opt_pass
+{
+public:
+  pass_widen_types_bbs (gcc::context *ctxt)
+    : gimple_opt_pass (pass_data_widen_types_bbs, ctxt)
+  {}
+
+  bool gate () { return gate_tw_bbs (); }
+  unsigned int execute () { return tw_finalize_bbs (); }
+
+}; // class pass_widen_types_bbs
+
+} // anon namespace
+
+/* Widen types. tw_finalize_stmts () can be run anytime immediately after
+ * gimplification but before the CFG pass (see comment * accompanying
+ * gimple_body ()).
+ *
+ * After gimplification has occurred, the emitted GIMPLE is
+ * scanned to check if these variables are only used among
+ * themselves (with the exception of being cast to unsigned long);
+ * invalidating the candidacy of any variable that is used with
+ * another outside this set (and so on recursively). The variables
+ * that remain after this process all occur in operations with other
+ * such candidate variables, (or with constants) - the type of all
+ * such residual candidate variables (and of constants that appear
+ * with these in operations) is changed to long (along with the
+ * original accompannying qualifiers on the type).
+ *
+ * void
+ * init_optimization_passes (void)
+ *
+ * p = &all_lowering_passes;
+ * NEXT_PASS (pass_widen_types_stmts);
+ * NEXT_PASS (pass_warn_unused_result);
+ */
+#ifdef TW_FINALIZE_STMTS
+static bool
+gate_tw_stmts (void)
+{
+  /* Skip if: Language not C or seen error or -fno-strict-overflow
+   * or -fno-widen-types or -fwrapv (gcc.dg/pr23518.c execution test */
+  return !(strcmp (lang_hooks.name, "GNU C") != 0 ||
+      seen_error () ||
+      !flag_strict_overflow ||
+      !flag_widen_types ||
+      flag_wrapv || flag_trapv);
+}
+
+static unsigned int
+tw_finalize_stmts ()
+{
+  long iv = 0;
+  gimple_seq stmts;
+  tree fndecl = current_function_decl; 
+
+  if (debug_info_level == DINFO_LEVEL_NONE)
+    {
+      /* PS: That we cannot call relayout_decl () on DEBUG_EXPR_DECL is an
+      * issue: Debug information is generated after lowering from tree to 
+      * GIMPLE; unless we widen before debug information is generated, the
+      * debug information will record pre-widening information - and that
+      * cannot be changed because relayout_decl () cannot be invoked on 
+      * DEBUG_EXPR_DECL. expand_debug_locations () during cfgexpand will
+      * fail gcc_assert ()'s on the DEBUG_INSN's since e.g. the modes will
+      * not agree, etc. So if we are compiling -g, we ought to run the 
+      * pass_widen_types_stmts.
+      *
+      * In short: pass_widen_types_stmts runs iff we're generating debug
+      *           information.
+      */
+      TWDBG_MSG ("Skipping: Debug level none.\n");
+      return 0;
+    }
+  gcc_assert (debug_info_level != DINFO_LEVEL_NONE);
+
+  if (!fndecl)
+    {
+      TWDBG_MSG ("Skipping: !fndecl.\n");
+      return 0;
+    }
+
+  TWDBG_MSG ("Widening function:\n");
+  TWDBG_TREE (fndecl);
+
+  stmts = gimple_body (fndecl);
+
+  if (!stmts)
+    {
+      TWDBG_MSG ("Skipping: !stmts.\n");
+      return 0;
+    }
+
+  if (tw_fn_has_openmp (stmts))
+    {
+      TWDBG_MSG ("Skipping: OpenMP stmts found.\n");
+      return 0;
+    }
+
+  /* Assume for now that we do not need to check for nested functions:
+   * (cgraph_get_node (fndecl) && cgraph_get_node (fndecl)->nested != NULL) ||
+   * TREE_CODE (DECL_CONTEXT (fndecl)) != TRANSLATION_UNIT_DECL ||
+   * Well, turns out that a nested function is processed only if it is 
+   * actually invoked from within the function, so we are in good shape.
+   */
+
+  tw_init ();
+  tw_log_parms (fndecl);
+  tw_log_vars (stmts);
+#if TW_DEBUG
+  tw_dump_candidate_list ();
+#endif
+
+  do
+    {
+      iv = tw_gimple_in_seq (stmts, 0);
+    } while (iv);
+  tw_gimple_in_seq (stmts, 1);
+  verify_gimple_in_seq (stmts);
+
+  tw_reset ();
+
+  return 0;
+}
+#endif
+
+static bool
+gate_tw_bbs (void)
+{
+  /* Skip if: Language not C or seen error or -fno-strict-overflow
+   * or -fno-widen-types or -fwrapv (gcc.dg/pr23518.c execution test */
+  return !(strcmp (lang_hooks.name, "GNU C") != 0 ||
+      seen_error () ||
+      !flag_strict_overflow ||
+      !flag_widen_types ||
+      flag_wrapv || flag_trapv);
+}
+
+static unsigned int
+tw_finalize_bbs ()
+{
+  long iv = 0;
+  basic_block bb;
+  tree fndecl;
+
+  if (debug_info_level != DINFO_LEVEL_NONE && flag_openmp)
+    {
+      /* Cannot run this pass as the debug information has already
+       * been recorded; If we type widen now, it'll lead to assert
+       * failures during RTL expansion in expandcfg.c since the
+       * debug information would all be prewidening and would
+       * mismatch with the postwidening information for the variables
+       * that got widened (but whoose debug information was already
+       * generated). This is all because we cannot call relayout_decl ()
+       * on DEBUG_EXPR_DECL's - see note elsewhere.
+       */
+      TWDBG_MSG ("Skipping: Non-zero debug level and -fopenmp specified.\n");
+      return 0;
+    }
+
+  if (!cfun || !(fndecl = cfun->decl) || !(cfun->cfg))
+    {
+      TWDBG_MSG ("Skipping: !cfun or !fndecl or !(cfun->cfg).\n");
+      return 0;
+    }
+
+  TWDBG_MSG ("Widening function:\n");
+  TWDBG_TREE (fndecl);
+
+  /* Assume for now that we do not need to check for nested functions:
+   * (cgraph_get_node (fndecl) && cgraph_get_node (fndecl)->nested != NULL) ||
+   * TREE_CODE (DECL_CONTEXT (fndecl)) != TRANSLATION_UNIT_DECL ||
+   * Well, turns out that a nested function is processed only if it is 
+   * actually invoked from within the function, so we are in good shape.
+   */
+
+  tw_init ();
+  tw_log_parms (fndecl);
+  tw_log_local_decls (); 
+#if TW_DEBUG
+  tw_dump_candidate_list ();
+#endif
+
+  do
+    {
+      iv = 0;
+      FOR_EACH_BB_FN (bb, cfun)
+        iv += tw_gimple_in_bb (bb, 0);
+    } while (iv);
+  FOR_EACH_BB_FN (bb, cfun)
+    tw_gimple_in_bb (bb, 1);
+  FOR_EACH_BB_FN (bb, cfun)
+    verify_gimple_in_seq (bb_seq (bb));
+
+  tw_reset ();
+
+  return 0;
+}
+
+/* Originally, we implemented type widening over the emitted GIMPLE
+ *  * sequence. Later on, we discovered that we needed to wait till
+ *   * after OpenMP expansion, so we implemented type widening over the
+ *    * CFG-BB form.
+ *     */
+#ifdef TW_FINALIZE_STMTS
+gimple_opt_pass *
+make_pass_widen_types_stmts (gcc::context *ctxt)
+{
+  return new pass_widen_types_stmts (ctxt);
+}
+#endif
+
+gimple_opt_pass *
+make_pass_widen_types_bbs (gcc::context *ctxt)
+{
+  return new pass_widen_types_bbs (ctxt);
+}
+
+/* Notes:
+ * ------
+ *
+ * Limitations to be documented:
+ * 0. -g -fopenmp not supported.
+ *
+ * Known DejaGNU failures:
+ * 0. FAIL: gcc.dg/pr38245-2.c scan-tree-dump-not optimized "link_error"
+ *    This failure is because the optimization is dependent on the type of the variable;
+ *    once the type of the variable has changed from int to long, the inequalities in
+ *    this test case no longer hold and the code cannot be optimized anymore, consequently,
+ *    the test fails.
+ *
+ * DejaGNU failures that are not due to type-widening:
+ * 0. gcc.dg/vect/vect-120.c scan-tree-dump-times vect "vectorized 1 loops" 1
+ * 1.gcc.dg/vect/vect-120.c -flto scan-tree-dump-times vect "vectorized 1 loops" 1
+ *
+ * DejaGNU PASS'es with -fwiden-types (but FAIL's in the baseline - the baseline needs
+ * to be fixed - it just so happens that the debug information happens to be better in
+ * the type-converted case. We have verified that the generated assembly is the same in
+ * either case (or has extsw eliminated)):
+ * gcc.dg/guality/pr45882.c
+ * gcc.dg/guality/pr43177.c
+ *
+ */
diff -rNu gcc-4.9.2/libatomic/Makefile.am test/gcc-4.9.2/libatomic/Makefile.am
--- gcc-4.9.2/libatomic/Makefile.am	2014-01-03 06:24:30.000000000 +0800
+++ test/gcc-4.9.2/libatomic/Makefile.am	2018-04-02 14:15:43.000000000 +0800
@@ -101,7 +101,8 @@
 IFUNC_DEF	= -DIFUNC_ALT=$(PAT_S)
 IFUNC_OPT	= $(word $(PAT_S),$(IFUNC_OPTIONS))
 
-M_DEPS		= -MT $@ -MD -MP -MF $(DEPDIR)/$(@F).Ppo
+@AMDEP_TRUE@M_DEPS		= -MT $@ -MD -MP -MF $(DEPDIR)/$(@F).Ppo
+@AMDEP_FALSE@M_DEPS		= 
 M_SIZE		= -DN=$(PAT_N)
 M_IFUNC		= $(if $(PAT_S),$(IFUNC_DEF) $(IFUNC_OPT))
 M_FILE		= $(PAT_BASE)_n.c
diff -rNu gcc-4.9.2/libatomic/Makefile.in test/gcc-4.9.2/libatomic/Makefile.in
--- gcc-4.9.2/libatomic/Makefile.in	2014-10-30 16:28:58.000000000 +0800
+++ test/gcc-4.9.2/libatomic/Makefile.in	2018-04-02 14:15:43.000000000 +0800
@@ -300,7 +300,8 @@
 PAT_S = $(word 3,$(PAT_SPLIT))
 IFUNC_DEF = -DIFUNC_ALT=$(PAT_S)
 IFUNC_OPT = $(word $(PAT_S),$(IFUNC_OPTIONS))
-M_DEPS = -MT $@ -MD -MP -MF $(DEPDIR)/$(@F).Ppo
+@AMDEP_TRUE@M_DEPS = -MT $@ -MD -MP -MF $(DEPDIR)/$(@F).Ppo
+@AMDEP_FALSE@M_DEPS = 
 M_SIZE = -DN=$(PAT_N)
 M_IFUNC = $(if $(PAT_S),$(IFUNC_DEF) $(IFUNC_OPT))
 M_FILE = $(PAT_BASE)_n.c
diff -rNu gcc-4.9.2/libffi/doc/libffi.texi test/gcc-4.9.2/libffi/doc/libffi.texi
--- gcc-4.9.2/libffi/doc/libffi.texi	2014-02-14 00:18:13.000000000 +0800
+++ test/gcc-4.9.2/libffi/doc/libffi.texi	2018-04-02 14:15:39.000000000 +0800
@@ -359,26 +359,6 @@
 You must first describe the structure to @samp{libffi} by creating a
 new @code{ffi_type} object for it.
 
-@tindex ffi_type
-@deftp {Data type} ffi_type
-The @code{ffi_type} has the following members:
-@table @code
-@item size_t size
-This is set by @code{libffi}; you should initialize it to zero.
-
-@item unsigned short alignment
-This is set by @code{libffi}; you should initialize it to zero.
-
-@item unsigned short type
-For a structure, this should be set to @code{FFI_TYPE_STRUCT}.
-
-@item ffi_type **elements
-This is a @samp{NULL}-terminated array of pointers to @code{ffi_type}
-objects.  There is one element per field of the struct.
-@end table
-@end deftp
-
-
 @node Type Example
 @subsection Type Example
 
diff -rNu gcc-4.9.2/libgcc/config.host test/gcc-4.9.2/libgcc/config.host
--- gcc-4.9.2/libgcc/config.host	2014-03-27 23:40:31.000000000 +0800
+++ test/gcc-4.9.2/libgcc/config.host	2018-04-02 14:15:32.000000000 +0800
@@ -975,6 +975,10 @@
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff t-crtstuff-pic t-fdpbit"
 	extra_parts="$extra_parts crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o ecrti.o ecrtn.o ncrti.o ncrtn.o"
 	;;
+powerpc-*-aeabi*)
+ 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff t-crtstuff-pic t-fdpbit rs6000/t-ldbl128 t-softfp"
+	extra_parts="$extra_parts crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o ecrti.o ecrtn.o ncrti.o ncrtn.o"
+	;;
 powerpc-*-rtems*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff t-crtstuff-pic t-fdpbit"
 	extra_parts="$extra_parts crtbeginS.o crtendS.o crtbeginT.o ecrti.o ecrtn.o ncrti.o ncrtn.o"
diff -rNu gcc-4.9.2/libgcc/unwind-dw2.c test/gcc-4.9.2/libgcc/unwind-dw2.c
--- gcc-4.9.2/libgcc/unwind-dw2.c	2014-01-03 06:25:22.000000000 +0800
+++ test/gcc-4.9.2/libgcc/unwind-dw2.c	2018-04-02 14:15:36.000000000 +0800
@@ -55,10 +55,6 @@
 #define PRE_GCC3_DWARF_FRAME_REGISTERS DWARF_FRAME_REGISTERS
 #endif
 
-#ifndef DWARF_REG_TO_UNWIND_COLUMN
-#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)
-#endif
-
 /* ??? For the public function interfaces, we tend to gcc_assert that the
    column numbers are in range.  For the dwarf2 unwind info this does happen,
    although so far in a case that doesn't actually matter.
diff -rNu gcc-4.9.2/libstdc++-v3/testsuite/ext/pb_ds/regression/priority_queue_rand.cc test/gcc-4.9.2/libstdc++-v3/testsuite/ext/pb_ds/regression/priority_queue_rand.cc
--- gcc-4.9.2/libstdc++-v3/testsuite/ext/pb_ds/regression/priority_queue_rand.cc	2014-01-03 06:30:10.000000000 +0800
+++ test/gcc-4.9.2/libstdc++-v3/testsuite/ext/pb_ds/regression/priority_queue_rand.cc	2018-04-02 14:15:34.000000000 +0800
@@ -45,10 +45,10 @@
 #include <regression/common_type.hpp>
 
 #ifndef ITERATIONS
-#define ITERATIONS 5000
+#define ITERATIONS 2
 #endif
 #ifndef KEYS
-#define KEYS 10000
+#define KEYS 5
 #endif
 int
 main(int argc, char* a_p_argv[])
diff -rNu gcc-4.9.2/ltmain.sh test/gcc-4.9.2/ltmain.sh
--- gcc-4.9.2/ltmain.sh	2014-02-04 17:31:38.000000000 +0800
+++ test/gcc-4.9.2/ltmain.sh	2018-04-02 14:15:43.000000000 +0800
@@ -5628,6 +5628,9 @@
 	    absdir="$abs_ladir"
 	    libdir="$abs_ladir"
 	  else
+	    # Instead of using libdir from .la which usually points to a host path,
+	    # use the path the .la is contained in.
+	    libdir="$abs_ladir"
 	    dir="$libdir"
 	    absdir="$libdir"
 	  fi
@@ -6359,6 +6362,10 @@
 	func_warning "ignoring multiple \`-rpath's for a libtool library"
 
       install_libdir="$1"
+      if test -n "$install_libdir"; then
+	func_normal_abspath "$install_libdir"
+	install_libdir=$func_normal_abspath_result
+      fi
 
       oldlibs=
       if test -z "$rpath"; then
diff -rNu gcc-4.9.2/Makefile.in test/gcc-4.9.2/Makefile.in
--- gcc-4.9.2/Makefile.in	2014-04-05 04:53:48.000000000 +0800
+++ test/gcc-4.9.2/Makefile.in	2018-04-02 14:15:43.000000000 +0800
@@ -149,8 +149,10 @@
 	AR="$(AR_FOR_BUILD)"; export AR; \
 	AS="$(AS_FOR_BUILD)"; export AS; \
 	CC="$(CC_FOR_BUILD)"; export CC; \
+	CPP="$(CC_FOR_BUILD) -E"; export CPP; \
 	CFLAGS="$(CFLAGS_FOR_BUILD)"; export CFLAGS; \
 	CONFIG_SHELL="$(SHELL)"; export CONFIG_SHELL; \
+	CPPFLAGS="$(CPPFLAGS_FOR_BUILD)"; export CPPFLAGS; \
 	CXX="$(CXX_FOR_BUILD)"; export CXX; \
 	CXXFLAGS="$(CXXFLAGS_FOR_BUILD)"; export CXXFLAGS; \
 	GCJ="$(GCJ_FOR_BUILD)"; export GCJ; \
@@ -169,6 +171,9 @@
 # built for the build system to override those in BASE_FLAGS_TO_PASS.
 EXTRA_BUILD_FLAGS = \
 	CFLAGS="$(CFLAGS_FOR_BUILD)" \
+	CXXFLAGS="$(CXXFLAGS_FOR_BUILD)" \
+	CPP="$(CC_FOR_BUILD) -E" \
+	CPPFLAGS="$(CPPFLAGS_FOR_BUILD)" \
 	LDFLAGS="$(LDFLAGS_FOR_BUILD)"
 
 # This is the list of directories to built for the host system.
@@ -186,6 +191,7 @@
 HOST_EXPORTS = \
 	$(BASE_EXPORTS) \
 	CC="$(CC)"; export CC; \
+	CPP="$(CC) -E"; export CPP; \
 	ADA_CFLAGS="$(ADA_CFLAGS)"; export ADA_CFLAGS; \
 	CFLAGS="$(CFLAGS)"; export CFLAGS; \
 	CONFIG_SHELL="$(SHELL)"; export CONFIG_SHELL; \
@@ -706,6 +712,7 @@
 	"CC_FOR_BUILD=$(CC_FOR_BUILD)" \
 	"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)" \
 	"CXX_FOR_BUILD=$(CXX_FOR_BUILD)" \
+	"CXXFLAGS_FOR_BUILD=$(CXXFLAGS_FOR_BUILD)" \
 	"EXPECT=$(EXPECT)" \
 	"FLEX=$(FLEX)" \
 	"INSTALL=$(INSTALL)" \
diff -rNu gcc-4.9.2/Makefile.tpl test/gcc-4.9.2/Makefile.tpl
--- gcc-4.9.2/Makefile.tpl	2014-03-07 20:58:27.000000000 +0800
+++ test/gcc-4.9.2/Makefile.tpl	2018-04-02 14:15:43.000000000 +0800
@@ -154,6 +154,7 @@
 	CC="$(CC_FOR_BUILD)"; export CC; \
 	CFLAGS="$(CFLAGS_FOR_BUILD)"; export CFLAGS; \
 	CONFIG_SHELL="$(SHELL)"; export CONFIG_SHELL; \
+	CPPFLAGS="$(CPPFLAGS_FOR_BUILD)"; export CPPFLAGS; \
 	CXX="$(CXX_FOR_BUILD)"; export CXX; \
 	CXXFLAGS="$(CXXFLAGS_FOR_BUILD)"; export CXXFLAGS; \
 	GCJ="$(GCJ_FOR_BUILD)"; export GCJ; \
@@ -172,6 +173,9 @@
 # built for the build system to override those in BASE_FLAGS_TO_PASS.
 EXTRA_BUILD_FLAGS = \
 	CFLAGS="$(CFLAGS_FOR_BUILD)" \
+	CXXFLAGS="$(CXXFLAGS_FOR_BUILD)" \
+	CPP="$(CC_FOR_BUILD) -E" \
+	CPPFLAGS="$(CPPFLAGS_FOR_BUILD)" \
 	LDFLAGS="$(LDFLAGS_FOR_BUILD)"
 
 # This is the list of directories to built for the host system.
@@ -189,6 +193,7 @@
 HOST_EXPORTS = \
 	$(BASE_EXPORTS) \
 	CC="$(CC)"; export CC; \
+	CPP="$(CC) -E"; export CPP; \
 	ADA_CFLAGS="$(ADA_CFLAGS)"; export ADA_CFLAGS; \
 	CFLAGS="$(CFLAGS)"; export CFLAGS; \
 	CONFIG_SHELL="$(SHELL)"; export CONFIG_SHELL; \
